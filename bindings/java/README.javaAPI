Here is how to generate the new Java interface to PLplot using swig.

PREREQUISITE: swig-1.3.17 (or later) must be installed if you are trying the
java interface to PLplot from the cvs version of PLplot. If you are doing
this from a PLplot tarball, it should have all the swig-created files in it
already, and you shouldn't need swig at all.

(1) Install a Java SDK (Software Development Kit).  I use
IBMJava2-SDK-14.tgz which is freely downloadable from IBM.  (See
http://www-106.ibm.com/developerworks/java/jdk/linux/tested.html for product
description.)

(2) Set environment variables (under tcsh.  For bash use the export
variable=value syntax.)
# Your location for the java SDK will vary depending on where you unpack the
# tarball of the SDK.
setenv JAVA_HOME /home/software/java/IBMJava2-14/
setenv PATH $PATH":$JAVA_HOME/bin"
#Your locations will differ depending on your PLPlot configure --prefix.
setenv CLASSPATH /usr/local/plplot/lib/java

(3) The rest is highly automated.  Move to the top-level PLplot build
directory and configure, build, and install.

cd plplot
./configure --prefix=/usr/local/plplot  (+ other options you care to
specify).

Note the option --enable-java is turned on by default, and if you have
set the above environment variables the report at the end will indicate
that java was not turned off by the configure script because of some
problem.

make
make install

That completes the installation of the Java interface to PLplot.
To test it with a number of example scripts, have a look at
../../examples/java/README.javademos.

For the curious, here are some more details about the 'make' and 'make
install' steps above.

'make' automatically runs swig (version 1.3.17 or above) on plplotjavac.i
(which does an include of  plplotcapi.i) to generate all the interface files
that are needed for further processing.  To understand these two files and
what they do, you should read the latest java interface documentation from
swig version 1.3.17.  The result should be a complete interface (aside
from the limitations mentioned below) for Java to the PLplot common API.

The files generated by swig are necessary java files and plplotjavac_wrap.c.
(These files should already be pre-generated if you have received PLplot as
a tarball).  'make' builds the wrapper library libplplotjava$(LIB_TAG).so
from plplotjavac_wrap.c. 'make' also builds the class files corresponding to
the swig-generated java files, the configured config.java file, and the
hand-crafted PLStreamc.java file. (Note the c suffix on the name.  In
contrast, PLStream.java and javabind.c are historical files we are only
keeping around for reference, see below.) The relevant java files and
corresponding class files that are compiled from them make up the
plplot.core package.

'make install' installs the relevant java and class files that are part of
the plplot.core package in /usr/local/plplot/lib/java/plplot/core, installs
the module (DLL) for the java PLplot interface in the same location, and also
installs (from ../../examples/java) the example java scripts and
corresponding class files that are part of the plplot.examples package into
/usr/local/plplot/lib/java/plplot/examples. For more details about the
examples, please see ../../examples/java/README.javademos or the installed
version of that file in /usr/local/plplot/lib/java/plplot/examples.

Here is how to add a new function to the Java API for PLplot:

Edit plplotcapi.i.  Find a function with the same argument types that you
have in your new function, and copy those argument types and argument names
*EXACTLY*.  The typedefs in plplotjavac.i process argument type and argument
name patterns to produce the required java files and java interface code.
So give it the same pattern (white space doesn't matter), and you will get
the same argument processing that worked before for the old function.
In the unlikely event that you have a new pattern of argument list, then it
is time to dig into the Java interface documentation for swig.

Limitations of the current swig-generated Java interface to PLplot:

(1) The new Java interface to PLplot should be complete (aside from the 3
functions mentioned below), but that functionality has not been thoroughly
tested.  All the example scripts run fine which is an excellent sign, but
those only exercise a subset of the Java PLplot API.  In particular, none of
the many 'plg' style functions that obtain floating point or integer
information from the PLplot environment have been exercised.  You will
have to look up the JNI tutorial from Sun to see how to access variables
returned as arguments in the Java environment.

(2) plgdev, plgfnam, and plgver are the 3 PLplot functions that return
character strings in their argument.  These 3 functions are not currently
implemented (i.e., they are commented out in plplotcapi.i and the relevant
typemaps which take care of how to process the arguments of these routines
are commented out in plplotjavac.i). From the perspective of my limited JNI
knowledge the generated code in plplotjavac_wrap.c looked fine, but it just
didn't work (acted like no-op) when I tried using plgver in x01.java. (That
call has now been commented-out.) I suspect trying to return a java string
through a JNI argument list is just not supported.  All the examples in the
JNI tutorial passed the string back as the function return value. So
probably the way to implement these 3 functions is to use helper functions
which return a string like all the JNI examples, then generate the
swig-based interface to the helper functions in a natural way.  But I will
leave those experiments to somebody else who is motivated by a huge urge to
have plgdev, plgfnam, or plgver implemented in Java.

(3) A user-friendly (UF) wrapper to the raw java interface should be made to
give us a variety of different simplified argument lists similarly to the
way plplot.py wraps the plplotc extension module.  I assume that java is
more powerful than C so that it makes sense to write the UF interface in
java rather than C. Note the raw interface only allows two-dimensional xg,
and yg arrays to plcont, plshades, and plshade. The options of no xg, yg,
and one-dimensional xg, and yg should also be allowed for the UI interface.
Also note the raw interface to plParseOpts demands you must be explicit
about ORing in pls.PL_PARSE_NOPROGRAM to the parse mode parameter.  This
idiosyncrasy of Java should be hidden for the UF interface.

If someone will show me the way by writing such a java wrapper with just one
argument list simplification, I can fill out the rest following the
user-friendly simplified argument list variations that have been implemented
in plplot.py.

(4) Each example has a rather ugly combination of two commands:

    PLStreamc plsdummy = new PLStreamc();
    plplotjavac pls = new plplotjavac();
	
The first one dynamically loads the wrapper library (with the stream stuff
commented out because the plplot API is not available to that class at the
moment), and the second one loads the plplotjavac wrapper made by swig which
then pulls in everything else that is required.  Obviously, this should all
be done with one command where we refer to PLStream, the user-friendly
wrapper which in turn wraps PLStreamc, which in turn (after loading the
library) wraps plplotjavac and then finishes with the stream stuff that
Geoffrey put in for the old interface.  But it is going to require somebody
(that word again....;-)) more expert in Java than me to implement this.  As
I said above, I can fill out all the required argument list variations once
somebody shows me how to make just one of them.

(5) Only the default java double-precision can be used from Java.  That is
what the examples use (by default) and that is what works.  I believe the way
to do this properly with swig is simply to make both single and double
precision versions of the PLplot API description, and the two possible
function calls will automatically be overloaded.  But I may have that wrong.

N.B. This java precision issue should not be confused with the double or
single precision PLplot library issue.  I have been doing my testing with
both the single-precision and double-precision forms of the PLplot library,
and all double-precision java entities are transformed to the appropriate C
precision (either single or double) without problems.

(6) The callback functions should be done properly so that Java methods can
be used for transformations for the full 3-D PLplot API.  This approach
would be similar to the way the Python interface fully implements the
callback functions (see the mypltr definition and use in xw09.py).  For now,
though, we will be taking a simplified approach to the 3-d API similar to
what is done for the Tcl interface rather than the preferred complete
callback approach used for the Python interface.

Alan W. Irwin (last updated on 2003 October 1.)
_________________________________________________________________

The following notes (written by Geoffrey Furnish with some minor editing
from Alan W. Irwin & others) concern the historical way we handcrafted a
partial Java interface to PLplot.  The resulting PLStream.java and
javabind.c files were quite useful in helping to understand what was needed
for the swig interface, and they may also be used to resolve any swig
problems in the future.  Thus, we will keep them in CVS for a while,
although they are no longer used to build the Java interface to PLplot.

Here is the historical hand-crafted way to add additional PLplot API to Java
under jdk 1.3.1. This may well work for other jdk versions, but it has not
been tested for them.

1) Edit PLStream.java, add "native" prototype for a new PLplot API
   function. 

2) Do all the java setup mentioned in plplot/examples/java/README.javademos
   and execute ./configure and make from the plplot directory.  This
   should compile PLStream.java with javac.

3) (from the tmp directory) "javah plplot.core.PLStream".

4) less the big hairy file that comes out.  The name of this file should
   be something like:
      plplot_core_PLStream.h
   If you use a "/" instead of a "." in the javah command, it may look like:
      plplot_0002fcore_0002fPLStream.h
   where the "0002f" means "/".  So use the "." syntax instead.

5) Find the prototypes for the JNI functions corresponding to the new
   API(s) you prototyped in 1) above.

6) Paste that (comment block plus function decl) into javabind.c, in
   the appropriate place.  I am more-or-less trying to keep javabind.c
   and PLStream.java ordered the same way as they're declared in
   plplot.h.  But plplot.h's function decls aren't actually all
   alphabetical for one thing, and also for the Java binding, I
   hoisted a few things to the top of javabind.c, just because it made
   sense to me at the time.  I forget the exact justification, but it
   had something to do with some things seeming to me that they were
   only useful inside the JNI code (javabind.c), and not really
   something we wanted to expose to the (Java-side) user of
   PLStream.java.  Also, I kept the (only partially implemented) arg
   parsing stuff together, irrespective of alphabetization.

7) Edit out any occurances of the "0002f" string if they occur (see #2 for
   avoiding this).

8) Fill in the function parameter names.

9) Implement the function.  For this, what I do, is cut and paste.  I
   find an existing function with argument signature similar to the
   one I'm doing now, copy its function body into place, and tweak as
   required.  Maybe arg names have to be changed, or maybe only the
   actual embedded call to the PLplot API function.  For instance,
   last night I built fill by copying line's body, and changing the
   call from plline(...) to plfill(...), and that was it.  For fill3 I
   took fill's body, added handling for z, changed plfill(...) to
   plfill3(...), and that was it.  Then line3 was made from fill3 in
   the same way that fill was made from line.

10) make (builds javabind.c, libplplot)

11) Edit x??.java to use the new api, then make jdemos

12) java plplot/examples/x??, be happy.  Or fix bugs :-/, as
    required. 

I think you'll be able to do the monkey-see-monkey-do thing easily
enough to cover many of the cases.  I think the existing functions are
fairly solid examples of how to do JNI code.

There are some problems.  I think I probably have a pretty bad bug in
some of the code that handles 2-d arrays.  There are some comments
about this in there somewhere, how I tried to do something I thought
was obvious but it didn't work, so I left it somehow that works, but
am concerned that it isn't right.  I've had some more thoughts about
those things, but haven't had time to try to set it straight.  I think
it comes down to lifetime management of stuff you fetch from JNI, and
probably I have to hold onto things more carefully.  Those sections of
code will probably become substantially more complex than they are
now, which is part of why I haven't attacked it yet.

[Update, 1/18/02:  The plcont wrappers do the 2-d lifetime management
stuff right.  Other 2-d functions (using jobjectarrays) should be
retrofitted, and certainly new wrappers involving 2-d data args should
be modelled after the plcont memory management style.]

But the simpler things you should be able to handle uneventfully.
Things that take scalars, or simple arrays, I think you can follow in
the footsteps of plline(), or other simple/similar signature
functions, and be okay.

Geoffrey, 28 December 2001
