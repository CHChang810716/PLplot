// -*- C -*-

//***********************************************************************
//*  Module name declaration
//***********************************************************************

%module PLplot


//***********************************************************************
//* Header files (only plplot.h is enough)
//***********************************************************************

%inline %{
#include "plplot/plplot.h"
#ifdef HAVE_PDL
#include <pdl.h>
#include <pdlcore.h>
#endif
%}


//***********************************************************************
//* Typedefs for input/output arguments
//***********************************************************************

%inline %{
@TYPEDEFS@
%}


//***********************************************************************
//* Inline and typemaps functions for converting array references into C 
//* arrays. 
//***********************************************************************

// Utility function
%inline %{

#ifdef HAVE_PDL
static Core* PDL = NULL;
#endif

void
PLplot_perl_get_array_of_double (SV* sv, I32* n, PLFLT** ptr)
{
  int i;
  svtype type;
  AV* av;

  // Get referenced object, if that is needed  
  // sv = SvROK (sv) ?  SvRV (sv) : sv;

#ifdef HAVE_PDL
  // Check if object is a piddle
  if (sv_isobject(sv) && sv_derived_from(sv, "PDL")) {
    pdl* piddle;
    int i[1];
    int n;
    PLFLT* p;
    SV* svcore; 

    if (PDL == NULL) {
      svcore = (SV*) perl_get_sv ("PDL::SHARE", FALSE);
      if (svcore != NULL)
	PDL = (Core*) SvIV (svcore);
      else
	croak
	  ("Given PDL object as PLFLT* argument, but PDL module not loaded");
    }

    piddle = (pdl*) PDL->SvPDLV (sv);

    if (piddle->ndims != 1)
      croak ("PLFLT* as pdl object must have dim = 1");

    // The following does not work with slices.  Should use something like:    
    //    PDL->make_physvaffine (piddle);

    n = piddle->nvals;
    p = *ptr = (PLFLT*) malloc (n * sizeof (PLFLT));
    
    for (*i = 0; *i < n; (*i)++)
      p[*i] = (PLFLT) PDL->get (piddle, &i[0]);

    return;
  }
#endif

  sv = SvROK (sv) ?  SvRV (sv) : sv;
  type = SvTYPE (sv);
  if (type == SVt_PVAV) {
    av = (AV*) sv;
    *n = av_len (av) + 1;
    *ptr = (PLFLT*) malloc ((*n) * sizeof (PLFLT));
    for (i = 0; i < *n; i++) {
      SV* elem = *(av_fetch(av, i, 0));
      type = SvTYPE (elem);
      if (type == SVt_NV || type >= SVt_PVNV )
	(*ptr)[i] = (PLFLT) SvNV (elem);
      else if (type == SVt_IV)
	(*ptr)[i] = (PLFLT) SvIV (elem);
      else
	croak ("Element in PLFLT* input is not numerical");
    }
  }
  else if (type == SVt_NV || type == SVt_IV || type >= SVt_PVIV) {
    *ptr = (PLFLT*) malloc (sizeof (PLFLT)); 
    if (type == SVt_NV || type >= SVt_PVNV)
      **ptr = (PLFLT) SvNV (sv);
    else
      **ptr = (PLFLT) SvIV (sv);
    *n = 1;
  }
  else
    croak ("Wrong type for PLFLT* input");
}

%}

// Allocate array of PLFLT
// temp should be freed!!
%typemap(perl5,in) PLFLT_p_input* (PLFLT* temp) {
  int i;
  SV* sv;
  I32 n;

  temp = NULL;
  PLplot_perl_get_array_of_double ($source, &n, &temp);
  $target = (PLFLT*) temp;
}

// Allocate array of PLFLT*
// FIXME: the code belo does not free memory in case of errors
%typemap(perl5,in) PLFLT_pp_input** (PLFLT** temp) {
  int i;
  SV* sv;
  I32 m, n, size;
  AV* av;
  
  temp = NULL;
  sv = SvROK ($source) ?  SvRV ($source) : $source;
  if (SvTYPE (sv) != SVt_PVAV)
    croak ("PLFLT** input must be an array");
  av = (AV*) sv;
  n = av_len (av);
  temp = (PLFLT**) malloc ((n+1) * sizeof (PLFLT*));
  for (i = 0; i <= n; i++) {
    SV* elem =  *(av_fetch(av, i, 0));
    PLplot_perl_get_array_of_double (elem, &m, &(temp[i]));
    if (i == 0)
      size = m;
    else 
      if (size != m)
	croak ("Elements of PLFLT** input must have the same length");
  }
  $target = (PLFLT**) temp;
}

// Allocate array of PLINT
%typemap(perl5,in) PLINT_p_input* (PLINT* temp) {
  int i;
  svtype type;
  SV* sv;
  AV* av;
  I32 n;

  temp = NULL;
  sv = SvROK ($source) ?  SvRV ($source) : $source;
  type = SvTYPE (sv);
  if (type == SVt_PVAV) {
    av = (AV*) sv;
    n = av_len (av);
    temp = (PLINT*) malloc ((n+1) * sizeof (PLINT));
    for (i = 0; i <= n; i++) {
      SV* elem = *(av_fetch(av, i, 0));
      type = SvTYPE (elem);
      if (type == SVt_IV || type >= SVt_PVIV)
	temp[i] = (PLINT) SvIV (elem);
      else if (type == SVt_NV)
	temp[i] = (PLINT) SvNV (elem);
      else
	croak ("Element in PLINT* input is not numerical");
    }
  }
  else if (type == SVt_NV || type == SVt_IV || type >= SVt_PVIV) {
    temp = (PLINT*) malloc (sizeof (PLINT)); 
    if (type == SVt_IV || type >= SVt_PVIV)
      *temp = (PLINT) SvIV (sv);
    else
      *temp = (PLINT) SvNV (sv);
  }
  else
    croak ("Wrong type for PLINT* input");
  $target = (PLINT*) temp;
}

// This will free the space malloc'ed above
%typemap(perl5,freearg) PLFLT_p_input*, PLINT_p_input* {
  if ($source != NULL)
      free ($source);
}

%typemap(perl5,in) char_input* {
  $target = SvPVX (SvROK ($source) ? SvRV ($source) : $source);
}

%typemap(perl5,in) char_p_output* (char buf[1024]) {
  if (! SvROK($source))
    croak ("char* output must be a reference");
  $target = buf;
}
%typemap(perl5,argout) char_p_output* {
  sv_setpv (SvRV ($arg), (char *) $source);
}

%typemap(perl5,in) PLFLT_p_output* (PLFLT temp) {
  if (! SvROK($source))
    croak ("PLFLT* output must be a reference");
  $target = &temp;
}
%typemap(perl5,argout) PLFLT_p_output* {
  sv_setnv (SvRV ($arg), (double) *$source);
}

%typemap(perl5,in) PLINT_p_output* (PLINT temp) {
  if (! SvROK($source))
    croak ("PLINT* output must be a reference");
  $target = &temp;
}
%typemap(perl5,argout) PLINT_p_output* {
  sv_setiv (SvRV ($arg), (IV) *$source);
}

%typemap(perl5,in) PLINT_input* (PLINT temp) {
  temp = (PLINT) SvIV ($source);
  $target = (PLINT*) &temp;
}

%typemap(perl5,in) PLFLT_input* (PLFLT temp) {
  temp = (PLFLT) SvNV ($source);
  $target = (PLFLT*) &temp;
}

%typemap(perl5,in) PLPointer_input* (SV* temp) {
  temp = sv_mortalcopy ($source);
  $target = (PLPointer*) &temp;
}

//***********************************************************************
//* Function pointer stubs
//***********************************************************************

@FUNCPTR@


//***********************************************************************
//* API prototypes
//***********************************************************************

@PROTOTYPES@

// PLgrid & pltr* support

%typedef PLcGrid PLcGrid_hash;
%typedef PLPointer PLcGrid_ref;


%typemap(perl5,in) PLcGrid_hash* {
  SV* sv;
  HV* hv;
  I32 nx, ny, nz;

  sv = SvROK ($source) ?  SvRV ($source) : $source;
  if (SvTYPE (sv) != SVt_PVHV)
    croak ("PLcGrid_hash* argument must be a hash");
  hv = (HV*) sv;

  $target = (PLcGrid_hash*) malloc (sizeof (PLcGrid));

  if (hv_exists (hv, "xg", 2)) {
    PLplot_perl_get_array_of_double (*hv_fetch(hv, "xg", 2, 0),
				     &nx, &($target->xg));
    $target->nx = nx;
  }
  else 
    $target->nx = 0;

  if (hv_exists (hv, "yg", 2)) {
    PLplot_perl_get_array_of_double (*hv_fetch(hv, "yg", 2, 0),
				     &ny, &($target->yg));
    $target->ny = ny;
  }
  else 
    $target->ny = 0;

  if (hv_exists (hv, "zg", 2)) {
    PLplot_perl_get_array_of_double (*hv_fetch(hv, "zg", 2, 0),
				     &nz, &($target->zg));
    $target->nz = nz;
  }
  else 
    $target->nz = 0;
}
%typemap(perl5,argout) PLcGrid_hash* {
  $target = sv_newmortal ();
  sv_mortalcopy (newSVrv ($target, "PLplot::PLcGrid"));
  sv_setiv (SvRV ($target), (IV) $source);
  argvi++;
}

%typemap(perl5,in) PLcGrid_ref* (PLPointer temp) {
  if (! sv_isa ($source, "PLplot::PLcGrid"))
    croak ("PLcGrid_ref* argument is not a PLplot::PLcGrid object");
  temp = (PLPointer) SvIV (SvRV ($source));
  $target = &temp;
}

%inline %{
void plgrid_new (PLcGrid_hash g) {}
%}


extern void pltr0 (PLFLT_input, PLFLT_input, PLFLT_p_output*, PLFLT_p_output*, 
                   PLcGrid_ref);
extern void pltr1 (PLFLT_input, PLFLT_input, PLFLT_p_output*, PLFLT_p_output*, 
                   PLcGrid_ref);
extern void pltr2 (PLFLT_input, PLFLT_input, PLFLT_p_output*, PLFLT_p_output*, 
                   PLcGrid_ref);


// plParseOpts support

%typedef int int_p_in_out
%typedef PLINT PLINT_parseopt_mode
%typedef char char_pp_in_out

// FIXME: the allocated memory should be freed
%typemap(perl5,in) char_pp_in_out** {
  SV* sv;
  AV* av;
  I32 i, n;
  STRLEN len;
  char* ptr;

  sv = SvROK ($source) ?  SvRV ($source) : $source;
  if (SvTYPE (sv) != SVt_PVAV)
    croak ("char_pp_input** must be an array");
  av = (AV*) sv;
  n = av_len (av) + 1;
  $target = (char_pp_input**) malloc (n * sizeof (char_pp_input*));
  for (i = 0; i < n; i++) {
    SV* elem = *(av_fetch(av, i, 0));
    if (! SvPOK (elem))
      croak ("Element in char_pp_input* input is not a string");
    $target[i] = (char_pp_input*) SvPV (elem, len);
  }
}

// FIXME: $source should be freed
%typemap(perl5,out) char_pp_in_out** {
  AV* av;
  I32 i, n;

  av = (AV*) $arg;
  n = av_len (av) + 1;
  for (i = 0; i < n; i++) {
    SV* elem = newSVpv ($source[i], 0);
    sv_2mortal (elem);
    av_store (av, i, elem)
  }
}

%typemap(perl5,out) int {
  if (argvi >= items) {
    EXTEND (sp,1);
  }
  $target = sv_newmortal();
  sv_setiv ($target, (IV) $source);
  argvi++;
}

%typemap(perl5,in) int_p_in_out* (int temp) {
  SV* sv;

  if (! SvROK ($source))
    croak ("int_p_in_out* must be a reference");
  sv = SvRV ($source);
  if (! SvIOK (sv)) 
    croak ("int_p_in_out* must reference an integer");
  temp = (int) SvIV (sv);
  $target = (int_p_in_out*) &temp;
}
%typemap(perl5,argout) int_p_in_out* {
  sv_setiv (SvRV ($arg), (IV) *$source);
}

// FIXME: Add support for PL_PARSE_* defines
%typemap(perl5,in) PLINT_parseopt_mode* (PLINT temp) {
  SV* sv;

  sv = $source;
  if (! SvIOK (sv)) 
    croak ("PLINT_parseopt_mode* must an integer");
  temp = (PLINT) SvIV (sv);
  $target = (PLINT_parseopt_mode*) &temp;
}

extern int plParseOpts (int_p_in_out*, char_pp_in_out**, PLINT_parseopt_mode);

