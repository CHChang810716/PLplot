// -*- C -*-

//***********************************************************************
//*  Module name declaration
//***********************************************************************

%module PLplot


//***********************************************************************
//* Header files (only plplot.h is enough)
//***********************************************************************

%inline %{
#include "plplot/plplot.h"
%}


//***********************************************************************
//* Typedefs for input/output arguments
//***********************************************************************

%inline %{
@TYPEDEFS@
%}


//***********************************************************************
//* Inline and typemaps functions for converting array references into C 
//* arrays. 
//***********************************************************************

// Utility function
%inline %{

void
PLplot_perl_get_array_of_double (SV* sv, I32* n, PLFLT** ptr)
{
  int i;
  svtype type;
  AV* av;
  
  type = SvTYPE (sv);
  if (type == SVt_PVAV) {
    av = (AV*) sv;
    *n = av_len (av);
    *ptr = (PLFLT*) malloc ((*n+1) * sizeof (PLFLT));
    for (i = 0; i <= *n; i++) {
      SV* elem = *(av_fetch(av, i, 0));
      type = SvTYPE (elem);
      if (type == SVt_NV || type >= SVt_PVNV )
	(*ptr)[i] = (PLFLT) SvNV (elem);
      else if (type == SVt_IV)
	(*ptr)[i] = (PLFLT) SvIV (elem);
      else
	croak ("Element in PLFLT* input is not numerical");
    }
  }
  else if (type == SVt_NV || type == SVt_IV || type >= SVt_PVIV) {
    *ptr = (PLFLT*) malloc (sizeof (PLFLT)); 
    if (type == SVt_NV || type >= SVt_PVNV)
      **ptr = (PLFLT) SvNV (sv);
    else
      **ptr = (PLFLT) SvIV (sv);
    *n = 1;
  }
  else
    croak ("Wrong type for PLFLT* input");
}

%}

// Allocate array of PLFLT
%typemap(perl5,in) PLFLT_p_input* (PLFLT* temp) {
  int i;
  SV* sv;
  I32 n;

  temp = NULL;
  sv = SvROK ($source) ?  SvRV ($source) : $source;
  PLplot_perl_get_array_of_double (sv, &n, &temp);
  $target = (PLFLT*) temp;
}

// Allocate array of PLFLT*
// FIXME: the code belo does not free memeory in case of errors
%typemap(perl5,in) PLFLT_pp_input** (PLFLT** temp) {
  int i;
  SV* sv;
  I32 m, n, size;
  AV* av;
  
  temp = NULL;
  sv = SvROK ($source) ?  SvRV ($source) : $source;
  if (SvTYPE (sv) != SVt_PVAV)
    croak ("PLFLT** input must be an array");
  av = (AV*) sv;
  n = av_len (av);
  temp = (PLFLT**) malloc ((n+1) * sizeof (PLFLT*));
  for (i = 0; i <= n; i++) {
    SV* elem =  *(av_fetch(av, i, 0));
    if (SvROK (elem)) 
      elem = SvRV (elem);
    PLplot_perl_get_array_of_double (elem, &m, &(temp[i]));
    if (i == 0)
      size = m;
    else 
      if (size != m)
	croak ("Elements of PLFLT** input must have the same length");
  }
  $target = (PLFLT**) temp;
}

// Allocate array of PLINT
%typemap(perl5,in) PLINT_p_input* (PLINT* temp) {
  int i;
  svtype type;
  SV* sv;
  AV* av;
  I32 n;

  temp = NULL;
  sv = SvROK ($source) ?  SvRV ($source) : $source;
  type = SvTYPE (sv);
  if (type == SVt_PVAV) {
    av = (AV*) sv;
    n = av_len (av);
    temp = (PLINT*) malloc ((n+1) * sizeof (PLINT));
    for (i = 0; i <= n; i++) {
      SV* elem = *(av_fetch(av, i, 0));
      type = SvTYPE (elem);
      if (type == SVt_IV || type >= SVt_PVIV)
	temp[i] = (PLINT) SvIV (elem);
      else if (type == SVt_NV)
	temp[i] = (PLINT) SvNV (elem);
      else
	croak ("Element in PLINT* input is not numerical");
    }
  }
  else if (type == SVt_NV || type == SVt_IV || type >= SVt_PVIV) {
    temp = (PLINT*) malloc (sizeof (PLINT)); 
    if (type == SVt_IV || type >= SVt_PVIV)
      *temp = (PLINT) SvIV (sv);
    else
      *temp = (PLINT) SvNV (sv);
  }
  else
    croak ("Wrong type for PLINT* input");
  $target = (PLINT*) temp;
}

// This will free the space malloc'ed above
%typemap(perl5,freearg) PLFLT_p_input*, PLINT_p_input* {
  if ($source != NULL)
      free ($source);
}

%typemap(perl5,in) char_input* {
  $target = SvPVX (SvROK ($source) ? SvRV ($source) : $source);
}

%typemap(perl5,in) char_p_output* (char buf[1024], int count) {
  count = 0;
  if (! SvROK($source))
    croak ("char* output must be a reference");
  ST(argvi++) = $source;
  $target = buf;
}
%typemap(perl5,argout) char_p_output* {
  sv_setpv (SvRV(ST(count++)), (char *) $source);
  argvi--;
}

%typemap(perl5,in) PLFLT_p_output* (PLFLT fltemp, int count) {
  count = 0;
  if (! SvROK($source))
    croak ("PLFLT* output must be a reference");
  ST(argvi++) = $source;
  $target = &fltemp;
}
%typemap(perl5,argout) PLFLT_p_output* {
  sv_setnv (SvRV(ST(count++)), (double) *$source);
  argvi--;
}

%typemap(perl5,in) PLINT_p_output* (PLINT fltemp, int count) {
  count = 0;
  if (! SvROK($source))
    croak ("PLINT* output must be a reference");
  ST(argvi++) = $source;
  $target = &fltemp;
}
%typemap(perl5,argout) PLINT_p_output* {
  sv_setiv (SvRV(ST(count++)), (double) *$source);
  argvi--;
}

%typemap(perl5,in) PLINT_input* (PLINT temp) {
  temp = (PLINT) SvIV ($source);
  $target = (PLINT*) &temp;
}

%typemap(perl5,in) PLFLT_input* (PLFLT temp) {
  temp = (PLFLT) SvNV ($source);
  $target = (PLFLT*) &temp;
}

%typemap(perl5,in) PLPointer_input* {
  $target = (PLPointer*) $source;
}


//***********************************************************************
//* Function pointer stubs
//***********************************************************************

@FUNCPTR@


//***********************************************************************
//* API prototypes
//***********************************************************************

@PROTOTYPES@

// The following  decalarations are in api-c.xml

extern void pltr0 (PLFLT_input, PLFLT_input, PLFLT_p_output*, PLFLT_p_output*, 
                   PLPointer_input);
extern void pltr1 (PLFLT_input, PLFLT_input, PLFLT_p_output*, PLFLT_p_output*, 
                   PLPointer_input);
extern void pltr2 (PLFLT_input, PLFLT_input, PLFLT_p_output*, PLFLT_p_output*, 
                   PLPointer_input);


