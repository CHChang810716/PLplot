# -*-perl-*-

require Exporter;
use vars qw(%EXPORT_TAGS @EXPORT_OK);
%EXPORT_TAGS = (all => [qw(&plline_p &plstyl_p 
                           &plgrid_new &pltr0 &pltr1 &pltr2
                           &plParseOpts &plParseOpts_p
                           @EXPORTS@)]);
Exporter::export_ok_tags('all');

use Carp;

sub _assert_length ($$) {
  my $x = shift;
  my $y = shift;

  my ($m , $n) = map {
    my $r = ref;
    
    if ($r and UNIVERSAL::isa ($_, 'PDL')) {
      croak "PDL argument must be a 1D array"
	if ($_->getndims () > 1);
      ($_->dims ())[0];
    }
    elsif ((! $r) or ($r eq "SCALAR")) {
      1
    }
    elsif ($r eq "ARRAY") {
      scalar @$_;
    }
    else {
      croak "Non-conformant argument";
    }
  } ($x, $y);

  croak "Arguments must have same size"
    if ($m != $n);

  return $n;
}

sub plline_p ($$) {
  my $x = shift;
  my $y = shift;
  my $n = _assert_length ($x, $y);
  plline ($n, $x, $y);
}
  
sub plstyl_p ($$) {
  my $x = shift;
  my $y = shift;
  my $n = _assert_length ($x, $y);
  plstyl ($n, $x, $y);
}

%_plParseOpts_parse_mode = (
  PL_PARSE_PARTIAL	=> 0x0000, # For backward compatibility 
  PL_PARSE_FULL		=> 0x0001, # Process fully & exit if error 
  PL_PARSE_QUIET	=> 0x0002, # Don't issue messages 
  PL_PARSE_NODELETE	=> 0x0004, # Don't delete options after processing
  PL_PARSE_SHOWALL	=> 0x0008, # Show invisible options 
  PL_PARSE_OVERRIDE	=> 0x0010, # Obsolete 
  PL_PARSE_NOPROGRAM	=> 0x0020, # Program name NOT in *argv[0].. 
  PL_PARSE_NODASH	=> 0x0040, # Set if leading dash NOT required 
  PL_PARSE_SKIP		=> 0x0080  # Skip over unrecognized args 
);

sub plParseOpts_p ($@) {
  my $argv = shift;
  my @mode = @_;

  my $m = 0;
  foreach my $i (@mode) {
    if (! exists $_plParseOpts_parse_mode{$i}) {
      carp "plParseOpts_p: undefined parse mode $i";
    }
    else {
      $m |= $_plParseOpts_parse_mode{$i};
    }
  }

  my $argc = scalar @$argv;  
  my $ret = plParseOpts (\$argc, $argv, $m);
  @$argv = @$argv[0..($$argc - 1)];
}

1;

