/* $Id$
 * $Log$
 * Revision 1.21  1995/10/22 17:39:16  mjl
 * Moved pls_auto_path to this file, and inserted call to it by Pltcl_Init to
 * allow more intelligent autoload behavior by pltcl and similarly enhanced
 * tclsh's.
 *
 * Revision 1.20  1995/10/19  00:02:25  mjl
 * Some more cleaning up, somehow I missed all this last time.
 *
 * Revision 1.19  1995/10/16  18:27:31  mjl
 * Lots of cleaning up including eliminating obsolete code.
 *
 * Revision 1.18  1995/07/04  21:28:03  furnish
 * Reimplemented plshade support so that it now allows coordinate
 * mappings, just as was done for plcont recently.  No user defined
 * mappings supported at this time, just pltr0 (the default), pltr1 and
 * pltr2.  Wraped coords are also supported.
 *
 * Revision 1.17  1995/07/04  18:53:48  furnish
 * Reimplemented the Tcl contouring support.  This time I made a serious
 * attempt to support coordinate mappings from Tcl.  Built in support is
 * provided for pltr0, pltr1, and pltr2.  NO support is available for
 * user defined coordinate transformation functions.  They'll just have
 * to set up coordinate arrays and use pltr2, I guess.  To ameliorate
 * this, I did however add support for one very common thing people need
 * to do, which is to support plotting of data defined on a grid which is
 * wrapped in one coordinate or the other.  Much testing still to do..
 *
 * Revision 1.16  1995/07/01  20:25:57  furnish
 * Implemented plot3d and plmesh.
 *
 * Revision 1.15  1995/06/29  20:23:13  furnish
 * Hack out even more of the old hand coded interface functions,
 * replacing with an even larger set of autogenerated Tcl command
 * procedures.  Also some fixes to error reporting to make it easier to
 * understand what went wrong.
 *
 * Revision 1.14  1995/06/28  14:51:28  furnish
 * Hack out most of the Tcl command procedures (using cpp #if 0
 * ... #endif), and include the new autogenerated versions.  This code
 * needs to be exercised, and once it is believed to be functioning
 * reliably, this file can be cut waaaay down to size.
 *
 * Revision 1.13  1995/06/22  18:51:53  furnish
 * Tcl support for plvpas, grrrrrr.
 *
 * Revision 1.12  1995/06/09  22:46:37  mjl
 * Eliminated vestigial lookup of TclMatrix variable in favor of new syntax.
 *
 * Revision 1.11  1995/05/07  03:14:26  mjl
 * Added new Tcl API functions plscol0 and plscolbg for color setting.
 *
 * Revision 1.10  1995/03/17  07:54:33  mjl
 * Fixed Copyright message and other cleaning up.
 *
 * Revision 1.9  1995/01/27  03:56:24  mjl
 * Added "loopback" command: gobbles the following word, which must be "cmd",
 * and processes the remaining arguments as any other plplot/Tcl command.
 * This allows scripts involving widget commands -- of the form <widget> cmd
 * <plplot command> -- to be processed by pltcl, with <widget> replaced
 * by "loopback".
 *
 * Revision 1.8  1994/10/10  19:45:07  furnish
 * Imlemented plshade from Tcl.
 *
 * Revision 1.7  1994/10/10  17:25:30  furnish
 * Add knowledge of contouring.
 *
 * Revision 1.6  1994/09/23  07:53:14  mjl
 * New Tcl API functions added: plend, plend1, plsstrm, and plinit.
 */

/*
    tclAPI.c

    Copyright 1994, 1995
    Maurice LeBrun			mjl@dino.ph.utexas.edu
    Institute for Fusion Studies	University of Texas at Austin

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.

    You should have received a copy of the GNU Library General Public
    License along with this library; if not, write to the Free
    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	
    This module implements a Tcl command set for interpretively calling
    PLplot functions.  Each Tcl command is responsible for calling the
    appropriate underlying function in the C API.  Can be used with any
    driver, in principle.
*/

#include "plplotP.h"
#include "pltcl.h"
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#include "tclgen.h"

/* PLplot/Tcl API handlers.  Prototypes must come before Cmds struct */

static int loopbackCmd	(ClientData, Tcl_Interp *, int, char **);
static int plcontCmd	(ClientData, Tcl_Interp *, int, char **);
static int plmeshCmd	(ClientData, Tcl_Interp *, int, char **);
static int plot3dCmd	(ClientData, Tcl_Interp *, int, char **);
static int plsetoptCmd	(ClientData, Tcl_Interp *, int, char **);
static int plshadeCmd	(ClientData, Tcl_Interp *, int, char **);

/*
 * The following structure defines all of the commands in the PLplot/Tcl
 * core, and the C procedures that execute them.
 */

typedef struct Command {
    int (*proc)();		/* Procedure to process command. */
    ClientData clientData;	/* Arbitrary value to pass to proc. */
    int *deleteProc;		/* Procedure to invoke when deleting
				 * command. */
    ClientData deleteData;	/* Arbitrary value to pass to deleteProc
				 * (usually the same as clientData). */
} Command;

typedef struct {
    char *name;
    int (*proc)();
} CmdInfo;

/* Built-in commands, and the procedures associated with them */

static CmdInfo Cmds[] = {
    {"loopback",	loopbackCmd},
#include "tclgen_s.h"
    {"plcol",		plcol0Cmd},
    {"plcont",		plcontCmd},
    {"plmesh",		plmeshCmd},
    {"plot3d",		plot3dCmd},
    {"plsetopt",	plsetoptCmd},
    {"plshade",		plshadeCmd},
    {NULL,		NULL}
};

/* Hash table and associated flag for directing control */

static int cmdTable_initted;
static Tcl_HashTable cmdTable;

/* Static functions */

/* Evals the specified command, aborting on an error. */

static int
tcl_cmd(Tcl_Interp *interp, char *cmd);

/*--------------------------------------------------------------------------*\
 * Append_Cmdlist
 *
 * Generates command list from Cmds, storing into interp->result.
\*--------------------------------------------------------------------------*/

static void
Append_Cmdlist(Tcl_Interp *interp)
{
    static int inited = 0;
    static char** namelist;
    register CmdInfo *cmdInfoPtr;
    int i, j, ncmds = sizeof(Cmds)/sizeof(CmdInfo);

    if (!inited) {
	namelist = (char **) malloc( ncmds * sizeof(char *) );

	for( i=0; i < ncmds; i++ )
	    namelist[i] = Cmds[i].name;

    /* Sort the list, couldn't get qsort to do it for me for some reason, grrr. */

	for( i=0; i < ncmds-1; i++ )
	    for( j=i+1; j < ncmds; j++ ) {
		if (strcmp(namelist[i], namelist[j]) > 0) {
		    char *t = namelist[i];
		    namelist[i] = namelist[j];
		    namelist[j] = t;
		}
	    }

	inited = 1;
    }

    for( i=0; i < ncmds; i++ )
	Tcl_AppendResult(interp, " ", namelist[i], (char *) NULL);
}

/*--------------------------------------------------------------------------*\
 * plTclCmd_Init
 *
 * Sets up command hash table for use with plframe to PLplot Tcl API.
 *
 * Right now all API calls are allowed, although some of these may not
 * make much sense when used with a widget.
\*--------------------------------------------------------------------------*/

static void
plTclCmd_Init(Tcl_Interp *interp)
{
    register Command *cmdPtr;
    register CmdInfo *cmdInfoPtr;

    Tcl_InitHashTable(&cmdTable, TCL_STRING_KEYS);

/* Create the hash table entry for each command */

    for (cmdInfoPtr = Cmds; cmdInfoPtr->name != NULL; cmdInfoPtr++) {
	int new;
	Tcl_HashEntry *hPtr;

	hPtr = Tcl_CreateHashEntry(&cmdTable, cmdInfoPtr->name, &new);
	if (new) {
	    cmdPtr = (Command *) ckalloc(sizeof(Command));
	    cmdPtr->proc = cmdInfoPtr->proc;
	    cmdPtr->clientData = (ClientData) NULL;
	    cmdPtr->deleteProc = NULL;
	    cmdPtr->deleteData = (ClientData) NULL;
	    Tcl_SetHashValue(hPtr, cmdPtr);
	}
    }
}

/*--------------------------------------------------------------------------*\
 * plTclCmd
 *
 * Front-end to PLplot/Tcl API for use from Tcl commands (e.g. plframe).
 *
 * This command is called by the plframe widget to process subcommands
 * of the "cmd" plframe widget command.  This is the plframe's direct
 * plotting interface to the PLplot library.  This routine can be called
 * from other commands that want a similar capability.
 *
 * In a widget-based application, a PLplot "command" doesn't make much
 * sense by itself since it isn't connected to a specific widget.
 * Instead, you have widget commands.  This allows arbitrarily many
 * widgets and requires a slightly different syntax than if there were
 * only a single output device.  That is, the widget name (and in this
 * case, the "cmd" widget command, after that comes the subcommand)
 * must come first.  The plframe widget checks first for one of its
 * internal subcommands, those specifically designed for use with the
 * plframe widget.  If not found, control comes here. 
\*--------------------------------------------------------------------------*/

int
plTclCmd(char *cmdlist, Tcl_Interp *interp, int argc, char **argv)
{
    register Tcl_HashEntry *hPtr;
    int result = TCL_OK;

/* Create hash table on first call */

    if ( ! cmdTable_initted) {
	cmdTable_initted = 1;
	plTclCmd_Init(interp);
    }

/* no option -- return list of available PLplot commands */

    if (argc == 0) {
	Tcl_AppendResult(interp, cmdlist, (char *) NULL);
	Append_Cmdlist(interp);
	return TCL_OK;
    }

/* Pick out the desired command */

    hPtr = Tcl_FindHashEntry(&cmdTable, argv[0]);
    if (hPtr == NULL) {
	Tcl_AppendResult(interp, "bad option \"", argv[0],
			 "\" to \"cmd\": must be one of ",
			 cmdlist, (char *) NULL);
	Append_Cmdlist(interp);
	result = TCL_ERROR;
    }
    else {
	register Command *cmdPtr = (Command *) Tcl_GetHashValue(hPtr);
	result = (*cmdPtr->proc)(cmdPtr->clientData, interp, argc, argv);
    }

    return result;
}

/*--------------------------------------------------------------------------*\
 * loopbackCmd
 *
 * Loop-back command for Tcl interpreter.  Main purpose is to enable a
 * compatible command syntax whether you are executing directly through a
 * Tcl interpreter or a plframe widget.  I.e. the syntax is:
 *
 *	<widget> cmd <PLplot command>		(widget command)
 *	loopback cmd <PLplot command>		(pltcl command)
 *
 * This routine is essentially the same as plTclCmd but without some of
 * the window dressing required by the plframe widget.
\*--------------------------------------------------------------------------*/

static int
loopbackCmd(ClientData clientData, Tcl_Interp *interp,
	    int argc, char **argv)
{
    register Tcl_HashEntry *hPtr;
    int result = TCL_OK;

    argc--; argv++;
    if (argc == 0 || (strcmp(argv[0], "cmd") != 0)) {
	Tcl_AppendResult(interp, "bad option to \"loopback\": must be ",
			 "\"cmd ?options?\" ", (char *) NULL);
	return TCL_ERROR;
    }

/* Create hash table on first call */

    if ( ! cmdTable_initted) {
	cmdTable_initted = 1;
	plTclCmd_Init(interp);
    }

/* no option -- return list of available PLplot commands */

    argc--; argv++;
    if (argc == 0) {
	Append_Cmdlist(interp);
	return TCL_OK;
    }

/* Pick out the desired command */

    hPtr = Tcl_FindHashEntry(&cmdTable, argv[0]);
    if (hPtr == NULL) {
	Tcl_AppendResult(interp,
			 "bad option to \"loopback cmd\": must be one of ",
			 (char *) NULL);
	Append_Cmdlist(interp);
	result = TCL_ERROR;
    }
    else {
	register Command *cmdPtr = (Command *) Tcl_GetHashValue(hPtr);
	result = (*cmdPtr->proc)(cmdPtr->clientData, interp, argc, argv);
    }

    return result;
}

/*--------------------------------------------------------------------------*\
 * Pltcl_Init
 *
 * Initialization routine for extended tclsh's.
 * Sets up auto_path, creates the matrix command and numerous commands for
 * interfacing to PLplot.  Should not be used in a widget-based system.
\*--------------------------------------------------------------------------*/

int
Pltcl_Init( Tcl_Interp *interp )
{
    register CmdInfo *cmdInfoPtr;

/* matrix -- matrix support command */

    Tcl_CreateCommand(interp, "matrix", Tcl_MatrixCmd,
                      (ClientData) NULL, (void (*)(ClientData)) NULL);

/* PLplot API commands */

    for (cmdInfoPtr = Cmds; cmdInfoPtr->name != NULL; cmdInfoPtr++) {

	Tcl_CreateCommand(interp, cmdInfoPtr->name, cmdInfoPtr->proc,
			  (ClientData) NULL, (void (*)(ClientData)) NULL);
    }

/* Set up auto_path */

    if (pls_auto_path(interp) == TCL_ERROR)
	return TCL_ERROR;

    return TCL_OK;
}

/*----------------------------------------------------------------------*\
 * pls_auto_path
 *
 * Sets up auto_path variable.  
 * Directories are added to the FRONT of autopath.  Therefore, they are
 * searched in reverse order of how they are listed below.
 *
 * Note: there is no harm in adding extra directories, even if they don't
 * actually exist (aside from a slight increase in processing time when
 * the autoloaded proc is first found).
\*----------------------------------------------------------------------*/

int
pls_auto_path(Tcl_Interp *interp)
{
    char *buf, *ptr=NULL, *dn;
#ifdef DEBUG
    char *path;
#endif

    buf = (char *) malloc(256 * sizeof(char));

/* Add TCL_DIR */

#ifdef TCL_DIR
    Tcl_SetVar(interp, "dir", TCL_DIR, TCL_GLOBAL_ONLY);
    if (tcl_cmd(interp, "set auto_path \"$dir $auto_path\"") == TCL_ERROR)
	return TCL_ERROR;
#ifdef DEBUG
    fprintf(stderr, "adding %s to auto_path\n", TCL_DIR);
    path = Tcl_GetVar(interp, "auto_path", 0);
    fprintf(stderr, "auto_path is %s\n", path);
#endif
#endif

/* Add $HOME/tcl */

    if ((dn = getenv("HOME")) != NULL) {
	plGetName(dn, "tcl", "", &ptr);
	Tcl_SetVar(interp, "dir", ptr, 0);
	if (tcl_cmd(interp, "set auto_path \"$dir $auto_path\"") == TCL_ERROR)
	    return TCL_ERROR;
#ifdef DEBUG
	fprintf(stderr, "adding %s to auto_path\n", ptr);
	path = Tcl_GetVar(interp, "auto_path", 0);
	fprintf(stderr, "auto_path is %s\n", path);
#endif
    }

/* Add PL_TCL_ENV = $(PL_TCL) */

#if defined (PL_TCL_ENV)
    if ((dn = getenv(PL_TCL_ENV)) != NULL) {
	plGetName(dn, "", "", &ptr);
	Tcl_SetVar(interp, "dir", ptr, 0);
	if (tcl_cmd(interp, "set auto_path \"$dir $auto_path\"") == TCL_ERROR)
	    return TCL_ERROR;
#ifdef DEBUG
	fprintf(stderr, "adding %s to auto_path\n", ptr);
	path = Tcl_GetVar(interp, "auto_path", 0);
	fprintf(stderr, "auto_path is %s\n", path);
#endif
    }
#endif  /* PL_TCL_ENV */

/* Add PL_HOME_ENV/tcl = $(PL_HOME_ENV)/tcl */

#if defined (PL_HOME_ENV)
    if ((dn = getenv(PL_HOME_ENV)) != NULL) {
	plGetName(dn, "tcl", "", &ptr);
	Tcl_SetVar(interp, "dir", ptr, 0);
	if (tcl_cmd(interp, "set auto_path \"$dir $auto_path\"") == TCL_ERROR)
	    return TCL_ERROR;
#ifdef DEBUG
	fprintf(stderr, "adding %s to auto_path\n", ptr);
	path = Tcl_GetVar(interp, "auto_path", 0);
	fprintf(stderr, "auto_path is %s\n", path);
#endif
    }
#endif  /* PL_HOME_ENV */

/* Add cwd */

    if (getcwd(buf, 256) == NULL) 
	return TCL_ERROR;

    Tcl_SetVar(interp, "dir", buf, 0);
    if (tcl_cmd(interp, "set auto_path \"$dir $auto_path\"") == TCL_ERROR)
	return TCL_ERROR;

#ifdef DEBUG
    fprintf(stderr, "adding %s to auto_path\n", buf);
    path = Tcl_GetVar(interp, "auto_path", 0);
    fprintf(stderr, "auto_path is %s\n", path);
#endif

    free_mem(buf);
    free_mem(ptr);

    return TCL_OK;
}

/*----------------------------------------------------------------------*\
 * tcl_cmd
 *
 * Evals the specified command, aborting on an error.
\*----------------------------------------------------------------------*/

static int
tcl_cmd(Tcl_Interp *interp, char *cmd)
{
    int result;

    result = Tcl_VarEval(interp, cmd, (char **) NULL);
    if (result != TCL_OK) {
	fprintf(stderr, "TCL command \"%s\" failed:\n\t %s\n",
		cmd, interp->result);
    }
    return result;
}

/*--------------------------------------------------------------------------*\
 * PLplot API Calls
 *
 * Any call that results in something actually being plotted must be
 * followed by by a call to plflush(), to make sure all output from 
 * that command is finished.  Devices that have text/graphics screens
 * (e.g. Tek4xxx and emulators) implicitly switch to the graphics screen
 * before graphics commands, so a plgra() is not necessary in this case.
 * Although if you switch to the text screen via user control (instead of
 * using pltext()), the device will get confused.
\*--------------------------------------------------------------------------*/

/* TEMPLATE */
#if 0
/*--------------------------------------------------------------------------*\
 * plxxxCmd
 *
 * Processes plxxx Tcl command.
\*--------------------------------------------------------------------------*/

static int
plxxxCmd(ClientData clientData, Tcl_Interp *interp,
	 int argc, char **argv)
{
    if (argc != 0 ) {
	Tcl_AppendResult(interp, "wrong # args: should be \"",
			 argv[0], "\"",
			 (char *) NULL);
	return TCL_ERROR;
    }


    plflush();
    return TCL_OK;
}

#endif

/*
  Now go pick up all the autogenerated Tcl command procs.
  */

static char buf[200];

#include "tclgen.c"

/*--------------------------------------------------------------------------*\
 * plcontCmd
 *
 * Processes plcont Tcl command.
 * 
 * The C function is:
 * void
 * c_plcont(PLFLT **f, PLINT nx, PLINT ny, PLINT kx, PLINT lx,
 * 	 PLINT ky, PLINT ly, PLFLT *clevel, PLINT nlevel,
 * 	 void (*pltr) (PLFLT, PLFLT, PLFLT *, PLFLT *, PLPointer),
 * 	 PLPointer pltr_data);
 * 
 * Since f will be specified by a Tcl Matrix, nx and ny are redundant, and
 * are automatically eliminated.  Same for nlevel, since clevel will be a 1-d
 * Tcl Matrix.  Since most people plot the whole data set, we will allow kx,
 * lx and ky, ly to be defaulted--either you specify all four, or none of
 * them.  We allow three ways of specifying the coordinate transforms: 1)
 * Nothing, in which case we will use the identity mapper pltr0 2) pltr1, in
 * which case the next two args must be 1-d Tcl Matricies 3) pltr2, in which
 * case the next two args must be 2-d Tcl Matricies.  Finally, a new
 * paramater is allowed at the end to specify which, if either, of the
 * coordinates wrap on themselves.  Can be 1 or x, or 2 or y.  Nothing or 0
 * specifies that neither coordinate wraps.
 * 
 * So, the new call from Tcl is:
 * 	plcont f [kx lx ky ly] clev [pltr x y] [wrap]
 * 
\*--------------------------------------------------------------------------*/

static int tclmateval_modx, tclmateval_mody;

PLFLT tclMatrix_feval (PLINT i, PLINT j, PLPointer p)
{
    tclMatrix *matPtr = (tclMatrix *) p;

    i = i % tclmateval_modx;
    j = j % tclmateval_mody;

/*    printf( "tclMatrix_feval: i=%d j=%d f=%f\n", i, j,
      matPtr->fdata[I2D(i,j)] );
	    */
    return matPtr->fdata[I2D(i,j)];
}

static int
plcontCmd( ClientData clientData, Tcl_Interp *interp,
	   int argc, char *argv[] )
{
    tclMatrix *matPtr, *matf, *matclev;
    PLINT nx, ny, kx, lx, ky, ly, nclev;
    char *pltrname = "pltr0";
    tclMatrix *mattrx, *mattry;

    int arg3_is_kx = 1, i, j;
    void (*pltr) (PLFLT, PLFLT, PLFLT *, PLFLT *, PLPointer);
    PLPointer pltr_data = NULL;
    PLcGrid  cgrid1;
    PLcGrid2 cgrid2;

    int wrap = 0;

    if (argc  < 3 ) {
	Tcl_AppendResult( interp, "wrong # args: see documentation for ",
			 argv[0], (char *) NULL);
	return TCL_ERROR;
    }

    matf = Tcl_GetMatrixPtr( interp, argv[1] );

    if (matf->dim != 2) {
	interp->result = "Must use 2-d data.";
	return TCL_ERROR;
    } else {
	nx = matf->n[0];
	ny = matf->n[1];

	tclmateval_modx = nx;
	tclmateval_mody = ny;

	kx = 1; lx = nx;
	ky = 1; ly = ny;
    }

/* Now check the next argument.  If it is all digits, then it must be kx,
   otherwise it is the name of clev. */

    for( i=0; i < strlen( argv[2] ) && arg3_is_kx; i++ )
	if (!isdigit(argv[2][i]))
	    arg3_is_kx = 0;

    if (arg3_is_kx) {
    /* Check that there are enough args */
	if (argc < 7) {
	    interp->result = "plcont, bogus syntax";
	    return TCL_ERROR;
	}

    /* Peel off the ones we need */
	kx = atoi( argv[3] );
	lx = atoi( argv[4] );
	ky = atoi( argv[5] );
	ly = atoi( argv[6] );

    /* adjust argc, argv to reflect our consumption */
	argc -= 6, argv += 6;
    } else {
	argc -= 2, argv += 2;
    }

/* The next argument has to be clev */

    if (argc < 1) {
	interp->result = "plcont, bogus syntax";
	return TCL_ERROR;
    }

    matclev = Tcl_GetMatrixPtr( interp, argv[0] );
    nclev = matclev->n[0];

    if (matclev->dim != 1) {
	interp->result = "clev must be 1-d matrix.";
	return TCL_ERROR;
    }

    argc--, argv++;

/* Now handle trailing optional parameters, if any */

    if (argc >= 3) {
    /* There is a pltr spec, parse it. */
	pltrname = argv[0];
	mattrx = Tcl_GetMatrixPtr( interp, argv[1] );
	mattry = Tcl_GetMatrixPtr( interp, argv[2] );

	argc -= 3, argv += 3;
    }

    if (argc) {
    /* There is a wrap spec, get it. */
	wrap = atoi( argv[0] );

    /* Hmm, I said the the doc they could also say x or y, have to come back
       to this... */

	argc--, argv++;
    }

/* There had better not be anything else on the command line by this point. */

    if (argc) {
	interp->result = "plcont, bogus syntax, too many args.";
	return TCL_ERROR;
    }

/* Now we need to set up the data for contouring. */

    if ( !strcmp( pltrname, "pltr0" ) ) {
	pltr = pltr0;

    /* wrapping is only supported for pltr2. */
	if (wrap) {
	    interp->result = "Must use pltr2 if want wrapping.";
	    return TCL_ERROR;
	}
    }
    else if ( !strcmp( pltrname, "pltr1" ) ) {
	pltr = pltr1;
	cgrid1.xg = mattrx->fdata;
	cgrid1.nx = nx;
	cgrid1.yg = mattry->fdata;
	cgrid1.ny = ny;

    /* wrapping is only supported for pltr2. */
	if (wrap) {
	    interp->result = "Must use pltr2 if want wrapping.";
	    return TCL_ERROR;
	}

	if (mattrx->dim != 1 || mattry->dim != 1) {
	    interp->result = "Must use 1-d coord arrays with pltr1.";
	    return TCL_ERROR;
	}

	pltr_data = &cgrid1;
    }
    else if ( !strcmp( pltrname, "pltr2" ) ) {
    /* printf( "plcont, setting up for pltr2\n" ); */
	if (!wrap) {
	/* printf( "plcont, no wrapping is needed.\n" ); */
	    plAlloc2dGrid( &cgrid2.xg, nx, ny );
	    plAlloc2dGrid( &cgrid2.yg, nx, ny );
	    cgrid2.nx = nx;
	    cgrid2.ny = ny;

	    matPtr = mattrx;
	    for( i=0; i < nx; i++ )
		for( j=0; j < ny; j++ )
		    cgrid2.xg[i][j] = mattrx->fdata[ I2D(i,j) ];

	    matPtr = mattry;
	    for( i=0; i < nx; i++ )
		for( j=0; j < ny; j++ )
		    cgrid2.yg[i][j] = mattry->fdata[ I2D(i,j) ];
	}
	else if (wrap == 1) {
	    plAlloc2dGrid( &cgrid2.xg, nx+1, ny );
	    plAlloc2dGrid( &cgrid2.yg, nx+1, ny );
	    cgrid2.nx = nx+1;
	    cgrid2.ny = ny;

	    matPtr = mattrx;
	    for( i=0; i < nx; i++ )
		for( j=0; j < ny; j++ )
		    cgrid2.xg[i][j] = mattrx->fdata[ I2D(i,j) ];

	    matPtr = mattry;
	    for( i=0; i < nx; i++ )
		for( j=0; j < ny; j++ )
		    cgrid2.yg[i][j] = mattry->fdata[ I2D(i,j) ];

	    for( j=0; j < ny; j++ ) {
		cgrid2.xg[nx][j] = cgrid2.xg[0][j];
		cgrid2.yg[nx][j] = cgrid2.yg[0][j];
	    }

	    nx++;
	}
	else if (wrap == 2) {
	    plAlloc2dGrid( &cgrid2.xg, nx, ny+1 );
	    plAlloc2dGrid( &cgrid2.yg, nx, ny+1 );
	    cgrid2.nx = nx;
	    cgrid2.ny = ny+1;

	    matPtr = mattrx;
	    for( i=0; i < nx; i++ )
		for( j=0; j < ny; j++ )
		    cgrid2.xg[i][j] = mattrx->fdata[ I2D(i,j) ];

	    matPtr = mattry;
	    for( i=0; i < nx; i++ )
		for( j=0; j < ny; j++ )
		    cgrid2.yg[i][j] = mattry->fdata[ I2D(i,j) ];

	    for( i=0; i < nx; i++ ) {
		cgrid2.xg[i][ny] = cgrid2.xg[i][0];
		cgrid2.yg[i][ny] = cgrid2.yg[i][0];
	    }

	    ny++;
	}
	else {
	    interp->result =
		"Invalid wrap specifier, must be <empty>, 1 or 2.";
	    return TCL_ERROR;
	}

	pltr = pltr2;
	pltr_data = &cgrid2;
    }
    else {
	Tcl_AppendResult( interp,
			  "Unrecognized coordinate transformation spec:",
			  pltrname, ", must be pltr0 pltr1 or pltr2.",
			  (char *) NULL );
	return TCL_ERROR;
    }
/*
    printf( "plcont: nx=%d ny=%d kx=%d lx=%d ky=%d ly=%d\n",
	    nx, ny, kx, lx, ky, ly );
    printf( "plcont: tclmateval_modx=%d tclmateval_mody=%d\n",
	    tclmateval_modx, tclmateval_mody );
    printf( "plcont: nclev=%d\n", nclev );
    */

/* contour the data.*/

    plcontf( tclMatrix_feval, matf, nx, ny,
	     kx, lx, ky, ly,
	     matclev->fdata, nclev,
	     pltr, pltr_data );

/* Now free up any space which got allocated for our coordinate trickery. */

    if (pltr == pltr1) {
    /* Hmm, actually, nothing to do here currently, since we just used the
       Tcl Matrix data directly, rather than allocating private space. */
    }
    else if (pltr == pltr2) {
    /* printf( "plcont, freeing space for grids used in pltr2\n" ); */
	plFree2dGrid( cgrid2.xg, nx, ny );
	plFree2dGrid( cgrid2.yg, nx, ny );
    }

    plflush();
    return TCL_OK;
}

/*--------------------------------------------------------------------------*\
 * plmeshCmd
 *
 * Processes plmesh Tcl command.
 *
 * We support 3 different invocation forms:
 * 1)	plmesh x y z nx ny opt
 * 2)	plmesh x y z opt
 * 3)	plmesh z opt
 *
 * Form 1) is an exact mirror of the usual C API.  In form 2) we infer nx and
 * ny from the input data, and in form 3 we inver nx and ny, and also take
 * the x and y arrays to just be integral spacing.
\*--------------------------------------------------------------------------*/

static int
plmeshCmd( ClientData clientData, Tcl_Interp *interp,
	   int argc, char *argv[] )
{
    PLINT nx, ny, opt;
    PLFLT *x, *y, **z;
    tclMatrix *matx, *maty, *matz, *matPtr;
    int i;

    if (argc == 7) {
	nx   = atoi( argv[4] );
	ny   = atoi( argv[5] );
	opt  = atoi( argv[6] );

	matx = Tcl_GetMatrixPtr( interp, argv[1] );
	maty = Tcl_GetMatrixPtr( interp, argv[2] );
	matz = Tcl_GetMatrixPtr( interp, argv[3] );
	matPtr = matz;		/* For dumb indexer macro, grrrr. */

	if ( matx->type != TYPE_FLOAT ||
	     maty->type != TYPE_FLOAT ||
	     matz->type != TYPE_FLOAT ) {
	    interp->result = "x y and z must all be float";
	    return TCL_ERROR;
	}

	if ( matx->dim != 1 || matx->n[0] != nx ||
	     maty->dim != 1 || maty->n[0] != ny ||
	     matz->dim != 2 || matz->n[0] != nx || matz->n[1] != ny ) {
	    interp->result = "Inconsistent dimensions";
	    return TCL_ERROR;
	}

	x = matx->fdata;
	y = maty->fdata;

	z = (PLFLT **) malloc( nx * sizeof(PLFLT *) );
	for( i=0; i < nx; i++ )
	    z[i] = &matz->fdata[ I2D(i,0) ];
    }
    else if (argc == 5) {
	opt  = atoi( argv[4] );

	matx = Tcl_GetMatrixPtr( interp, argv[1] );
	maty = Tcl_GetMatrixPtr( interp, argv[2] );
	matz = Tcl_GetMatrixPtr( interp, argv[3] );
	matPtr = matz;		/* For dumb indexer macro, grrrr. */

	if ( matx->type != TYPE_FLOAT ||
	     maty->type != TYPE_FLOAT ||
	     matz->type != TYPE_FLOAT ) {
	    interp->result = "x y and z must all be float";
	    return TCL_ERROR;
	}

	nx = matx->n[0]; ny = maty->n[0];

	if ( matx->dim != 1 || matx->n[0] != nx ||
	     maty->dim != 1 || maty->n[0] != ny ||
	     matz->dim != 2 || matz->n[0] != nx || matz->n[1] != ny ) {
	    interp->result = "Inconsistent dimensions";
	    return TCL_ERROR;
	}

	x = matx->fdata;
	y = maty->fdata;

	z = (PLFLT **) malloc( nx * sizeof(PLFLT *) );
	for( i=0; i < nx; i++ )
	    z[i] = &matz->fdata[ I2D(i,0) ];
    }
    else if (argc == 3) {
	interp->result = "unimplemented";
	return TCL_ERROR;
    }
    else {
	Tcl_AppendResult(interp, "wrong # args: should be \"plmesh ",
			 "x y z nx ny opt\", or a valid contraction ",
			 "thereof.", (char *) NULL);
	return TCL_ERROR;
    }

    plmesh( x, y, z, nx, ny, opt );

    if (argc == 7) {
	free(z);
    }
    else if (argc == 5) {
	free(z);
    }
    else {			/* argc == 3 */
    }

    plflush();
    return TCL_OK;
}

/*--------------------------------------------------------------------------*\
 * plot3dCmd
 *
 * Processes plot3d Tcl command.
 *
 * We support 3 different invocation forms:
 * 1)	plot3d x y z nx ny opt side
 * 2)	plot3d x y z opt side
 * 3)	plot3d z opt side
 *
 * Form 1) is an exact mirror of the usual C API.  In form 2) we infer nx and
 * ny from the input data, and in form 3 we inver nx and ny, and also take
 * the x and y arrays to just be integral spacing.
\*--------------------------------------------------------------------------*/

static int
plot3dCmd( ClientData clientData, Tcl_Interp *interp,
	   int argc, char *argv[] )
{
    PLINT nx, ny, opt, side;
    PLFLT *x, *y, **z;
    tclMatrix *matx, *maty, *matz, *matPtr;
    int i;

    if (argc == 8) {
	nx   = atoi( argv[4] );
	ny   = atoi( argv[5] );
	opt  = atoi( argv[6] );
	side = atoi( argv[7] );

	matx = Tcl_GetMatrixPtr( interp, argv[1] );
	maty = Tcl_GetMatrixPtr( interp, argv[2] );
	matz = Tcl_GetMatrixPtr( interp, argv[3] );
	matPtr = matz;		/* For dumb indexer macro, grrrr. */

	if ( matx->type != TYPE_FLOAT ||
	     maty->type != TYPE_FLOAT ||
	     matz->type != TYPE_FLOAT ) {
	    interp->result = "x y and z must all be float";
	    return TCL_ERROR;
	}

	if ( matx->dim != 1 || matx->n[0] != nx ||
	     maty->dim != 1 || maty->n[0] != ny ||
	     matz->dim != 2 || matz->n[0] != nx || matz->n[1] != ny ) {
	    interp->result = "Inconsistent dimensions";
	    return TCL_ERROR;
	}

	x = matx->fdata;
	y = maty->fdata;

	z = (PLFLT **) malloc( nx * sizeof(PLFLT *) );
	for( i=0; i < nx; i++ )
	    z[i] = &matz->fdata[ I2D(i,0) ];
    }
    else if (argc == 6) {
	opt  = atoi( argv[4] );
	side = atoi( argv[5] );

	matx = Tcl_GetMatrixPtr( interp, argv[1] );
	maty = Tcl_GetMatrixPtr( interp, argv[2] );
	matz = Tcl_GetMatrixPtr( interp, argv[3] );
	matPtr = matz;		/* For dumb indexer macro, grrrr. */

	if ( matx->type != TYPE_FLOAT ||
	     maty->type != TYPE_FLOAT ||
	     matz->type != TYPE_FLOAT ) {
	    interp->result = "x y and z must all be float";
	    return TCL_ERROR;
	}

	nx = matx->n[0]; ny = maty->n[0];

	if ( matx->dim != 1 || matx->n[0] != nx ||
	     maty->dim != 1 || maty->n[0] != ny ||
	     matz->dim != 2 || matz->n[0] != nx || matz->n[1] != ny ) {
	    interp->result = "Inconsistent dimensions";
	    return TCL_ERROR;
	}

	x = matx->fdata;
	y = maty->fdata;

	z = (PLFLT **) malloc( nx * sizeof(PLFLT *) );
	for( i=0; i < nx; i++ )
	    z[i] = &matz->fdata[ I2D(i,0) ];
    }
    else if (argc == 4) {
	interp->result = "unimplemented";
	return TCL_ERROR;
    }
    else {
	Tcl_AppendResult(interp, "wrong # args: should be \"plot3d ",
			 "x y z nx ny opt side\", or a valid contraction ",
			 "thereof.", (char *) NULL);
	return TCL_ERROR;
    }

    plot3d( x, y, z, nx, ny, opt, side );

    if (argc == 8) {
	free(z);
    }
    else if (argc == 6) {
	free(z);
    }
    else {			/* argc == 4 */
    }

    plflush();
    return TCL_OK;
}

/*--------------------------------------------------------------------------*\
 * plsetoptCmd
 *
 * Processes plsetopt Tcl command.
 * Just calls plSetInternalOpt() 
\*--------------------------------------------------------------------------*/

static int
plsetoptCmd(ClientData clientData, Tcl_Interp *interp,
	     int argc, char **argv)
{
    if (argc < 2 || argc > 3) {
	Tcl_AppendResult(interp, "wrong # args: should be \"",
			 argv[0], " option ?argument?\"", (char *) NULL);
	return TCL_ERROR;
    }

    plSetInternalOpt(argv[1], argv[2]);

    plflush();
    return TCL_OK;
}

/*--------------------------------------------------------------------------*\
 * plshadeCmd
 *
 * Processes plshade Tcl command.
 * C version takes:
 *    data, nx, ny, defined,
 *    xmin, xmax, ymin, ymax,
 *    sh_min, sh_max, sh_cmap, sh_color, sh_width,
 *    min_col, min_wid, max_col, max_wid,
 *    plfill, rect, pltr, pltr_data
 *
 * We will be getting data through a 2-d Matrix, which carries along
 * nx and ny, so no need for those.  Toss defined since it's not supported
 * anyway.  Toss plfill since it is the only valid choice.  Take an optional 
 * pltr spec just as for plcont, and add a wrapping specifier, also just as
 * in plcont.  So the new command looks like:
 * 
 * 	plshade z xmin xmax ymin ymax \
 * 	    sh_min sh_max sh_cmap sh_color sh_width \
 * 	    min_col min_wid max_col max_wid \
 * 	    rect [pltr x y] [wrap]
\*--------------------------------------------------------------------------*/

static int
plshadeCmd( ClientData clientData, Tcl_Interp *interp,
	    int argc, char *argv[] )
{
    tclMatrix *matPtr, *matz, *mattrx, *mattry;
    PLFLT xmin, xmax, ymin, ymax, sh_min, sh_max, sh_col;

    PLINT sh_cmap =1, sh_wid =2;
    PLINT min_col =1, min_wid =0, max_col =0, max_wid =0;
    PLINT rect =1;
    char *pltrname = "pltr0";
    void (*pltr) (PLFLT, PLFLT, PLFLT *, PLFLT *, PLPointer);
    PLPointer pltr_data = NULL;
    PLcGrid  cgrid1;
    PLcGrid2 cgrid2;
    PLINT wrap = 0;
    int nx, ny, i, j;

    if (argc < 16 ) {
	Tcl_AppendResult(interp, "bogus syntax for plshade, see doc.",
			 (char *) NULL );
	return TCL_ERROR;
    }

    matz = Tcl_GetMatrixPtr( interp, argv[1] );
    xmin = atof( argv[2] );
    xmax = atof( argv[3] );
    ymin = atof( argv[4] );
    ymax = atof( argv[5] );
    sh_min = atof( argv[6] );
    sh_max = atof( argv[7] );
    sh_cmap = atoi( argv[8] );
    sh_col = atof( argv[9] );
    sh_wid = atoi( argv[10] );
    min_col = atoi( argv[11] );
    min_wid = atoi( argv[12] );
    max_col = atoi( argv[13] );
    max_wid = atoi( argv[14] );
    rect = atoi( argv[15] );

    argc -= 16, argv += 16;

    if (argc >= 3) {
	pltrname = argv[0];
	mattrx = Tcl_GetMatrixPtr( interp, argv[1] );
	mattry = Tcl_GetMatrixPtr( interp, argv[2] );

	argc -= 3, argv += 3;
    }

    if (argc) {
	wrap = atoi( argv[0] );
	argc--, argv++;
    }

    if (argc) {
	interp->result = "plshade: bogus arg list";
	return TCL_ERROR;
    }

    if (matz->dim != 2) {
	interp->result = "Must plot a 2-d matrix.";
	return TCL_ERROR;
    }

    nx = matz->n[0];
    ny = matz->n[1];

    tclmateval_modx = nx;
    tclmateval_mody = ny;

/* Figure out which coordinate transformation model is being used, and setup
   accordingly. */

    if ( !strcmp( pltrname, "pltr0" ) ) {
	pltr = pltr0;

    /* wrapping is only supported for pltr2. */
	if (wrap) {
	    interp->result = "Must use pltr2 if want wrapping.";
	    return TCL_ERROR;
	}
    }
    else if ( !strcmp( pltrname, "pltr1" ) ) {
	pltr = pltr1;
	cgrid1.xg = mattrx->fdata;
	cgrid1.nx = nx;
	cgrid1.yg = mattry->fdata;
	cgrid1.ny = ny;

    /* wrapping is only supported for pltr2. */
	if (wrap) {
	    interp->result = "Must use pltr2 if want wrapping.";
	    return TCL_ERROR;
	}

	if (mattrx->dim != 1 || mattry->dim != 1) {
	    interp->result = "Must use 1-d coord arrays with pltr1.";
	    return TCL_ERROR;
	}

	pltr_data = &cgrid1;
    }
    else if ( !strcmp( pltrname, "pltr2" ) ) {
    /* printf( "plshade, setting up for pltr2\n" ); */
	if (!wrap) {
	/* printf( "plshade, no wrapping is needed.\n" ); */
	    plAlloc2dGrid( &cgrid2.xg, nx, ny );
	    plAlloc2dGrid( &cgrid2.yg, nx, ny );
	    cgrid2.nx = nx;
	    cgrid2.ny = ny;

	    matPtr = mattrx;
	    for( i=0; i < nx; i++ )
		for( j=0; j < ny; j++ )
		    cgrid2.xg[i][j] = mattrx->fdata[ I2D(i,j) ];

	    matPtr = mattry;
	    for( i=0; i < nx; i++ )
		for( j=0; j < ny; j++ )
		    cgrid2.yg[i][j] = mattry->fdata[ I2D(i,j) ];
	}
	else if (wrap == 1) {
	    plAlloc2dGrid( &cgrid2.xg, nx+1, ny );
	    plAlloc2dGrid( &cgrid2.yg, nx+1, ny );
	    cgrid2.nx = nx+1;
	    cgrid2.ny = ny;

	    matPtr = mattrx;
	    for( i=0; i < nx; i++ )
		for( j=0; j < ny; j++ )
		    cgrid2.xg[i][j] = mattrx->fdata[ I2D(i,j) ];

	    matPtr = mattry;
	    for( i=0; i < nx; i++ )
		for( j=0; j < ny; j++ )
		    cgrid2.yg[i][j] = mattry->fdata[ I2D(i,j) ];

	    for( j=0; j < ny; j++ ) {
		cgrid2.xg[nx][j] = cgrid2.xg[0][j];
		cgrid2.yg[nx][j] = cgrid2.yg[0][j];
	    }

	    nx++;
	}
	else if (wrap == 2) {
	    plAlloc2dGrid( &cgrid2.xg, nx, ny+1 );
	    plAlloc2dGrid( &cgrid2.yg, nx, ny+1 );
	    cgrid2.nx = nx;
	    cgrid2.ny = ny+1;

	    matPtr = mattrx;
	    for( i=0; i < nx; i++ )
		for( j=0; j < ny; j++ )
		    cgrid2.xg[i][j] = mattrx->fdata[ I2D(i,j) ];

	    matPtr = mattry;
	    for( i=0; i < nx; i++ )
		for( j=0; j < ny; j++ )
		    cgrid2.yg[i][j] = mattry->fdata[ I2D(i,j) ];

	    for( i=0; i < nx; i++ ) {
		cgrid2.xg[i][ny] = cgrid2.xg[i][0];
		cgrid2.yg[i][ny] = cgrid2.yg[i][0];
	    }

	    ny++;
	}
	else {
	    interp->result =
		"Invalid wrap specifier, must be <empty>, 1 or 2.";
	    return TCL_ERROR;
	}

	pltr = pltr2;
	pltr_data = &cgrid2;
    }
    else {
	Tcl_AppendResult( interp,
			  "Unrecognized coordinate transformation spec:",
			  pltrname, ", must be pltr0 pltr1 or pltr2.",
			  (char *) NULL );
	return TCL_ERROR;
    }

/* Now go make the plot. */

    plfshade( tclMatrix_feval, matz, NULL, NULL, nx, ny,
	      xmin, xmax, ymin, ymax,
	      sh_min, sh_max, sh_cmap, sh_col, sh_wid,
	      min_col, min_wid, max_col, max_wid,
	      plfill, rect, pltr, pltr_data );

/* Now free up any space which got allocated for our coordinate trickery. */

    if (pltr == pltr1) {
    /* Hmm, actually, nothing to do here currently, since we just used the
       Tcl Matrix data directly, rather than allocating private space. */
    }
    else if (pltr == pltr2) {
    /* printf( "plshade, freeing space for grids used in pltr2\n" ); */
	plFree2dGrid( cgrid2.xg, nx, ny );
	plFree2dGrid( cgrid2.yg, nx, ny );
    }

    plflush();
    return TCL_OK;
}
