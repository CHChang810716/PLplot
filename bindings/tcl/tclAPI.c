/* $Id$
 * $Log$
 * Revision 1.17  1995/07/04 18:53:48  furnish
 * Reimplemented the Tcl contouring support.  This time I made a serious
 * attempt to support coordinate mappings from Tcl.  Built in support is
 * provided for pltr0, pltr1, and pltr2.  NO support is available for
 * user defined coordinate transformation functions.  They'll just have
 * to set up coordinate arrays and use pltr2, I guess.  To ameliorate
 * this, I did however add support for one very common thing people need
 * to do, which is to support plotting of data defined on a grid which is
 * wrapped in one coordinate or the other.  Much testing still to do..
 *
 * Revision 1.16  1995/07/01  20:25:57  furnish
 * Implemented plot3d and plmesh.
 *
 * Revision 1.15  1995/06/29  20:23:13  furnish
 * Hack out even more of the old hand coded interface functions,
 * replacing with an even larger set of autogenerated Tcl command
 * procedures.  Also some fixes to error reporting to make it easier to
 * understand what went wrong.
 *
 * Revision 1.14  1995/06/28  14:51:28  furnish
 * Hack out most of the Tcl command procedures (using cpp #if 0
 * ... #endif), and include the new autogenerated versions.  This code
 * needs to be exercised, and once it is believed to be functioning
 * reliably, this file can be cut waaaay down to size.
 *
 * Revision 1.13  1995/06/22  18:51:53  furnish
 * Tcl support for plvpas, grrrrrr.
 *
 * Revision 1.12  1995/06/09  22:46:37  mjl
 * Eliminated vestigial lookup of TclMatrix variable in favor of new syntax.
 *
 * Revision 1.11  1995/05/07  03:14:26  mjl
 * Added new Tcl API functions plscol0 and plscolbg for color setting.
 *
 * Revision 1.10  1995/03/17  07:54:33  mjl
 * Fixed Copyright message and other cleaning up.
 *
 * Revision 1.9  1995/01/27  03:56:24  mjl
 * Added "loopback" command: gobbles the following word, which must be "cmd",
 * and processes the remaining arguments as any other plplot/Tcl command.
 * This allows scripts involving widget commands -- of the form <widget> cmd
 * <plplot command> -- to be processed by pltcl, with <widget> replaced
 * by "loopback".
 *
 * Revision 1.8  1994/10/10  19:45:07  furnish
 * Imlemented plshade from Tcl.
 *
 * Revision 1.7  1994/10/10  17:25:30  furnish
 * Add knowledge of contouring.
 *
 * Revision 1.6  1994/09/23  07:53:14  mjl
 * New Tcl API functions added: plend, plend1, plsstrm, and plinit.
 */

/*
    tclAPI.c

    Copyright 1994, 1995
    Maurice LeBrun			mjl@dino.ph.utexas.edu
    Institute for Fusion Studies	University of Texas at Austin

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.

    You should have received a copy of the GNU Library General Public
    License along with this library; if not, write to the Free
    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	
    This module implements a Tcl command set for interpretively calling
    PLplot functions.  Each Tcl command is responsible for calling the
    appropriate underlying function in the C API.  Can be used with any
    driver, in principle.
*/

#include "plplotP.h"
#include "pltcl.h"

#include "tclgen.h"

/* PLplot/Tcl API handlers.  Prototypes must come before Cmds struct */

static int loopbackCmd	(ClientData, Tcl_Interp *, int, char **);
/*
static int pladvCmd	(ClientData, Tcl_Interp *, int, char **);
static int plbopCmd	(ClientData, Tcl_Interp *, int, char **);
static int plboxCmd	(ClientData, Tcl_Interp *, int, char **);
static int plcol0Cmd	(ClientData, Tcl_Interp *, int, char **);
*/
static int plcontCmd	(ClientData, Tcl_Interp *, int, char **);
/*
static int plendCmd	(ClientData, Tcl_Interp *, int, char **);
static int plend1Cmd	(ClientData, Tcl_Interp *, int, char **);
static int plenvCmd	(ClientData, Tcl_Interp *, int, char **);
static int pleopCmd	(ClientData, Tcl_Interp *, int, char **);
static int plfontCmd	(ClientData, Tcl_Interp *, int, char **);
static int plfontldCmd	(ClientData, Tcl_Interp *, int, char **);
static int plgraCmd	(ClientData, Tcl_Interp *, int, char **);
static int plhistCmd	(ClientData, Tcl_Interp *, int, char **);
*/
static int plinitCmd	(ClientData, Tcl_Interp *, int, char **);
/*
static int pljoinCmd	(ClientData, Tcl_Interp *, int, char **);
static int pllabCmd	(ClientData, Tcl_Interp *, int, char **);
static int pllineCmd	(ClientData, Tcl_Interp *, int, char **);
static int plmtexCmd	(ClientData, Tcl_Interp *, int, char **);
static int plpoinCmd	(ClientData, Tcl_Interp *, int, char **);
static int plptexCmd	(ClientData, Tcl_Interp *, int, char **);
static int plschrCmd	(ClientData, Tcl_Interp *, int, char **);
static int plscol0Cmd	(ClientData, Tcl_Interp *, int, char **);
static int plscolbgCmd	(ClientData, Tcl_Interp *, int, char **);
*/
static int plmeshCmd	(ClientData, Tcl_Interp *, int, char **);
static int plot3dCmd	(ClientData, Tcl_Interp *, int, char **);
static int plsetoptCmd	(ClientData, Tcl_Interp *, int, char **);
static int plshadeCmd	(ClientData, Tcl_Interp *, int, char **);
/*
static int plsstrmCmd	(ClientData, Tcl_Interp *, int, char **);
static int plssubCmd	(ClientData, Tcl_Interp *, int, char **);
static int plstylCmd	(ClientData, Tcl_Interp *, int, char **);
static int plsxaxCmd	(ClientData, Tcl_Interp *, int, char **);
static int plsyaxCmd	(ClientData, Tcl_Interp *, int, char **);
static int plsymCmd	(ClientData, Tcl_Interp *, int, char **);
static int pltextCmd	(ClientData, Tcl_Interp *, int, char **);
static int plvpasCmd	(ClientData, Tcl_Interp *, int, char **);
static int plvporCmd	(ClientData, Tcl_Interp *, int, char **);
static int plvstaCmd	(ClientData, Tcl_Interp *, int, char **);
static int plwidCmd	(ClientData, Tcl_Interp *, int, char **);
static int plwindCmd	(ClientData, Tcl_Interp *, int, char **);
*/

/*
 * The following structure defines all of the commands in the PLplot/Tcl
 * core, and the C procedures that execute them.
 */

typedef struct Command {
    int (*proc)();		/* Procedure to process command. */
    ClientData clientData;	/* Arbitrary value to pass to proc. */
    int *deleteProc;		/* Procedure to invoke when deleting
				 * command. */
    ClientData deleteData;	/* Arbitrary value to pass to deleteProc
				 * (usually the same as clientData). */
} Command;

typedef struct {
    char *name;
    int (*proc)();
} CmdInfo;

/* Built-in commands, and the procedures associated with them */

static CmdInfo Cmds[] = {
    {"loopback",	loopbackCmd},
#include "tclgen_s.h"
    {"plcol",		plcol0Cmd},
/*
    {"pladv",		pladvCmd},
    {"plbop",		plbopCmd},
    {"plbox",		plboxCmd},
    {"plcol",		plcol0Cmd},
    {"plcol0",		plcol0Cmd},
    */
    {"plcont",		plcontCmd},
/*
    {"plend",		plendCmd},
    {"plend1",		plend1Cmd},
    {"plenv",		plenvCmd},
    {"pleop",		pleopCmd},
    {"plfont",		plfontCmd},
    {"plfontld",	plfontldCmd},
    {"plgra",		plgraCmd},
    {"plhist",		plhistCmd},
    */
    {"plinit",		plinitCmd},
/*
    {"pljoin",		pljoinCmd},
    {"pllab",		pllabCmd},
    {"plline",		pllineCmd},
    {"plmtex",		plmtexCmd},
    {"plpoin",		plpoinCmd},
    {"plptex",		plptexCmd},
    {"plschr",		plschrCmd},
    {"plscol0",		plscol0Cmd},
    {"plscolbg",	plscolbgCmd},
    */
    {"plmesh",		plmeshCmd},
    {"plot3d",		plot3dCmd},
    {"plsetopt",	plsetoptCmd},
    {"plshade",		plshadeCmd},
/*
    {"plsstrm",		plsstrmCmd},
    {"plssub",		plssubCmd},
    {"plstyl",		plstylCmd},
    {"plsxax",		plsxaxCmd},
    {"plsyax",		plsyaxCmd},
    {"plsym",		plsymCmd},
    {"pltext",		pltextCmd},
    {"plvpas",		plvpasCmd},
    {"plvpor",		plvporCmd},
    {"plvsta",		plvstaCmd},
    {"plwid",		plwidCmd},
    {"plwind",		plwindCmd},
    */
    {NULL,		NULL}
};

/* Hash table and associated flag for directing control */

static int cmdTable_initted;
static Tcl_HashTable cmdTable;

/*--------------------------------------------------------------------------*\
 * Append_Cmdlist
 *
 * Generates command list from Cmds, storing into interp->result.
\*--------------------------------------------------------------------------*/

static void
Append_Cmdlist(Tcl_Interp *interp)
{
    static int inited = 0;
    static char** namelist;
    register CmdInfo *cmdInfoPtr;
    int i, j, ncmds = sizeof(Cmds)/sizeof(CmdInfo);

    if (!inited) {
	namelist = (char **) malloc( ncmds * sizeof(char *) );

	for( i=0; i < ncmds; i++ )
	    namelist[i] = Cmds[i].name;

    /* Sort the list, couldn't get qsort to do it for me for some reason, grrr. */

	for( i=0; i < ncmds-1; i++ )
	    for( j=i+1; j < ncmds; j++ ) {
		if (strcmp(namelist[i], namelist[j]) > 0) {
		    char *t = namelist[i];
		    namelist[i] = namelist[j];
		    namelist[j] = t;
		}
	    }

	inited = 1;
    }

    for( i=0; i < ncmds; i++ )
	Tcl_AppendResult(interp, " ", namelist[i], (char *) NULL);
}

/*--------------------------------------------------------------------------*\
 * plTclCmd_Init
 *
 * Sets up command hash table for use with plframe to PLplot Tcl API.
 *
 * Right now all API calls are allowed, although some of these may not
 * make much sense when used with a widget.
\*--------------------------------------------------------------------------*/

static void
plTclCmd_Init(Tcl_Interp *interp)
{
    register Command *cmdPtr;
    register CmdInfo *cmdInfoPtr;

    Tcl_InitHashTable(&cmdTable, TCL_STRING_KEYS);

/* Create the hash table entry for each command */

    for (cmdInfoPtr = Cmds; cmdInfoPtr->name != NULL; cmdInfoPtr++) {
	int new;
	Tcl_HashEntry *hPtr;

	hPtr = Tcl_CreateHashEntry(&cmdTable, cmdInfoPtr->name, &new);
	if (new) {
	    cmdPtr = (Command *) ckalloc(sizeof(Command));
	    cmdPtr->proc = cmdInfoPtr->proc;
	    cmdPtr->clientData = (ClientData) NULL;
	    cmdPtr->deleteProc = NULL;
	    cmdPtr->deleteData = (ClientData) NULL;
	    Tcl_SetHashValue(hPtr, cmdPtr);
	}
    }
}

/*--------------------------------------------------------------------------*\
 * plTclCmd
 *
 * Front-end to PLplot/Tcl API for use from Tcl commands (e.g. plframe).
 *
 * This command is called by the plframe widget to process subcommands
 * of the "cmd" plframe widget command.  This is the plframe's direct
 * plotting interface to the PLplot library.  This routine can be called
 * from other commands that want a similar capability.
 *
 * In a widget-based application, a PLplot "command" doesn't make much
 * sense by itself since it isn't connected to a specific widget.
 * Instead, you have widget commands.  This allows arbitrarily many
 * widgets and requires a slightly different syntax than if there were
 * only a single output device.  That is, the widget name (and in this
 * case, the "cmd" widget command, after that comes the subcommand)
 * must come first.  The plframe widget checks first for one of its
 * internal subcommands, those specifically designed for use with the
 * plframe widget.  If not found, control comes here. 
\*--------------------------------------------------------------------------*/

int
plTclCmd(char *cmdlist, Tcl_Interp *interp, int argc, char **argv)
{
    register Tcl_HashEntry *hPtr;
    int result = TCL_OK;

/* Create hash table on first call */

    if ( ! cmdTable_initted) {
	cmdTable_initted = 1;
	plTclCmd_Init(interp);
    }

/* no option -- return list of available PLplot commands */

    if (argc == 0) {
	Tcl_AppendResult(interp, cmdlist, (char *) NULL);
	Append_Cmdlist(interp);
	return TCL_OK;
    }

/* Pick out the desired command */

    hPtr = Tcl_FindHashEntry(&cmdTable, argv[0]);
    if (hPtr == NULL) {
	Tcl_AppendResult(interp, "bad option \"", argv[0],
			 "\" to \"cmd\": must be one of ",
			 cmdlist, (char *) NULL);
	Append_Cmdlist(interp);
	result = TCL_ERROR;
    }
    else {
	register Command *cmdPtr = (Command *) Tcl_GetHashValue(hPtr);
	result = (*cmdPtr->proc)(cmdPtr->clientData, interp, argc, argv);
    }

    return result;
}

/*--------------------------------------------------------------------------*\
 * loopbackCmd
 *
 * Loop-back command for Tcl interpreter.  Main purpose is to enable a
 * compatible command syntax whether you are executing directly through a
 * Tcl interpreter or a plframe widget.  I.e. the syntax is:
 *
 *	<widget> cmd <PLplot command>		(widget command)
 *	loopback cmd <PLplot command>		(pltcl command)
 *
 * This routine is essentially the same as plTclCmd but without some of
 * the window dressing required by the plframe widget.
\*--------------------------------------------------------------------------*/

static int
loopbackCmd(ClientData clientData, Tcl_Interp *interp,
	    int argc, char **argv)
{
    register Tcl_HashEntry *hPtr;
    int result = TCL_OK;

    argc--; argv++;
    if (argc == 0 || (strcmp(argv[0], "cmd") != 0)) {
	Tcl_AppendResult(interp, "bad option to \"loopback\": must be ",
			 "\"cmd ?options?\" ", (char *) NULL);
	return TCL_ERROR;
    }

/* Create hash table on first call */

    if ( ! cmdTable_initted) {
	cmdTable_initted = 1;
	plTclCmd_Init(interp);
    }

/* no option -- return list of available PLplot commands */

    argc--; argv++;
    if (argc == 0) {
	Append_Cmdlist(interp);
	return TCL_OK;
    }

/* Pick out the desired command */

    hPtr = Tcl_FindHashEntry(&cmdTable, argv[0]);
    if (hPtr == NULL) {
	Tcl_AppendResult(interp,
			 "bad option to \"loopback cmd\": must be one of ",
			 (char *) NULL);
	Append_Cmdlist(interp);
	result = TCL_ERROR;
    }
    else {
	register Command *cmdPtr = (Command *) Tcl_GetHashValue(hPtr);
	result = (*cmdPtr->proc)(cmdPtr->clientData, interp, argc, argv);
    }

    return result;
}

/*--------------------------------------------------------------------------*\
 * Pltcl_Init
 *
 * Initialization routine for extended wish'es.
 * Creates the matrix command, as well as numerous commands for
 * interfacing to PLplot.  Should not be used in a widget-based system.
\*--------------------------------------------------------------------------*/

int
Pltcl_Init( Tcl_Interp *interp )
{
    register CmdInfo *cmdInfoPtr;

/* matrix -- matrix support command */

    Tcl_CreateCommand(interp, "matrix", Tcl_MatrixCmd,
                      (ClientData) NULL, (void (*)(ClientData)) NULL);

/* PLplot API commands */

    for (cmdInfoPtr = Cmds; cmdInfoPtr->name != NULL; cmdInfoPtr++) {

	Tcl_CreateCommand(interp, cmdInfoPtr->name, cmdInfoPtr->proc,
			  (ClientData) NULL, (void (*)(ClientData)) NULL);
    }

    return TCL_OK;
}

/*--------------------------------------------------------------------------*\
 * PLplot API Calls
 *
 * Any call that results in something actually being plotted must be
 * followed by by a call to plflush(), to make sure all output from 
 * that command is finished.  Devices that have text/graphics screens
 * (e.g. Tek4xxx and emulators) implicitly switch to the graphics screen
 * before graphics commands, so a plgra() is not necessary in this case.
 * Although if you switch to the text screen via user control (instead of
 * using pltext()), the device will get confused.
\*--------------------------------------------------------------------------*/

/* TEMPLATE */
#if 0
/*--------------------------------------------------------------------------*\
 * plxxxCmd
 *
 * Processes plxxx Tcl command.
\*--------------------------------------------------------------------------*/

static int
plxxxCmd(ClientData clientData, Tcl_Interp *interp,
	 int argc, char **argv)
{
    if (argc != 0 ) {
	Tcl_AppendResult(interp, "wrong # args: should be \"",
			 argv[0], " \"",
			 (char *) NULL);
	return TCL_ERROR;
    }


    plflush();
    return TCL_OK;
}

#endif

/*
  Now go pick up all the autogenerated Tcl command procs.
  */

#include "tclgen.c"

#if 0
/*--------------------------------------------------------------------------*\
 * pladvCmd
 *
 * Processes pladv Tcl command.
\*--------------------------------------------------------------------------*/

static int
pladvCmd(ClientData clientData, Tcl_Interp *interp,
	 int argc, char **argv)
{
    int sub = 0;

    if (argc > 2 ) {
	Tcl_AppendResult(interp, "wrong # args: should be \"",
			 argv[0], " ?subwindow?\"",
			 (char *) NULL);
	return TCL_ERROR;
    }

    if (argc == 2) 
	sub = atoi(argv[1]);

    pladv(sub);

    plflush();
    return TCL_OK;
}

/*--------------------------------------------------------------------------*\
 * plbopCmd
 *
 * Processes plbop Tcl command.
\*--------------------------------------------------------------------------*/

static int
plbopCmd(ClientData clientData, Tcl_Interp *interp,
	 int argc, char **argv)
{
    if (argc > 1 ) {
	Tcl_AppendResult(interp, "wrong # args: should be \"",
			 argv[0], " \"",
			 (char *) NULL);
	return TCL_ERROR;
    }

    plbop();

    plflush();
    return TCL_OK;
}

/*--------------------------------------------------------------------------*\
 * plboxCmd
 *
 * Processes plbox Tcl command.
\*--------------------------------------------------------------------------*/

static int
plboxCmd(ClientData clientData, Tcl_Interp *interp,
	 int argc, char **argv)
{
    char *xopt, *yopt;
    PLFLT xtick, ytick;
    PLINT nxsub, nysub;

    if (argc != 7 ) {
	Tcl_AppendResult(interp, "wrong # args: should be \"",
			 argv[0], " xopt xtick nxsub yopt ytick nysub\"",
			 (char *) NULL);
	return TCL_ERROR;
    }

    xopt = argv[1];
    xtick = atof(argv[2]);
    nxsub = atoi(argv[3]);

    yopt = argv[4];
    ytick = atof(argv[5]);
    nysub = atoi(argv[6]);

    plbox(xopt, xtick, nxsub, yopt, ytick, nysub);

    plflush();
    return TCL_OK;
}

/*--------------------------------------------------------------------------*\
 * plcol0Cmd
 *
 * Processes plcol0 Tcl command.
\*--------------------------------------------------------------------------*/

static int
plcol0Cmd(ClientData clientData, Tcl_Interp *interp,
	  int argc, char **argv)
{
    PLINT col;

    if (argc != 2) {
	Tcl_AppendResult(interp, "wrong # args: should be \"", argv[0],
			 " color-index\"",
			 (char *) NULL);
	return TCL_ERROR;
    }

    col = atoi( argv[1] );

    plcol0( col );

    return TCL_OK;
}
#endif

/*--------------------------------------------------------------------------*\
 * plcontCmd
 *
 * Processes plcont Tcl command.
 * 
 * The C function is:
 * void
 * c_plcont(PLFLT **f, PLINT nx, PLINT ny, PLINT kx, PLINT lx,
 * 	 PLINT ky, PLINT ly, PLFLT *clevel, PLINT nlevel,
 * 	 void (*pltr) (PLFLT, PLFLT, PLFLT *, PLFLT *, PLPointer),
 * 	 PLPointer pltr_data);
 * 
 * Since f will be specified by a Tcl Matrix, nx and ny are redundant, and
 * are automatically eliminated.  Same for nlevel, since clevel will be a 1-d
 * Tcl Matrix.  Since most people plot the whole data set, we will allow kx,
 * lx and ky, ly to be defaulted--either you specify all four, or none of
 * them.  We allow three ways of specifying the coordinate transforms: 1)
 * Nothing, in which case we will use the identity mapper pltr0 2) pltr1, in
 * which case the next two args must be 1-d Tcl Matricies 3) pltr2, in which
 * case the next two args must be 2-d Tcl Matricies.  Finally, a new
 * paramater is allowed at the end to specify which, if either, of the
 * coordinates wrap on themselves.  Can be 1 or x, or 2 or y.  Nothing or 0
 * specifies that neither coordinate wraps.
 * 
 * So, the new call from Tcl is:
 * 	plcont f [kx lx ky ly] clev [pltr x y] [wrap]
 * 
\*--------------------------------------------------------------------------*/

static int tclmateval_modx, tclmateval_mody;

PLFLT tclMatrix_feval (PLINT i, PLINT j, PLPointer p)
{
    tclMatrix *matPtr = (tclMatrix *) p;

    i = i % tclmateval_modx;
    j = j % tclmateval_mody;

/*    printf( "tclMatrix_feval: i=%d j=%d f=%f\n", i, j,
      matPtr->fdata[I2D(i,j)] );
	    */
    return matPtr->fdata[I2D(i,j)];
}

static int
plcontCmd( ClientData clientData, Tcl_Interp *interp,
	   int argc, char *argv[] )
{
    tclMatrix *matPtr, *matf, *matclev;
    PLINT nx, ny, kx, lx, ky, ly, nclev;
    char *pltrname = "pltr0";
    tclMatrix *mattrx, *mattry;

    int arg3_is_kx = 1, i, j;
    void (*pltr) (PLFLT, PLFLT, PLFLT *, PLFLT *, PLPointer);
    PLPointer pltr_data = NULL;
    PLcGrid  cgrid1;
    PLcGrid2 cgrid2;

    int wrap = 0;

    if (argc  < 3 ) {
	Tcl_AppendResult( interp, "wrong # args: see documentation for ",
			 argv[0], (char *) NULL);
	return TCL_ERROR;
    }

    matf = Tcl_GetMatrixPtr( interp, argv[1] );

    if (matf->dim != 2) {
	interp->result = "Must use 2-d data.";
	return TCL_ERROR;
    } else {
	nx = matf->n[0];
	ny = matf->n[1];

	tclmateval_modx = nx;
	tclmateval_mody = ny;

	kx = 1; lx = nx;
	ky = 1; ly = ny;
    }

/* Now check the next argument.  If it is all digits, then it must be kx,
   otherwise it is the name of clev. */

    for( i=0; i < strlen( argv[2] ) && arg3_is_kx; i++ )
	if (!isdigit(argv[2][i]))
	    arg3_is_kx = 0;

    if (arg3_is_kx) {
    /* Check that there are enough args */
	if (argc < 7) {
	    interp->result = "plcont, bogus syntax";
	    return TCL_ERROR;
	}

    /* Peel off the ones we need */
	kx = atoi( argv[3] );
	lx = atoi( argv[4] );
	ky = atoi( argv[5] );
	ly = atoi( argv[6] );

    /* adjust argc, argv to reflect our consumption */
	argc -= 6, argv += 6;
    } else {
	argc -= 2, argv += 2;
    }

/* The next argument has to be clev */

    if (argc < 1) {
	interp->result = "plcont, bogus syntax";
	return TCL_ERROR;
    }

    matclev = Tcl_GetMatrixPtr( interp, argv[0] );
    nclev = matclev->n[0];

    if (matclev->dim != 1) {
	interp->result = "clev must be 1-d matrix.";
	return TCL_ERROR;
    }

    argc--, argv++;

/* Now handle trailing optional parameters, if any */

    if (argc >= 3) {
    /* There is a pltr spec, parse it. */
	pltrname = argv[0];
	mattrx = Tcl_GetMatrixPtr( interp, argv[1] );
	mattry = Tcl_GetMatrixPtr( interp, argv[2] );

	argc -= 3, argv += 3;
    }

    if (argc) {
    /* There is a wrap spec, get it. */
	wrap = atoi( argv[0] );

    /* Hmm, I said the the doc they could also say x or y, have to come back
       to this... */

	argc--, argv++;
    }

/* There had better not be anything else on the command line by this point. */

    if (argc) {
	interp->result = "plcont, bogus syntax, too many args.";
	return TCL_ERROR;
    }

/* Now we need to set up the data for contouring. */

    if ( !strcmp( pltrname, "pltr0" ) ) {
	pltr = pltr0;

    /* wrapping is only supported for pltr2. */
	if (wrap) {
	    interp->result = "Must use pltr2 if want wrapping.";
	    return TCL_ERROR;
	}
    }
    else if ( !strcmp( pltrname, "pltr1" ) ) {
	pltr = pltr1;
	cgrid1.xg = mattrx->fdata;
	cgrid1.nx = nx;
	cgrid1.yg = mattry->fdata;
	cgrid1.ny = ny;

    /* wrapping is only supported for pltr2. */
	if (wrap) {
	    interp->result = "Must use pltr2 if want wrapping.";
	    return TCL_ERROR;
	}

	if (mattrx->dim != 1 || mattry->dim != 1) {
	    interp->result = "Must use 1-d coord arrays with pltr1.";
	    return TCL_ERROR;
	}

	pltr_data = &cgrid1;
    }
    else if ( !strcmp( pltrname, "pltr2" ) ) {
    /* printf( "plcont, setting up for pltr2\n" ); */
	if (!wrap) {
	/* printf( "plcont, no wrapping is needed.\n" ); */
	    plAlloc2dGrid( &cgrid2.xg, nx, ny );
	    plAlloc2dGrid( &cgrid2.yg, nx, ny );
	    cgrid2.nx = nx;
	    cgrid2.ny = ny;

	    matPtr = mattrx;
	    for( i=0; i < nx; i++ )
		for( j=0; j < ny; j++ )
		    cgrid2.xg[i][j] = mattrx->fdata[ I2D(i,j) ];

	    matPtr = mattry;
	    for( i=0; i < nx; i++ )
		for( j=0; j < ny; j++ )
		    cgrid2.yg[i][j] = mattry->fdata[ I2D(i,j) ];
	}
	else if (wrap == 1) {
	    plAlloc2dGrid( &cgrid2.xg, nx+1, ny );
	    plAlloc2dGrid( &cgrid2.yg, nx+1, ny );
	    cgrid2.nx = nx+1;
	    cgrid2.ny = ny;

	    matPtr = mattrx;
	    for( i=0; i < nx; i++ )
		for( j=0; j < ny; j++ )
		    cgrid2.xg[i][j] = mattrx->fdata[ I2D(i,j) ];

	    matPtr = mattry;
	    for( i=0; i < nx; i++ )
		for( j=0; j < ny; j++ )
		    cgrid2.yg[i][j] = mattry->fdata[ I2D(i,j) ];

	    for( j=0; j < ny; j++ ) {
		cgrid2.xg[nx][j] = cgrid2.xg[0][j];
		cgrid2.yg[nx][j] = cgrid2.yg[0][j];
	    }

	    nx++;
	}
	else if (wrap == 2) {
	    plAlloc2dGrid( &cgrid2.xg, nx, ny+1 );
	    plAlloc2dGrid( &cgrid2.yg, nx, ny+1 );
	    cgrid2.nx = nx;
	    cgrid2.ny = ny+1;

	    matPtr = mattrx;
	    for( i=0; i < nx; i++ )
		for( j=0; j < ny; j++ )
		    cgrid2.xg[i][j] = mattrx->fdata[ I2D(i,j) ];

	    matPtr = mattry;
	    for( i=0; i < nx; i++ )
		for( j=0; j < ny; j++ )
		    cgrid2.yg[i][j] = mattry->fdata[ I2D(i,j) ];

	    for( i=0; i < nx; i++ ) {
		cgrid2.xg[i][ny] = cgrid2.xg[i][0];
		cgrid2.yg[i][ny] = cgrid2.yg[i][0];
	    }

	    ny++;
	}
	else {
	    interp->result =
		"Invalid wrap specifier, must be <empty>, 1 or 2.";
	    return TCL_ERROR;
	}

	pltr = pltr2;
	pltr_data = &cgrid2;
    }
    else {
	Tcl_AppendResult( interp,
			  "Unrecognized coordinate transformation spec:",
			  pltrname, ", must be pltr0 pltr1 or pltr2.",
			  (char *) NULL );
	return TCL_ERROR;
    }
/*
    printf( "plcont: nx=%d ny=%d kx=%d lx=%d ky=%d ly=%d\n",
	    nx, ny, kx, lx, ky, ly );
    printf( "plcont: tclmateval_modx=%d tclmateval_mody=%d\n",
	    tclmateval_modx, tclmateval_mody );
    printf( "plcont: nclev=%d\n", nclev );
    */

/* contour the data.*/

    plcontf( tclMatrix_feval, matf, nx, ny,
	     kx, lx, ky, ly,
	     matclev->fdata, nclev,
	     pltr, pltr_data );

/* Now free up any space which got allocated for our coordinate trickery. */

    if (pltr == pltr1) {
    /* Hmm, actually, nothing to do here currently, since we just used the
       Tcl Matrix data directly, rather than allocating private space. */
    }
    else if (pltr == pltr2) {
    /* printf( "plcont, freeing space for grids used in pltr2\n" ); */
	plFree2dGrid( cgrid2.xg, nx, ny );
	plFree2dGrid( cgrid2.yg, nx, ny );
    }

    plflush();
    return TCL_OK;
}

#if 0
/*--------------------------------------------------------------------------*\
 * plendCmd
 *
 * Processes plend Tcl command.
\*--------------------------------------------------------------------------*/

static int
plendCmd(ClientData clientData, Tcl_Interp *interp,
	 int argc, char **argv)
{
    if (argc != 1 ) {
	Tcl_AppendResult(interp, "wrong # args: should be \"", argv[0],
			 "\"", (char *) NULL);
	return TCL_ERROR;
    }

    plend();

    return TCL_OK;
}

/*--------------------------------------------------------------------------*\
 * plend1Cmd
 *
 * Processes plend1 Tcl command.
\*--------------------------------------------------------------------------*/

static int
plend1Cmd(ClientData clientData, Tcl_Interp *interp,
	  int argc, char **argv)
{
    if (argc != 1 ) {
	Tcl_AppendResult(interp, "wrong # args: should be \"", argv[0],
			 "\"", (char *) NULL);
	return TCL_ERROR;
    }

    plend1();

    return TCL_OK;
}

/*--------------------------------------------------------------------------*\
 * plenvCmd
 *
 * Processes plenv Tcl command.
\*--------------------------------------------------------------------------*/

static int
plenvCmd(ClientData clientData, Tcl_Interp *interp,
	 int argc, char **argv)
{
    PLFLT xmin, xmax, ymin, ymax;
    PLINT just, axis;

    if (argc != 7 ) {
	Tcl_AppendResult(interp, "wrong # args: should be \"", argv[0],
			 " xmin xmax ymin ymax just axis\"",
			 (char *) NULL);
	return TCL_ERROR;
    }

    xmin = atof( argv[1] );
    xmax = atof( argv[2] );
    ymin = atof( argv[3] );
    ymax = atof( argv[4] );
    just = atoi( argv[5] );
    axis = atoi( argv[6] );

    plenv( xmin, xmax, ymin, ymax, just, axis );

    plflush();
    return TCL_OK;
}

/*--------------------------------------------------------------------------*\
 * pleopCmd
 *
 * Processes pleop Tcl command.
\*--------------------------------------------------------------------------*/

static int
pleopCmd(ClientData clientData, Tcl_Interp *interp,
	 int argc, char **argv)
{
    if (argc > 1 ) {
	Tcl_AppendResult(interp, "wrong # args: should be \"",
			 argv[0], "\"",
			 (char *) NULL);
	return TCL_ERROR;
    }

    pleop();

    plflush();
    return TCL_OK;
}

/*--------------------------------------------------------------------------*\
 * plfontCmd
 *
 * Processes plfont Tcl command.
\*--------------------------------------------------------------------------*/

static int
plfontCmd(ClientData clientData, Tcl_Interp *interp,
	  int argc, char **argv)
{
    PLINT font;

    if (argc != 2 ) {
	Tcl_AppendResult(interp, "wrong # args: should be \"",
			 argv[0], " font\"",
			 (char *) NULL);
	return TCL_ERROR;
    }

    font = atoi(argv[1]);

    plfont(font);

    return TCL_OK;
}

/*--------------------------------------------------------------------------*\
 * plfontldCmd
 *
 * Processes plfontld Tcl command.
\*--------------------------------------------------------------------------*/

static int
plfontldCmd(ClientData clientData, Tcl_Interp *interp,
	    int argc, char **argv)
{
    PLINT font;

    if (argc != 2 ) {
	Tcl_AppendResult(interp, "wrong # args: should be \"",
			 argv[0], " font\"",
			 (char *) NULL);
	return TCL_ERROR;
    }

    font = atoi(argv[1]);

    plfontld(font);

    return TCL_OK;
}

/*--------------------------------------------------------------------------*\
 * plgraCmd
 *
 * Processes plgra Tcl command.
\*--------------------------------------------------------------------------*/

static int
plgraCmd(ClientData clientData, Tcl_Interp *interp,
	 int argc, char **argv)
{
    if (argc > 1 ) {
	Tcl_AppendResult(interp, "wrong # args: should be \"",
			 argv[0], " \"",
			 (char *) NULL);
	return TCL_ERROR;
    }

    plgra();

    return TCL_OK;
}

/*--------------------------------------------------------------------------*\
 * plhistCmd
 *
 * Processes plhist Tcl command.
\*--------------------------------------------------------------------------*/

static int
plhistCmd(ClientData clientData, Tcl_Interp *interp,
	  int argc, char **argv)
{
    PLINT n, nbin, oldwin;
    PLFLT *data, datmin, datmax;
    tclMatrix *mat;

    if (argc != 7 ) {
	Tcl_AppendResult(interp, "wrong # args: should be \"",
			 argv[0], " n data datmin datmax nbin oldwin\"",
			 (char *) NULL);
	return TCL_ERROR;
    }

    n = atoi(argv[1]);
    mat = Tcl_GetMatrixPtr(interp, argv[2]);
    data = mat->fdata;
    datmin = atof( argv[3] );
    datmax = atof( argv[4] );
    nbin = atoi( argv[5] );
    oldwin = atoi( argv[6] );

    plhist(n, data, datmin, datmax, nbin, oldwin);

    plflush();
    return TCL_OK;
}
#endif

/*--------------------------------------------------------------------------*\
 * plinitCmd
 *
 * Processes plinit Tcl command.
\*--------------------------------------------------------------------------*/

static int
plinitCmd(ClientData clientData, Tcl_Interp *interp,
	  int argc, char **argv)
{
    if (argc != 1 ) {
	Tcl_AppendResult(interp, "wrong # args: should be \"",
			 argv[0], "\"", (char *) NULL);
	return TCL_ERROR;
    }

    plinit();

    return TCL_OK;
}

#if 0
/*--------------------------------------------------------------------------*\
 * pljoinCmd
 *
 * Processes pljoin Tcl command.
\*--------------------------------------------------------------------------*/

static int
pljoinCmd(ClientData clientData, Tcl_Interp *interp,
	  int argc, char **argv)
{
    PLFLT x1, y1, x2, y2;

    if (argc != 5 ) {
	Tcl_AppendResult(interp, "wrong # args: should be \"",
			 argv[0], " x1 y1 x2 y2\"",
			 (char *) NULL);
	return TCL_ERROR;
    }

    x1 = atof( argv[1] );
    y1 = atof( argv[2] );
    x2 = atof( argv[3] );
    y2 = atof( argv[4] );

    pljoin(x1, y1, x2, y2);

    plflush();
    return TCL_OK;
}

/*--------------------------------------------------------------------------*\
 * pllabCmd
 *
 * Processes pllab Tcl command.
\*--------------------------------------------------------------------------*/

static int
pllabCmd(ClientData clientData, Tcl_Interp *interp,
	  int argc, char **argv)
{
    if (argc != 4 ) {
	Tcl_AppendResult(interp, "wrong # args: should be \"",
			 argv[0], " xlabel ylabel tlabel\"",
			 (char *) NULL);
	return TCL_ERROR;
    }

    pllab( argv[1], argv[2], argv[3] );

    plflush();
    return TCL_OK;
}

/*--------------------------------------------------------------------------*\
 * pllineCmd
 *
 * Processes plline Tcl command.
\*--------------------------------------------------------------------------*/

static int
pllineCmd(ClientData clientData, Tcl_Interp *interp,
	   int argc, char **argv)
{
    PLFLT *x, *y;
    tclMatrix *matx, *maty;
    int n;

    if (argc != 4 ) {
	Tcl_AppendResult(interp, "wrong # args: should be \"", argv[0],
			 " n x-array y-array\"",
			 (char *) NULL);
	return TCL_ERROR;
    }

    matx = Tcl_GetMatrixPtr(interp, argv[2]);
    x = matx->fdata;
    maty = Tcl_GetMatrixPtr(interp, argv[3]);
    y = maty->fdata;

    if (strncmp(argv[1], "*", 1) == 0)
	n = MIN(matx->len, maty->len);
    else
	n = atoi(argv[1]);

    plline( n, x, y );

    plflush();
    return TCL_OK;
}

/*--------------------------------------------------------------------------*\
 * plmtexCmd
 *
 * Processes plmtex Tcl command.
\*--------------------------------------------------------------------------*/

static int
plmtexCmd(ClientData clientData, Tcl_Interp *interp,
	  int argc, char **argv)
{
    char *side, *text;
    PLFLT disp, pos, just;

    if (argc != 6 ) {
	Tcl_AppendResult(interp, "wrong # args: should be \"",
			 argv[0], " side disp pos just text\"",
			 (char *) NULL);
	return TCL_ERROR;
    }

    side = argv[1];
    disp = atof(argv[2]);
    pos = atof(argv[3]);
    just = atof(argv[4]);
    text = argv[5];

    plmtex(side, disp, pos, just, text);

    plflush();
    return TCL_OK;
}

/*--------------------------------------------------------------------------*\
 * plpoinCmd
 *
 * Processes plpoin Tcl command.
\*--------------------------------------------------------------------------*/

static int
plpoinCmd(ClientData clientData, Tcl_Interp *interp,
	   int argc, char **argv)
{
    PLFLT *x, *y;
    tclMatrix *matx, *maty;
    int n, code;

    if (argc != 5 ) {
	Tcl_AppendResult(interp, "wrong # args: should be \"", argv[0],
			 " n x-array y-array code\"",
			 (char *) NULL);
	return TCL_ERROR;
    }

    matx = Tcl_GetMatrixPtr(interp, argv[2]);
    x = matx->fdata;
    maty = Tcl_GetMatrixPtr(interp, argv[3]);
    y = maty->fdata;
    code = atoi( argv[4] );

    if (strncmp(argv[1], "*", 1) == 0)
	n = MIN(matx->len, maty->len);
    else
	n = atoi(argv[1]);

    plpoin( n, x, y, code );

    plflush();
    return TCL_OK;
}

/*--------------------------------------------------------------------------*\
 * plptexCmd
 *
 * Processes plptex Tcl command.
\*--------------------------------------------------------------------------*/

static int
plptexCmd(ClientData clientData, Tcl_Interp *interp,
	  int argc, char **argv)
{
    PLFLT x, y, dx, dy, just;
    char *text;

    if (argc != 7 ) {
	Tcl_AppendResult(interp, "wrong # args: should be \"",
			 argv[0], " x y dx dy just text\"",
			 (char *) NULL);
	return TCL_ERROR;
    }

    x = atof(argv[1]);
    y = atof(argv[2]);
    dx = atof(argv[3]);
    dy = atof(argv[4]);
    just = atof(argv[5]);
    text = argv[6];

    plptex(x, y, dx, dy, just, text);

    plflush();
    return TCL_OK;
}

/*--------------------------------------------------------------------------*\
 * plschrCmd
 *
 * Processes plschr Tcl command.
\*--------------------------------------------------------------------------*/

static int
plschrCmd(ClientData clientData, Tcl_Interp *interp,
	  int argc, char **argv)
{
    PLFLT def, scale;

    if (argc != 3 ) {
	Tcl_AppendResult(interp, "wrong # args: should be \"",
			 argv[0], " def scale\"",
			 (char *) NULL);
	return TCL_ERROR;
    }

    def = atof(argv[1]);
    scale = atof(argv[2]);

    plschr(def, scale);

    return TCL_OK;
}

/*--------------------------------------------------------------------------*\
 * plscol0Cmd
 *
 * Processes plscol0 Tcl command.
\*--------------------------------------------------------------------------*/

static int
plscol0Cmd(ClientData clientData, Tcl_Interp *interp,
	  int argc, char **argv)
{
    PLINT index, r, g, b;

    if (argc != 5 ) {
	Tcl_AppendResult(interp, "wrong # args: should be \"",
			 argv[0], " index R G B\"",
			 (char *) NULL);
	return TCL_ERROR;
    }

    index = atoi(argv[1]);
    r = atoi(argv[2]);
    g = atoi(argv[3]);
    b = atoi(argv[4]);

    plscol0(index, r, g, b);

    return TCL_OK;
}

/*--------------------------------------------------------------------------*\
 * plscolbgCmd
 *
 * Processes plscolbg Tcl command.
\*--------------------------------------------------------------------------*/

static int
plscolbgCmd(ClientData clientData, Tcl_Interp *interp,
	  int argc, char **argv)
{
    PLINT r, g, b;

    if (argc != 4 ) {
	Tcl_AppendResult(interp, "wrong # args: should be \"",
			 argv[0], " R G B\"",
			 (char *) NULL);
	return TCL_ERROR;
    }

    r = atoi(argv[1]);
    g = atoi(argv[2]);
    b = atoi(argv[3]);

    plscolbg(r, g, b);

    return TCL_OK;
}
#endif

/*--------------------------------------------------------------------------*\
 * plmeshCmd
 *
 * Processes plmesh Tcl command.
 *
 * We support 3 different invocation forms:
 * 1)	plmesh x y z nx ny opt
 * 2)	plmesh x y z opt
 * 3)	plmesh z opt
 *
 * Form 1) is an exact mirror of the usual C API.  In form 2) we infer nx and
 * ny from the input data, and in form 3 we inver nx and ny, and also take
 * the x and y arrays to just be integral spacing.
\*--------------------------------------------------------------------------*/

static int
plmeshCmd( ClientData clientData, Tcl_Interp *interp,
	   int argc, char *argv[] )
{
    PLINT nx, ny, opt;
    PLFLT *x, *y, **z;
    tclMatrix *matx, *maty, *matz, *matPtr;
    int i;

    if (argc == 7) {
	nx   = atoi( argv[4] );
	ny   = atoi( argv[5] );
	opt  = atoi( argv[6] );

	matx = Tcl_GetMatrixPtr( interp, argv[1] );
	maty = Tcl_GetMatrixPtr( interp, argv[2] );
	matz = Tcl_GetMatrixPtr( interp, argv[3] );
	matPtr = matz;		/* For dumb indexer macro, grrrr. */

	if ( matx->type != TYPE_FLOAT ||
	     maty->type != TYPE_FLOAT ||
	     matz->type != TYPE_FLOAT ) {
	    interp->result = "x y and z must all be float";
	    return TCL_ERROR;
	}

	if ( matx->dim != 1 || matx->n[0] != nx ||
	     maty->dim != 1 || maty->n[0] != ny ||
	     matz->dim != 2 || matz->n[0] != nx || matz->n[1] != ny ) {
	    interp->result = "Inconsistent dimensions";
	    return TCL_ERROR;
	}

	x = matx->fdata;
	y = maty->fdata;

	z = (PLFLT **) malloc( nx * sizeof(PLFLT *) );
	for( i=0; i < nx; i++ )
	    z[i] = &matz->fdata[ I2D(i,0) ];
    }
    else if (argc == 5) {
	opt  = atoi( argv[4] );

	matx = Tcl_GetMatrixPtr( interp, argv[1] );
	maty = Tcl_GetMatrixPtr( interp, argv[2] );
	matz = Tcl_GetMatrixPtr( interp, argv[3] );
	matPtr = matz;		/* For dumb indexer macro, grrrr. */

	if ( matx->type != TYPE_FLOAT ||
	     maty->type != TYPE_FLOAT ||
	     matz->type != TYPE_FLOAT ) {
	    interp->result = "x y and z must all be float";
	    return TCL_ERROR;
	}

	nx = matx->n[0]; ny = maty->n[0];

	if ( matx->dim != 1 || matx->n[0] != nx ||
	     maty->dim != 1 || maty->n[0] != ny ||
	     matz->dim != 2 || matz->n[0] != nx || matz->n[1] != ny ) {
	    interp->result = "Inconsistent dimensions";
	    return TCL_ERROR;
	}

	x = matx->fdata;
	y = maty->fdata;

	z = (PLFLT **) malloc( nx * sizeof(PLFLT *) );
	for( i=0; i < nx; i++ )
	    z[i] = &matz->fdata[ I2D(i,0) ];
    }
    else if (argc == 3) {
	interp->result = "unimplemented";
	return TCL_ERROR;
    }
    else {
	Tcl_AppendResult(interp, "wrong # args: should be \"plmesh ",
			 "x y z nx ny opt\", or a valid contraction ",
			 "thereof.", (char *) NULL);
	return TCL_ERROR;
    }

    plmesh( x, y, z, nx, ny, opt );

    if (argc == 7) {
	free(z);
    }
    else if (argc == 5) {
	free(z);
    }
    else {			/* argc == 3 */
    }

    plflush();
    return TCL_OK;
}

/*--------------------------------------------------------------------------*\
 * plot3dCmd
 *
 * Processes plot3d Tcl command.
 *
 * We support 3 different invocation forms:
 * 1)	plot3d x y z nx ny opt side
 * 2)	plot3d x y z opt side
 * 3)	plot3d z opt side
 *
 * Form 1) is an exact mirror of the usual C API.  In form 2) we infer nx and
 * ny from the input data, and in form 3 we inver nx and ny, and also take
 * the x and y arrays to just be integral spacing.
\*--------------------------------------------------------------------------*/

static int
plot3dCmd( ClientData clientData, Tcl_Interp *interp,
	   int argc, char *argv[] )
{
    PLINT nx, ny, opt, side;
    PLFLT *x, *y, **z;
    tclMatrix *matx, *maty, *matz, *matPtr;
    int i;

    if (argc == 8) {
	nx   = atoi( argv[4] );
	ny   = atoi( argv[5] );
	opt  = atoi( argv[6] );
	side = atoi( argv[7] );

	matx = Tcl_GetMatrixPtr( interp, argv[1] );
	maty = Tcl_GetMatrixPtr( interp, argv[2] );
	matz = Tcl_GetMatrixPtr( interp, argv[3] );
	matPtr = matz;		/* For dumb indexer macro, grrrr. */

	if ( matx->type != TYPE_FLOAT ||
	     maty->type != TYPE_FLOAT ||
	     matz->type != TYPE_FLOAT ) {
	    interp->result = "x y and z must all be float";
	    return TCL_ERROR;
	}

	if ( matx->dim != 1 || matx->n[0] != nx ||
	     maty->dim != 1 || maty->n[0] != ny ||
	     matz->dim != 2 || matz->n[0] != nx || matz->n[1] != ny ) {
	    interp->result = "Inconsistent dimensions";
	    return TCL_ERROR;
	}

	x = matx->fdata;
	y = maty->fdata;

	z = (PLFLT **) malloc( nx * sizeof(PLFLT *) );
	for( i=0; i < nx; i++ )
	    z[i] = &matz->fdata[ I2D(i,0) ];
    }
    else if (argc == 6) {
	opt  = atoi( argv[4] );
	side = atoi( argv[5] );

	matx = Tcl_GetMatrixPtr( interp, argv[1] );
	maty = Tcl_GetMatrixPtr( interp, argv[2] );
	matz = Tcl_GetMatrixPtr( interp, argv[3] );
	matPtr = matz;		/* For dumb indexer macro, grrrr. */

	if ( matx->type != TYPE_FLOAT ||
	     maty->type != TYPE_FLOAT ||
	     matz->type != TYPE_FLOAT ) {
	    interp->result = "x y and z must all be float";
	    return TCL_ERROR;
	}

	nx = matx->n[0]; ny = maty->n[0];

	if ( matx->dim != 1 || matx->n[0] != nx ||
	     maty->dim != 1 || maty->n[0] != ny ||
	     matz->dim != 2 || matz->n[0] != nx || matz->n[1] != ny ) {
	    interp->result = "Inconsistent dimensions";
	    return TCL_ERROR;
	}

	x = matx->fdata;
	y = maty->fdata;

	z = (PLFLT **) malloc( nx * sizeof(PLFLT *) );
	for( i=0; i < nx; i++ )
	    z[i] = &matz->fdata[ I2D(i,0) ];
    }
    else if (argc == 4) {
	interp->result = "unimplemented";
	return TCL_ERROR;
    }
    else {
	Tcl_AppendResult(interp, "wrong # args: should be \"plot3d ",
			 "x y z nx ny opt side\", or a valid contraction ",
			 "thereof.", (char *) NULL);
	return TCL_ERROR;
    }

    plot3d( x, y, z, nx, ny, opt, side );

    if (argc == 8) {
	free(z);
    }
    else if (argc == 6) {
	free(z);
    }
    else {			/* argc == 4 */
    }

    plflush();
    return TCL_OK;
}

/*--------------------------------------------------------------------------*\
 * plsetoptCmd
 *
 * Processes plsetopt Tcl command.
 * Just calls plSetInternalOpt() 
\*--------------------------------------------------------------------------*/

static int
plsetoptCmd(ClientData clientData, Tcl_Interp *interp,
	     int argc, char **argv)
{
    if (argc < 2 || argc > 3) {
	Tcl_AppendResult(interp, "wrong # args: should be \"",
			 argv[0], " option ?argument?\"", (char *) NULL);
	return TCL_ERROR;
    }

    plSetInternalOpt(argv[1], argv[2]);

    plflush();
    return TCL_OK;
}

/*--------------------------------------------------------------------------*\
 * plshadeCmd
 *
 * Processes plshade Tcl command.
 * C version takes:
 *    data, nx, ny, defined,
 *    xmin, xmax, ymin, ymax,
 *    sh_min, sh_max, sh_cmap, sh_color, sh_width,
 *    min_col, min_wid, max_col, max_wid,
 *    plfill, rect, pltr, pltr_data
 *
 * We will be getting data through a 2-d Matrix, which carries along
 * nx and ny, so no need for those.  Toss defined.  Toss plfill since
 * it is the only valid choice anyway, and assume rect==1 and no
 * transformation, since I don't know how to do anything else anyway.
\*--------------------------------------------------------------------------*/

static int
plshadeCmd(ClientData clientData, Tcl_Interp *interp,
	 int argc, char **argv)
{
    int result = TCL_OK;
    tclMatrix *matPtr;

    PLFLT xmin, xmax, ymin, ymax, sh_min, sh_max, sh_col;

    PLFLT **z;
    PLINT sh_cmap =1, sh_wid =2;
    PLINT min_col =1, min_wid =0, max_col =0, max_wid =0;
    PLINT rect =1;
    int i, j;

    if (argc < 9 ) {
	Tcl_AppendResult(interp, "wrong # args: should be \"",
			 argv[0], " \"",
			 (char *) NULL);
	return TCL_ERROR;
    }

    matPtr = Tcl_GetMatrixPtr( interp, argv[1] );

    if (matPtr->dim != 2) {
	interp->result = "Must plot a 2-d matrix.";
	return TCL_ERROR;
    }

    plAlloc2dGrid( &z, matPtr->n[0], matPtr->n[1] );
    
    for( i=0; i < matPtr->n[0]; i++ )
	for( j=0; j < matPtr->n[1]; j++ )
	    z[i][j] = matPtr->fdata[I2D(i,j)];

    xmin = atof( argv[2] );
    xmax = atof( argv[3] );
    ymin = atof( argv[4] );
    ymax = atof( argv[5] );
    sh_min = atof( argv[6] );
    sh_max = atof( argv[7] );
    sh_col = atof( argv[8] );

    for( i=9; i < argc; i++ ) {
	/* process argv[i] for options like -min_col 4, etc. */
	/* Jump to end if error, so z is freed. */
    }

    plshade( z, matPtr->n[0], matPtr->n[1], NULL,
	     xmin, xmax, ymin, ymax,
	     sh_min, sh_max, sh_cmap, sh_col, sh_wid,
	     min_col, min_wid, max_col, max_wid,
	     plfill, rect, NULL, NULL );

    plflush();

  end:
    free( (void *) z );
    return result;
}

#if 0
/*--------------------------------------------------------------------------*\
 * plsstrmCmd
 *
 * Processes plsstrm Tcl command.
\*--------------------------------------------------------------------------*/

static int
plsstrmCmd(ClientData clientData, Tcl_Interp *interp,
	   int argc, char **argv)
{
    PLINT strm;

    if (argc != 2 ) {
	Tcl_AppendResult(interp, "wrong # args: should be \"",
			 argv[0], " stream-number\"",
			 (char *) NULL);
	return TCL_ERROR;
    }

    strm = atoi(argv[1]);

    plsstrm(strm);

    return TCL_OK;
}

/*--------------------------------------------------------------------------*\
 * plssubCmd
 *
 * Processes plssub Tcl command.
\*--------------------------------------------------------------------------*/

static int
plssubCmd(ClientData clientData, Tcl_Interp *interp,
	  int argc, char **argv)
{
    PLINT nsubx, nsuby;

    if (argc != 3 ) {
	Tcl_AppendResult(interp, "wrong # args: should be \"",
			 argv[0], " nsubx nsuby\"",
			 (char *) NULL);
	return TCL_ERROR;
    }

    nsubx = atoi(argv[1]);
    nsuby = atoi(argv[2]);

    plssub(nsubx, nsuby);

    plflush();
    return TCL_OK;
}

/*--------------------------------------------------------------------------*\
 * plstylCmd
 *
 * Processes plstyl Tcl command.
\*--------------------------------------------------------------------------*/

static int
plstylCmd(ClientData clientData, Tcl_Interp *interp,
	 int argc, char **argv)
{
    PLINT *space, *mark, nels;
    tclMatrix *mat1, *mat2;

    if (argc != 4 ) {
	Tcl_AppendResult(interp, "wrong # args: should be \"",
			 argv[0], " nels mark-array space-array\"",
			 (char *) NULL);
	return TCL_ERROR;
    }

    nels = atoi(argv[1]);
    mat1 = Tcl_GetMatrixPtr(interp, argv[2]);
    space = mat1->idata;
    mat2 = Tcl_GetMatrixPtr(interp, argv[3]);
    mark = mat2->idata;

    plstyl(nels, mark, space);

    return TCL_OK;
}

/*--------------------------------------------------------------------------*\
 * plsxaxCmd
 *
 * Processes plsxax Tcl command.
\*--------------------------------------------------------------------------*/

static int
plsxaxCmd(ClientData clientData, Tcl_Interp *interp,
	  int argc, char **argv)
{
    PLINT digmax;

    if (argc < 1 ) {
	Tcl_AppendResult(interp, "wrong # args: should be \"",
			 argv[0], " digmax\"",
			 (char *) NULL);
	return TCL_ERROR;
    }

    digmax = atoi(argv[1]);

    plsxax(digmax, 0);

    return TCL_OK;
}

/*--------------------------------------------------------------------------*\
 * plsyaxCmd
 *
 * Processes plsyax Tcl command.
\*--------------------------------------------------------------------------*/

static int
plsyaxCmd(ClientData clientData, Tcl_Interp *interp,
	  int argc, char **argv)
{
    PLINT digmax;

    if (argc < 1 ) {
	Tcl_AppendResult(interp, "wrong # args: should be \"",
			 argv[0], " digmax\"",
			 (char *) NULL);
	return TCL_ERROR;
    }

    digmax = atoi(argv[1]);

    plsyax(digmax, 0);

    return TCL_OK;
}

/*--------------------------------------------------------------------------*\
 * plsymCmd
 *
 * Processes plsym Tcl command.
\*--------------------------------------------------------------------------*/

static int
plsymCmd(ClientData clientData, Tcl_Interp *interp,
	 int argc, char **argv)
{
    PLFLT *x, *y;
    tclMatrix *matx, *maty;
    int n, code;

    if (argc != 5 ) {
	Tcl_AppendResult(interp, "wrong # args: should be \"", argv[0],
			 " n x-array y-array code\"",
			 (char *) NULL);
	return TCL_ERROR;
    }

    matx = Tcl_GetMatrixPtr(interp, argv[2]);
    x = matx->fdata;
    maty = Tcl_GetMatrixPtr(interp, argv[3]);
    y = maty->fdata;
    code = atoi( argv[4] );

    if (strncmp(argv[1], "*", 1) == 0)
	n = MIN(matx->len, maty->len);
    else
	n = atoi(argv[1]);

    plsym( n, x, y, code );

    plflush();
    return TCL_OK;
}

/*--------------------------------------------------------------------------*\
 * pltextCmd
 *
 * Processes pltext Tcl command.
\*--------------------------------------------------------------------------*/

static int
pltextCmd(ClientData clientData, Tcl_Interp *interp,
	  int argc, char **argv)
{
    if (argc > 1 ) {
	Tcl_AppendResult(interp, "wrong # args: should be \"",
			 argv[0], " \"",
			 (char *) NULL);
	return TCL_ERROR;
    }

    pltext();

    return TCL_OK;
}

/*--------------------------------------------------------------------------*\
 * plvpasCmd
 *
 * Processes plvpas Tcl command.
\*--------------------------------------------------------------------------*/

static int
plvpasCmd( ClientData clientData, Tcl_Interp *interp,
	   int argc, char **argv)
{
    PLFLT xmin, xmax, ymin, ymax, asp;

    if (argc != 6 ) {
	Tcl_AppendResult(interp, "wrong # args: should be \"",
			 argv[0], " xmin xmax ymin ymax asp\"",
			 (char *) NULL);
	return TCL_ERROR;
    }

    xmin = atof( argv[1] );
    xmax = atof( argv[2] );
    ymin = atof( argv[3] );
    ymax = atof( argv[4] );
    asp  = atof( argv[6] );

    plvpas( xmin, xmax, ymin, ymax, asp );

    return TCL_OK;
}

/*--------------------------------------------------------------------------*\
 * plvporCmd
 *
 * Processes plvpor Tcl command.
\*--------------------------------------------------------------------------*/

static int
plvporCmd(ClientData clientData, Tcl_Interp *interp,
	  int argc, char **argv)
{
    PLFLT xmin, xmax, ymin, ymax;

    if (argc != 5 ) {
	Tcl_AppendResult(interp, "wrong # args: should be \"",
			 argv[0], " xmin xmax ymin ymax\"",
			 (char *) NULL);
	return TCL_ERROR;
    }

    xmin = atof( argv[1] );
    xmax = atof( argv[2] );
    ymin = atof( argv[3] );
    ymax = atof( argv[4] );

    plvpor(xmin, xmax, ymin, ymax);

    return TCL_OK;
}

/*--------------------------------------------------------------------------*\
 * plvstaCmd
 *
 * Processes plvsta Tcl command.
\*--------------------------------------------------------------------------*/

static int
plvstaCmd(ClientData clientData, Tcl_Interp *interp,
	  int argc, char **argv)
{
    if (argc > 1 ) {
	Tcl_AppendResult(interp, "wrong # args: should be \"",
			 argv[0], " \"",
			 (char *) NULL);
	return TCL_ERROR;
    }

    plvsta();

    return TCL_OK;
}

/*--------------------------------------------------------------------------*\
 * plwidCmd
 *
 * Processes plwid Tcl command.
\*--------------------------------------------------------------------------*/

static int
plwidCmd(ClientData clientData, Tcl_Interp *interp,
	 int argc, char **argv)
{
    PLINT width;

    if (argc != 2 ) {
	Tcl_AppendResult(interp, "wrong # args: should be \"",
			 argv[0], " width\"",
			 (char *) NULL);
	return TCL_ERROR;
    }

    width = atoi(argv[1]);

    plwid(width);

    return TCL_OK;
}

/*--------------------------------------------------------------------------*\
 * plwindCmd
 *
 * Processes plwind Tcl command.
\*--------------------------------------------------------------------------*/

static int
plwindCmd(ClientData clientData, Tcl_Interp *interp,
	  int argc, char **argv)
{
    PLFLT xmin, xmax, ymin, ymax;

    if (argc != 5 ) {
	Tcl_AppendResult(interp, "wrong # args: should be \"",
			 argv[0], " xmin xmax ymin ymax\"",
			 (char *) NULL);
	return TCL_ERROR;
    }

    xmin = atof(argv[1]);
    xmax = atof(argv[2]);
    ymin = atof(argv[3]);
    ymax = atof(argv[4]);

    plwind(xmin, xmax, ymin, ymax);

    plflush();
    return TCL_OK;
}
#endif
