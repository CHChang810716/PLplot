\chapter {PLPLOT Subroutine Reference} \label{reference}

All the PLPLOT subroutines are listed below in alphabetical order.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{pladv(sub)}\label{pladv}
\addcontentsline{toc}{subsection}{pladv}

\descr{ Advances to the next subpage if {\tt sub=0}, performing a page
advance if there are no remaining subpages on the current page.  If
subwindowing isn't being used, {\tt pladv(0)} will always advance the page.
If {\tt sub>0}, PLPLOT switches to the specified subpage.  Note that this
allows you to overwrite a plot on the specified subpage; if this is not what
you intended, use {\tt plclr} followed by {\tt plpage} to first advance the
page.  This routine is called automatically (with {\tt sub=0}) by {\tt
plenv}, but if {\tt plenv} is not used, {\tt pladv} must be called after
initializing PLPLOT but before defining the viewport.}

\argu{ {\tt sub} (PLINT, input)}{Specifies the subpage number (starting from
1 in the top left corner and increasing along the rows) to which to advance.
Set to zero to advance to the next subpage.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plancol(color, name)}\label{plancol}
\addcontentsline{toc}{subsection}{plancol}

\descr{ Allocates the specified named color and assigns it to the color
numbered {\tt color}.  Supported by the X-window driver only at present.
See {\tt plcol} for more information.}

\argu{ {\tt color} (PLINT, input)}{Specifies the color number as set by the
{\tt plcol} command.}

\argu{ {\tt name} (char *, input)}{Specifies the color name.  The RGB values
corresponding to the given color are those given by the X11 RGB data base
({\tt rgb.txt}).}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plbin(nbin, x, y, cen)}\label{plbin}
\addcontentsline{toc}{subsection}{plbin}

\descr{ Plots a histogram consisting of {\tt n} bins.  The value associated
with the {\tt i}'th bin is placed in {\tt x[i]}, and the number of points in
the bin is placed in {\tt y[i]}.  For proper operation, the values in {\tt
x[i]} must form a strictly increasing sequence.  If {\tt center} is false, 
{\tt x[i]} is the left-hand edge of the {\tt i'th} bin, and if {\tt center}
is true, the bin boundaries are placed midway between the values in the {\tt
x}~array.  Also see {\tt plhist} for drawing histograms from unbinned data.}

\argu{ {\tt nbin} (PLINT, input)}{Number of bins (i.e., number of values in
$x$ and $y$ arrays.)}

\argu{ {\tt x} (PLFLT *, input)}{Pointer to array containing values
associated with bins.  These must form a strictly increasing sequence.}

\argu{ {\tt y} (PLFLT *, input)}{Pointer to array containing number of
points in bin.  This is a PLFLT (instead of PLINT) array so as to allow
histograms of probabilities, etc.}

\argu{ {\tt cen} (PLINT, input)}{Indicates whether the values in {\tt x}
represent the lower bin boundaries ({\tt cen=0}) or whether the bin
boundaries are to be midway between the {\tt x} values ({\tt cen=1}).  If
the values in {\tt x} are equally spaced and {\tt cen=1}, the values in {\tt
x} are the center values of the bins.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plbox(xopt, xtick, nxsub, yopt, ytick, nysub)}\label{plbox}
\addcontentsline{toc}{subsection}{plbox}

\descr{ Draws a box around the currently defined viewport, and labels it
with world coordinate values appropriate to the window.  Thus {\tt plbox}
should only be called after defining both viewport and window.  The
character strings {\tt xopt} and {\tt yopt} specify how the box should be
drawn as described below.  If ticks and/or subticks are to be drawn for a
particular axis, the tick intervals and number of subintervals may be
specified explicitly, or they may be defaulted by setting the appropriate
arguments to zero.}

\argu{ {\tt xopt} (char *, input)}{Pointer to character string specifying
options for horizontal axis.  The string can include any combination of the
following letters (upper or lower case) in any order:
\begin{itemize}
\item{{\tt a :}} Draws axis, X-axis is horizontal line {\tt y=0}, and Y-axis
is vertical line {\tt x=0}.
\item{{\tt b :}} Draws bottom (X) or left (Y) edge of frame.
\item{{\tt c :}} Draws top (X) or right (Y) edge of frame.
\item{{\tt g :}} Draws a grid at the major tick interval.
\item{{\tt i :}} Inverts tick marks, so they are drawn outwards, rather than
inwards.
\item{{\tt l :}} Labels axis logarithmically. This only affects the labels, 
not the data, and so it is necessary to compute the logarithms of data
points before passing them to any of the drawing routines.
\item{{\tt m :}} Writes numeric labels at major tick intervals in the
unconventional location (above box for X, right of box for Y).
\item{{\tt n :}} Writes numeric labels at major tick intervals in the
conventional location (below box for X, left of box for Y).
\item{{\tt s :}} Enables subticks between major ticks, only valid if {\tt t} is
also specified.
\item{{\tt t :}} Draws major ticks.
\end{itemize}}

\argu{ {\tt xtick} (PLFLT, input)}{World coordinate interval between major
ticks on the x~axis.  If it is set to zero, PLPLOT automatically generates a
suitable tick interval.}

\argu{ {\tt nxsub} (PLINT, input)}{Number of subintervals between major
x~axis ticks for minor ticks.  If it is set to zero, PLPLOT automatically
generates a suitable minor tick interval.}

\argu{ {\tt yopt} (char *, input)}{Pointer to character string specifying
options for vertical axis.  The string can include any combination of the
letters defined above for {\tt xopt}, and in addition may contain:
\begin{itemize} 
\item{{\tt v }}{:  Write numeric labels for vertical axis
parallel to the base of the graph, rather than parallel to the axis.}
\end{itemize} }

\argu{ {\tt ytick} (real, input)}{World coordinate interval between major
ticks on the y~axis.  If it is set to zero, PLPLOT automatically generates a
suitable tick interval.}

\argu{ {\tt nysub} (PLINT, input)}{Number of subintervals between major
y~axis ticks for minor ticks.  If it is set to zero, PLPLOT automatically
generates a suitable minor tick interval.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{ \begin{tabular}{l@{\strut}l}
plbox3(&xopt, xlabel, xtick, nxsub, yopt, ylabel, ytick, nysub, \\
&zopt, zlabel, ztick, nzsub)
\end{tabular}
} \label{plbox3}
\addcontentsline{toc}{subsection}{plbox3}

\descr{ Draws axes, numeric and text labels for a three-dimensional surface
plot. See Section \ref{threed} on page \pageref{threed} for a
more complete description of three-dimensional plotting.}

\argu{ {\tt xopt} (char *, input)}{Pointer to character string specifying
options for the x~axis.  The string can include any combination of the
following letters (upper or lower case) in any order:
\begin{itemize}
\item{{\tt b :}} Draws axis at base, at height {\tt z=zmin} where {\tt zmin} is defined
by call to {\tt plw3d}. This character must be specified in order to use any
of the other options.
\item{{\tt i :}} Inverts tick marks, so they are drawn downwards, rather than
upwards.
\item{{\tt l :}} Labels axis logarithmically. This only affects the labels, 
not the data, and so it is necessary to compute the logarithms of data
points before passing them to any of the drawing routines.
\item{{\tt n :}} Writes numeric labels at major tick intervals.
\item{{\tt s :}} Enables subticks between major ticks, only valid if {\tt t} is
also specified.
\item{{\tt t :}} Draws major ticks.
\item{{\tt u :}} If this is specified, the text label for the axis is written
under the axis.
\end{itemize}
}

\argu{ {\tt xlabel} (char *, input)}{Pointer to character string specifying
text label for the x~axis.  It is only drawn if {\tt u} is in the {\tt xopt}
string.}

\argu{ {\tt xtick} (PLFLT, input)}{World coordinate interval between major
ticks on the x~axis.  If it is set to zero, PLPLOT automatically generates a
suitable tick interval.}

\argu{ {\tt nxsub} (PLINT, input)}{Number of subintervals between major
x~axis ticks for minor ticks.  If it is set to zero, PLPLOT automatically
generates a suitable minor tick interval.}

\argu{ {\tt yopt} (char *, input)}{Pointer to character string specifying
options for the y~axis.  The string is interpreted in the same way as {\tt
xopt}.}

\argu{ {\tt ylabel} (char *, input)}{Pointer to character string specifying
text label for the y~axis.  It is only drawn if {\tt u} is in the {\tt yopt}
string.}

\argu{ {\tt ytick} (PLFLT, input)}{World coordinate interval between major
ticks on the y~axis.  If it is set to zero, PLPLOT automatically generates a
suitable tick interval.}

\argu{ {\tt nysub} (PLINT, input)}{Number of subintervals between major
y~axis ticks for minor ticks.  If it is set to zero, PLPLOT automatically
generates a suitable minor tick interval.}

\argu{ {\tt zopt} (char *, input)}{Pointer to character string specifying
options for the z~axis.  The string can include any combination of the
following letters (upper or lower case) in any order:
\begin{itemize}
\item{{\tt b :}} Draws z~axis to the left of the surface plot.
\item{{\tt c :}} Draws z~axis to the right of the surface plot.
\item{{\tt d :}} Draws grid lines parallel to the x-y plane behind the figure.
These lines are not drawn until after {\tt plot3d} or {\tt plmesh} are called
because of the need for hidden line removal.
\item{{\tt i :}} Inverts tick marks, so they are drawn away from the center.
\item{{\tt l :}} Labels axis logarithmically. This only affects the labels, 
not the data, and so it is necessary to compute the logarithms of data
points before passing them to any of the drawing routines.
\item{{\tt m :}} Writes numeric labels at major tick intervals on the right-hand
verical axis.
\item{{\tt n :}} Writes numeric labels at major tick intervals on the left-hand
verical axis.
\item{{\tt s :}} Enables subticks between major ticks, only valid if {\tt t} is
also specified.
\item{{\tt t :}} Draws major ticks.
\item{{\tt u :}} If this is specified, the text label is written beside the
left-hand axis.
\item{{\tt v :}} If this is specified, the text label is written beside the
right-hand axis.
\end{itemize}
}

\argu{ {\tt zlabel} (char *, input)}{Pointer to character string specifying
text label for the z~axis.  It is only drawn if {\tt u} or {\tt v} are in
the {\tt zopt} string.}

\argu{ {\tt ztick} (PLFLT, input)}{World coordinate interval between major
ticks on the z~axis.  If it is set to zero, PLPLOT automatically generates a
suitable tick interval.}

\argu{ {\tt nzsub} (PLINT, input)}{Number of subintervals between major
z~axis ticks for minor ticks.  If it is set to zero, PLPLOT automatically
generates a suitable minor tick interval.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plclr()}\label{plclr}
\addcontentsline{toc}{subsection}{plclr}

\descr{ Clears the graphics screen of an interactive device, or ejects a
page on a plotter.  See {\tt plpage} for more information.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plcol(color)}\label{plcol}
\addcontentsline{toc}{subsection}{plcol}

\descr{ Sets the color for subsequent lines.  You may specify which colors
are associated with which number by the {\tt plancol} routine if supported
by the output driver.}

\argu{ {\tt color} (PLINT, input)}{Integer representing the color.  The
defaults at present are (these may change):
\begin{description}
\item [0]	coral
\item [1]	red
\item [2]	yellow
\item [3]	green
\item [4]	aquamarine
\item [5]	pink
\item [6]	wheat
\item [7]	grey
\item [8]	brown
\item [9]	blue
\item [10]	BlueViolet
\item [11]	cyan
\item [12]	turquoise
\item [13]	magenta
\item [14]	salmon
\item [15]	white (default foreground)
\item [16]	black (default background)
\end{description}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bnameF{plcon0(z, nx, ny, kx, lx, ky, ly, clevel, nlevel)}\label{plcon0}
\addcontentsline{toc}{subsection}{plcon0}

\descr{ Draws a contour plot of the data in {\tt z[nx][ny]}, using the {\tt
nlevel} contour levels specified by {\tt clevel}.  Only the region of the
array from {\tt kx} to {\tt lx} and from {\tt ky} to {\tt ly} is plotted
out.  See Section \ref{contour} for more information.}

\argu{ {\tt z} (PLFLT **, input)} {Pointer to a vectored two-dimensional array
containing data to be contoured.}

\argu{ {\tt nx, ny} (PLINT, input)} {Physical dimensions of array {\tt z}.}

\argu{ {\tt kx, lx} (PLINT, input)} {Range of {\tt x} indicies to consider.}

\argu{ {\tt ky, ly} (PLINT, input)} {Range of {\tt y} indicies to consider.}

\argu{ {\tt clevel} (PLFLT *, input)} {Pointer to array specifying
    levels at which to draw contours.}

\argu{ {\tt nlevel} (PLINT, input)} {Number of contour levels to draw.}

NOTE: this function is intended for use from a Fortran caller only.  The C
user should instead call {\tt plcont} using the built-in transformation
function {\tt pltr0} for the same capability. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bnameF{plcon1(z, nx, ny, kx, lx, ky, ly, clevel, nlevel, xg, yg)}\label{plcon1}
\addcontentsline{toc}{subsection}{plcon1}

\descr{ Draws a contour plot of the data in {\tt z[nx][ny]}, using the {\tt
nlevel} contour levels specified by {\tt clevel}.  Only the region of the
array from {\tt kx} to {\tt lx} and from {\tt ky} to {\tt ly} is plotted
out.  The arrays {\tt xg} and {\tt yg} are used to specify the
transformation between array indices and world coordinates.  See Section
\ref{contour} for more information.}

\argu{ {\tt z} (PLFLT **, input)} {Pointer to a vectored two-dimensional array
containing data to be contoured.}

\argu{ {\tt nx, ny} (PLINT, input)} {Physical dimensions of array {\tt z}.}

\argu{ {\tt kx, lx} (PLINT, input)} {Range of {\tt x} indicies to consider.}

\argu{ {\tt ky, ly} (PLINT, input)} {Range of {\tt y} indicies to consider.}

\argu{ {\tt clevel} (PLFLT *, input)} {Pointer to array specifying
    levels at which to draw contours.}

\argu{ {\tt nlevel} (PLINT, input)} {Number of contour levels to draw.}

\argu{ {\tt xg, yg} (PLFLT *, input)}{Pointers to arrays which specify the
transformation from array indices to world coordinates.  These must be
one-dimensional arrays, used for a transformation of the form:  {\tt
tx$=$f(x), ty$=$f(y)}.  Function values at locations between grid points are
obtained via linear interpolation. }

NOTE: this function is intended for use from a Fortran caller only.  The C
user should instead call {\tt plconf} using the built-in transformation
function {\tt pltr1} for the same capability. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bnameF{plcon2(z, nx, ny, kx, lx, ky, ly, clevel, nlevel, xg, yg)}\label{plcon2}
\addcontentsline{toc}{subsection}{plcon2}

\descr{ Draws a contour plot of the data in {\tt z[nx][ny]}, using the {\tt
nlevel} contour levels specified by {\tt clevel}.  Only the region of the
array from {\tt kx} to {\tt lx} and from {\tt ky} to {\tt ly} is plotted
out.  The arrays {\tt xg} and {\tt yg} are used to specify the
transformation between array indices and world coordinates.  See Section
\ref{contour} for more information.}

\argu{ {\tt z} (PLFLT **, input)} {Pointer to a vectored two-dimensional array
containing data to be contoured.}

\argu{ {\tt nx, ny} (PLINT, input)} {Physical dimensions of array {\tt z}.}

\argu{ {\tt kx, lx} (PLINT, input)} {Range of {\tt x} indicies to consider.}

\argu{ {\tt ky, ly} (PLINT, input)} {Range of {\tt y} indicies to consider.}

\argu{ {\tt clevel} (PLFLT *, input)} {Pointer to array specifying
    levels at which to draw contours.}

\argu{ {\tt nlevel} (PLINT, input)} {Number of contour levels to draw.}

\argu{ {\tt xg, yg} (PLFLT *, input)}{Pointers to arrays which specify the
transformation from array indices to world coordinates.  These must be
two-dimensional arrays, used for a transformation of the form:  {\tt
tx$=$f(x, y), ty$=$f(x, y)}.  Function values at locations between grid points
are obtained via linear interpolation.}

NOTE: this function is intended for use from a Fortran caller only.  The C
user should instead call {\tt plconf} using the built-in transformation
function {\tt pltr2} for the same capability. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bnameC{plconf(z, nx, ny, kx, lx, ky, ly, clevel, nlevel, pltr, xg, yg)}\label{plconf}
\addcontentsline{toc}{subsection}{plconf}

\descr{ Draws a contour plot of the data in {\tt z[nx][ny]}, using the {\tt
nlevel} contour levels specified by {\tt clevel}.  Only the region of the
array from {\tt kx} to {\tt lx} and from {\tt ky} to {\tt ly} is plotted
out.  A transformation routine {\tt pltr} is used to map indicies within the
array to the world coordinates, using the transformation arrays {\tt xg} and
{\tt yg}.  See Section \ref{contour} for more information.}

\argu{ {\tt z} (PLFLT **, input)} {Pointer to a vectored two-dimensional array
containing data to be contoured.}

\argu{ {\tt nx, ny} (PLINT, input)} {Physical dimensions of array {\tt z}.}

\argu{ {\tt kx, lx} (PLINT, input)} {Range of {\tt x} indicies to consider.}

\argu{ {\tt ky, ly} (PLINT, input)} {Range of {\tt y} indicies to consider.}

\argu{ {\tt clevel} (PLFLT *, input)} {Pointer to array specifying
    levels at which to draw contours.}

\argu{ {\tt nlevel} (PLINT, input)} {Number of contour levels to draw.}

\argu{ {\tt pltr} (void *, input)} {Pointer to function that defines
transformation between indicies in array {\tt z} and the world coordinates.
The function should have the form
\name{pltr(x, y, tx, ty, xg, yg, nx, ny)}

\argu{ {\tt x, y} (PLFLT, input)}{ Specifies the position in the array through
which the contour runs in terms of the array indicies.}
\argu{ {\tt tx, ty} (PLFLT *, output)}{Pointers to the
world coordinates corresponding to the
point {\tt (x, y)}.}
\argu{ {\tt xg, yg} (PLFLT *, input)}{Pointers to transformation arrays.}
\argu{ {\tt nx, ny} (PLINT, input)}{Array dimensions in {\tt x} and {\tt y}, 
respectively.}
}
\argu{ {\tt xg, yg} (PLFLT *, input)}{Pointers to arrays which define the
transformation from {\tt (x, y)} to {\tt (tx, ty)}, used as input to the
transformation function {\tt pltr}.}

Two transformation functions are provided:  {\tt pltr1}, for one dimensional
mappings (i.e.~{\tt tx$=$f(x), ty$=$f(y)}), and {\tt pltr2}, for two
dimensional mappings (i.e.~{\tt tx$=$f(x, y), ty$=$f(x, y)}).  Function values
at locations between grid points are obtained via linear interpolation.  

NOTE:  this routine cannot be called directly from Fortran.  Use {\tt
plcon0}, {\tt plcon1}, or {\tt plcon2} instead.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bnameCF{plcont(z, nx, ny, kx, lx, ky, ly, clevel, nlevel, pltr)}{(C)}
	{plcont(z, nx, ny, kx, lx, ky, ly, clevel, nlevel, tr)}{\ \ (Fortran)}
\label{plcont}
\addcontentsline{toc}{subsection}{plcont}

\descr{ Draws a contour plot of the data in {\tt z[nx][ny]}, using the {\tt
nlevel} contour levels specified by {\tt clevel}.  Only the region of the
array from {\tt kx} to {\tt lx} and from {\tt ky} to {\tt ly} is plotted
out.  A transformation routine {\tt pltr} is used to map indicies within the
array to the world coordinates.  See Section \ref{contour} for more
information.}

\argu{ {\tt z} (PLFLT **, input)} {Pointer to a vectored two-dimensional array
containing data to be contoured.}

\argu{ {\tt nx, ny} (PLINT, input)} {Physical dimensions of array {\tt z}.}

\argu{ {\tt kx, lx} (PLINT, input)} {Range of {\tt x} indicies to consider.}

\argu{ {\tt ky, ly} (PLINT, input)} {Range of {\tt y} indicies to consider.}

\argu{ {\tt clevel} (PLFLT *, input)} {Pointer to array specifying
    levels at which to draw contours.}

\argu{ {\tt nlevel} (PLINT, input)} {Number of contour levels to draw.}

\argu{ {\tt pltr} (void *, input)} {Pointer to function that defines
transformation between indicies in array {\tt z} and the world coordinates
(C only).  Two transformation functions are provided:  {\tt xform}, for
simple linear mappings, and {\tt pltr0}, if no mapping is required.  {\tt
xform} is not actually compiled into the PLPLOT library due to the need for
external data; instead you must include it as part of your program.  The
function should have the form
\name{pltr(x, y, tx, ty)}

\argu{ {\tt x, y} (PLFLT, input)}{ Specifies the position in the array
through which the contour runs in terms of the array indicies.} \argu{ {\tt
tx, ty} (PLFLT *, output)}{Pointers to the world coordinates corresponding
to the point {\tt (x, y)}.} }

\argu{ {\tt tr} (PLFLT *, input)} {Pointer to 6-element array specifying
coefficients to use in the {\tt xform} transformation function (Fortran
only).  Since this is somewhat inflexible, the user is recommended to call
either of {\tt plcon0}, {\tt plcon1}, or {\tt plcon2} instead.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plend()}\label{plend}
\addcontentsline{toc}{subsection}{plend}

\descr{ Ends a plotting session, tidies up all the output files, switches
interactive devices back into text mode and frees up any memory that was
allocated.  Must be called before end of program.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plend1()}\label{plend1}
\addcontentsline{toc}{subsection}{plend}

\descr{ Ends a plotting session for the current output stream only.
See {\tt plsstrm} for more info.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plenv(xmin, xmax, ymin, ymax, just, axis)}\label{plenv}
\addcontentsline{toc}{subsection}{plenv}

\descr{ Sets up plotter environment for simple graphs by calling {\tt pladv}
and setting up viewport and window to sensible default values.  {\tt plenv}
leaves enough room around most graphs for axis labels and a title.  When
these defaults are not suitable, use the individual routines {\tt plvspa}, 
{\tt plvpor}, or {\tt plvasp} for setting up the viewport, {\tt plwind} for
defining the window, and {\tt plbox} for drawing the box.}

\argu{ {\tt xmin} (PLFLT, input)}{Value of~x at left-hand edge of window.}

\argu{ {\tt xmax} (PLFLT, input)}{Value of~x at right-hand edge of window.}

\argu{ {\tt ymin} (PLFLT, input)}{Value of~y at bottom edge of window.}

\argu{ {\tt ymax} (PLFLT, input)}{Value of~y at top edge of window.}

\argu{ {\tt just} (PLINT, input)}{If {\tt just=0}, the x~and~y axes are
scaled independently to use as much of the screen as possible, but if {\tt
just=1}, the scales of the x~and~y axes are made equal.}

\argu{ {\tt axis} (PLINT, input)}{Controls drawing of the box around the plot:
\begin{itemize}
\item{-2}: No box or annotation.
\item{-1}: Draw box only.
\item{0}: Draw box, labelled with coordinate values around edge.
\item{1}: In addition to box and labels, draw the two axes
{\tt x=0} and {\tt y=0}.
\item{2}: As for {\tt axis=1}, but also draw a grid at the major tick interval.
\item{10}: Logarithmic x axis, linear y axis.
\item{11}: Logarithmic x axis, linear y axis and draw line {\tt y=0}.
\item{20}: Linear x axis, logarithmic y axis.
\item{21}: Linear x axis, logarithmic y axis and draw line {\tt x=0}.
\item{30}: Logarithmic x and y axes.
\end{itemize}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plerrx(n, xmin, xmax, y)}\label{plerrx}
\addcontentsline{toc}{subsection}{plerrx}

\descr{ Draws a set of {\tt n} horizontal error bars, the {\tt i}'th error
bar extending from {\tt xmin[i]} to {\tt xmax[i]} at y~coordinate {\tt
y[i]}.  The terminals of the error bar are of length equal to the minor tick
length (settable using {\tt plsmin}).}

\argu{ {\tt n} (PLINT, input)}{Number of error bars to draw.}

\argu{ {\tt xmin} (PLFLT *, input)}{Pointer to array with x~coordinates of
left-hand endpoint of error bars.}

\argu{ {\tt xmax} (PLFLT *, input)}{Pointer to array with x~coordinates of
right-hand endpoint of error bars.}

\argu{ {\tt y} (PLFLT *, input)}{Pointer to array with y~coordinates of
error bar.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plerry(n, x, ymin, ymax)}\label{plerry}
\addcontentsline{toc}{subsection}{plerry}

\descr{ Draws a set of {\tt n} vertical error bars, the {\tt i}'th error bar
extending from {\tt ymin[i]} to {\tt ymax[i]} at x~coordinate {\tt x[i]}.
The terminals of the error bar are of length equal to the minor tick length
(settable using {\tt plsmin}).}

\argu{ {\tt n} (PLINT, input)}{Number of error bars to draw.}

\argu{ {\tt x} (PLFLT *, input)}{Pointer to array with x~coordinates of
error bars.}

\argu{ {\tt ymin} (PLFLT *, input)}{Pointer to array with y~coordinates of
lower endpoint of error bars.}

\argu{ {\tt ymax} (PLFLT *, input)}{Pointer to array with y~coordinate of
upper endpoint of error bar.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plexit(message)}\label{plexit}
\addcontentsline{toc}{subsection}{plexit}

\descr{ This routine is called in case an error is encountered during
execution of a PLPLOT routine.  It prints the error message, tries to
release allocated resources, calls {\tt pl\_exit} and then exits.  If
cleanup needs to be done in the driver program then the user may want to
supply his/her own version of {\tt pl\_exit}.}

\argu{ {\tt message} (char *, input)}{Error message.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{pl\_exit()}\label{plxexit}
\addcontentsline{toc}{subsection}{pl\_exit}

\descr{ This routine does nothing.  It is intended to be replaced by a user
routine of the same name so that any user allocated resources can be
released in the case of an error (C programs only).  See {\tt plexit}
above.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plfill(n, x, y)}\label{plfill}
\addcontentsline{toc}{subsection}{plfill}

\descr{ Fills the polygon defined by the {\tt n} points {\tt (x[i], y[i])}
using the pattern defined by {\tt plpsty} or {\tt plpat}.  The routine will
automatically close the polygon between the last and first vertices.  If
multiple closed polygons are passed in {\tt x} and {\tt y} then {\tt plfill}
will fill in between them.}

\argu{ {\tt n} (PLINT, input)}{Number of vertices in polygon.}

\argu{ {\tt x} (PLFLT *, input)}{Pointer to array with x~coordinates of
vertices.}

\argu{ {\tt y} (PLFLT *, input)}{Pointer to array with y~coordinates of
vertices.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plfont(font)}\label{plfont}
\addcontentsline{toc}{subsection}{plfont}

\descr{ Sets the default character font for subsequent character drawing.
Also affects symbols produced by {\tt plpoin}.}  This routine has no effect
unless the extended character set is loaded (see {\tt plfontld}).

\argu{ {\tt font} (PLINT, input)}{Specifies the font:
\begin{itemize}
\item{1}: Normal font (simplest and fastest)
\item{2}: Roman font
\item{3}: Italic font
\item{4}: Script font
\end{itemize}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plfontld(set)}\label{plfontld}
\addcontentsline{toc}{subsection}{plfontld}

\descr{ Sets the character set to use for subsequent character drawing.
May be called before calling initializing PLPLOT.}

\argu{ {\tt set} (PLINT, input)}{Specifies the character set to load:
\begin{itemize}
\item{0}: Standard character set
\item{1}: Extended character set
\end{itemize}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plgfam(fam, num, bmax)}\label{plgfam}
\addcontentsline{toc}{subsection}{plgfam}

\descr{ Gets information about current family file, if familying is
enabled.  See Section \ref{sec:family} for more information.}

\argu{ {\tt fam} (PLINT *, output)}{Pointer to variable with the boolean
family flag value.   If nonzero, familying is enabled.}

\argu{ {\tt num} (PLINT *, output)}{Pointer to variable with the current 
family file number.}

\argu{ {\tt bmax} (PLINT *, output)}{Pointer to variable with the maximum
file size (in bytes) for a family file.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plgfile(file)}\label{plgfile}
\addcontentsline{toc}{subsection}{plgfile}

\descr{ Gets the current output file handle, if applicable. }

\argu{ {\tt file} (FILE *, output)}{File pointer to current output file.}

NOTE: cannot be called from Fortran.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plgfnam(fnam)}\label{plgfnam}
\addcontentsline{toc}{subsection}{plgfnam}

\descr{ Gets the current output file name, if applicable. }

\argu{ {\tt fnam} (char *, output)}{Pointer to file name string.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plgpage(xp, yp, xleng, yleng, xoff, yoff)}\label{plgpage}
\addcontentsline{toc}{subsection}{plgpage}

\descr{ Gets the current page configuration. }

\argu{ {\tt xp} (PLINT *, output)}{Pointer to number of pixels in x.}
\argu{ {\tt yp} (PLINT *; output)}{Pointer to number of pixels in y.}
\argu{ {\tt xleng} (PLINT *, output)}{Pointer to x page length value.}
\argu{ {\tt yleng} (PLINT *, output)}{Pointer to y page length value.}
\argu{ {\tt xoff} (PLINT *, output)}{Pointer to x page offset.}
\argu{ {\tt yoff} (PLINT *, output)}{Pointer to y page offset.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plgra()}\label{plgra}
\addcontentsline{toc}{subsection}{plgra}

\descr{ Sets an interactive device to graphics mode, used in conjunction
with {\tt pltext} to allow graphics and text to be interspersed.  On a
device which supports separate text and graphics windows, this command
causes control to be switched to the graphics window.  If already in
graphics mode, this command is ignored.  It is also ignored on devices which
only support a single window or use a different method for shifting focus.  
See also {\tt pltext}.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plgspa(xmin, xmax, ymin, ymax)}\label{plgspa}
\addcontentsline{toc}{subsection}{plgspa}

\descr{ Gets the size of the current subpage in millimetres measured from
the bottom left hand corner of the output device page or screen.  Can be
used in conjunction with {\tt plsvpa} for setting the size of a viewport in
absolute coordinates (millimetres).}

\argu{ {\tt xmin} (PLFLT *, output)}{Pointer to variable with position of
left hand edge of subpage in millimetres.}

\argu{ {\tt xmax} (PLFLT *, output)}{Pointer to variable with position of
right hand edge of subpage in millimetres.}

\argu{ {\tt ymin} (PLFLT *, output)}{Pointer to variable with position of
bottom edge of subpage in millimetres.}

\argu{ {\tt ymax} (PLFLT *, output)}{Pointer to variable with position of
top edge of subpage in millimetres.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plgstrm(strm)}\label{plgstrm}
\addcontentsline{toc}{subsection}{plgstrm}

\descr{ Gets the number of the current output stream. See also {\tt
plsstrm}.}

\argu{ {\tt strm} (PLINT *, output)}{Pointer to current stream value.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plgxax(digmax, digits)}\label{plgxax}
\addcontentsline{toc}{subsection}{plgxax}

\descr{ Returns current values of the {\tt digmax} and {\tt digits} flags
for the x axis.  {\tt digits} is updated after the plot is drawn, so so this
routine should only be called {\em after\/} the call to {\tt plbox} 
(or {\tt plbox3}) is complete.  See section \ref{annotate} for more
information.}

\argu{ {\tt digmax} (PLINT *, output)}{Pointer to variable with the maximum
number of digits.  If nonzero, the printed label will be switched to a
floating point representation when the number of digits exceeds {\tt
digmax}.}

\argu{ {\tt digits} (PLINT *, output)}{Pointer to variable with the actual
number of digits for the numeric labels (x axis) from the last plot.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plgyax(digmax, digits)}\label{plgyax}
\addcontentsline{toc}{subsection}{plgyax}

\descr{ Identical to {\tt plgxax}, except that arguments are flags for 
y axis.  See the description of {\tt plgxax} for more detail.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plgzax(digmax, digits)}\label{plgzax}
\addcontentsline{toc}{subsection}{plgzax}

\descr{ Identical to {\tt plgxax}, except that arguments are flags for 
z axis.  See the description of {\tt plgxax} for more detail.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plhist(n, data, datmin, datmax, nbin, oldwin)}\label{plhist}
\addcontentsline{toc}{subsection}{plhist}

\descr{ Plots a histogram from {\tt n} data points stored in the array {\tt
data}.  This routine bins the data into {\tt nbin} bins equally spaced
between {\tt datmin} and {\tt datmax}, and calls {\tt plbin} to draw the
resulting histogram.  Parameter {\tt oldwin} allows the histogram either to
be plotted in an existing window or causes {\tt plhist} to call {\tt plenv}
with suitable limits before plotting the histogram.}

\argu{ {\tt n} (PLINT, input)}{Number of data points.}

\argu{ {\tt data} (PLFLT *, input)}{Pointer to array with values of the {\tt
n} data points.}

\argu{ {\tt datmin} (PLFLT, input)}{Left-hand edge of lowest-valued bin.}

\argu{ {\tt datmax} (PLFLT, input)}{Right-hand edge of highest-valued bin.}

\argu{ {\tt nbin} (PLINT, input)}{Number of (equal-sized) bins into which
to divide the interval {\tt xmin} to {\tt xmax}.}

\argu{ {\tt oldwin} (PLINT, input)}{If one, the histogram is plotted in the
currently-defined window, and if zero, {\tt plenv} is called automatically
before plotting.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{pljoin(x1, y1, x2, y2)}\label{pljoin}
\addcontentsline{toc}{subsection}{pljoin}

\descr{ Joins the point {\tt (x1, y1)} to {\tt (x2, y2)}.}

\argu{ {\tt x1} (PLFLT, input)}{x~coordinate of first point.}

\argu{ {\tt y1} (PLFLT, input)}{y~coordinate of first point.}

\argu{ {\tt x2} (PLFLT, input)}{x~coordinate of second point.}

\argu{ {\tt y2} (PLFLT, input)}{y~coordinate of second point.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{pllab(xlabel, ylabel, tlabel)}\label{pllab}
\addcontentsline{toc}{subsection}{pllab}

\descr{ Routine for writing simple labels. Use {\tt plmtex} for more complex
labels.}

\argu{ {\tt xlabel} (char *, input)}{Label for horizontal axis.}

\argu{ {\tt ylabel} (char *, input)}{Label for vertical axis.}

\argu{ {\tt tlabel} (char *, input)}{Title of graph.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plline(n, x, y)}\label{plline}
\addcontentsline{toc}{subsection}{plline}

\descr{ Draws {\tt n-1} line segments joining points {\tt (x[i], y[i])}.}

\argu{ {\tt n} (PLINT, input)}{Number of points to join.}

\argu{ {\tt x} (PLFLT *, input)}{Pointer to array with x~coordinates of
points.}

\argu{ {\tt y} (PLFLT *, input)}{Pointer to array with y~coordinates of
points.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{pllsty(n)}\label{pllsty}
\addcontentsline{toc}{subsection}{pllsty}

\descr{ This sets the line style according to one of eight predefined patterns
(also see {\tt plstyl}).}

\argu{ {\tt n} (PLINT, input)}{Integer value between 1 and 8.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bnameCF{plmesh(x, y, z, nx, ny, opt)}{\qquad(C)}
	{plmesh(x, y, z, nx, ny, opt, mx)}{(Fortran)}
\label{plmesh}
\addcontentsline{toc}{subsection}{plmesh}

\descr{ Plots a surface mesh within the environment set up by {\tt plw3d}.
The surface is defined by the two-dimensional array {\tt z[][]}, the point
{\tt z[i][j]} being the value of the function at {\tt (x[i], y[j])}.  Note
that the points in arrays {\tt x} and {\tt y} do not need to be equally
spaced, but must be stored in ascending order.  The parameter {\tt opt}
controls the way in which the surface is displayed.  See Section
\ref{threed} on page \pageref{threed} for further details.}

\argu{ {\tt x} (PLFLT *, input)}{Pointer to set of x~coordinate values at
which the function is evaluated.}

\argu{ {\tt y} (PLFLT *, input)}{Pointer to set of y~coordinate values at
which the function is evaluated.}

\argu{ {\tt z} (PLFLT **, input)}{Pointer to a vectored two-dimensional
array with set of function values.}

\argu{ {\tt nx} (PLINT, input)}{Number of {\tt x}~values at which function is
evaluated.}

\argu{ {\tt ny} (PLINT, input)}{Number of {\tt y}~values at which function is
evaluated.}

\argu{ {\tt opt} (PLINT, input)}{Determines the way in which the surface
is represented:
\begin{itemize}
\item{1}: Lines are drawn showing {\tt z} as a function of {\tt x} for each value
  of {\tt y[j]}.
\item{2}: Lines are drawn showing {\tt z} as a function of {\tt y} for each value
  of {\tt x[i]}.
\item{3}: Network of lines is drawn connecting points at which function is
  defined.
\end{itemize}
}

\argu{ {\tt mx} (PLINT, input)}{Length of array in x direction, for plotting
subarrays (Fortran only).}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plmtex(side, disp, pos, just, text)}\label{plmtex}
\addcontentsline{toc}{subsection}{plmtex}

\descr{ Writes text at a specified position relative to the viewport
boundaries.  Text may be written inside or outside the viewport, but is
clipped at the subpage boundaries.  The reference point of a string lies
along a line passing through the string at half the height of a capital
letter.  The position of the reference point along this line is determined
by {\tt just}, and the position of the reference point relative to the
viewport is set by {\tt disp} and {\tt pos}.}

\argu{ {\tt side} (char *, input)}{Specifies the side of the viewport along
which the text is to be written. The string must be one of:
\begin{itemize}
\item{b}: Bottom of viewport.
\item{l}: Left of viewport, text written parallel to edge.
\item{lv}: Left of viewport, text written at right angles to edge.
\item{r}: Right of viewport, text written parallel to edge.
\item{rv}: Right of viewport, text written at right angles to edge.
\item{t}: Top of viewport.
\end{itemize}
}

\argu{ {\tt disp} (PLFLT, input)}{Position of the reference point of string, 
measured outwards from the specified viewport edge in units of the current
character height.  Use negative {\tt disp} to write within the viewport.}

\argu{ {\tt pos} (PLFLT, input)}{Position of the reference point of string
along the specified edge, expressed as a fraction of the length of the edge.}

\argu{ {\tt just} (PLFLT, input)}{Specifies the position of the string
relative to its reference point.  If {\tt just=0}, the reference point is at
the left and if {\tt just=1}, it is at the right of the string.  Other
values of {\tt just} give intermediate justifications.}

\argu{ {\tt text} (char *, input)}{The string to be written out.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bnameCF{plot3d(x, y, z, nx, ny, opt, side)}{\qquad(C)}
	{plot3d(x, y, z, nx, ny, opt, side, mx)}{(Fortran)}
\label{plot3d}
\addcontentsline{toc}{subsection}{plot3d}

\descr{ Plots a three dimensional surface plot within the environment set up
by {\tt plw3d}.  The surface is defined by the two-dimensional array {\tt
z[][]}, the point {\tt z[i][j]} being the value of the function at {\tt
(x[i], y[j])}.  Note that the points in arrays {\tt x} and {\tt y} do not
need to be equally spaced, but must be stored in ascending order.  The
parameter {\tt opt} controls the way in which the surface is displayed.  See
Section \ref{threed} on page \pageref{threed} for further details.}

\argu{ {\tt x} (PLFLT *, input)}{Pointer to set of x~coordinate values at
which the function is evaluated.}

\argu{ {\tt y} (PLFLT *, input)}{Pointer to set of y~coordinate values at
which the function is evaluated.}

\argu{ {\tt z} (PLFLT **, input)}{Pointer to a vectored two-dimensional
array with set of function values.}

\argu{ {\tt nx} (PLINT, input)}{Number of {\tt x}~values at which function
is evaluated.}

\argu{ {\tt ny} (PLINT, input)}{Number of {\tt y}~values at which function
is evaluated.}

\argu{ {\tt opt} (PLINT, input)}{Determines the way in which the surface
is represented:
\begin{itemize}
\item{1}: Lines are drawn showing {\tt z} as a function of {\tt x} for each value
  of {\tt y[j]}.
\item{2}: Lines are drawn showing {\tt z} as a function of {\tt y} for each value
  of {\tt x[i]}.
\item{3}: Network of lines is drawn connecting points at which function is
  defined.
\end{itemize}
}

\argu{ {\tt side} (PLINT, input)}{Flag to indicate whether or not ``sides''
should be draw on the figure.  If {\tt side=0} no sides are drawn, otherwise
the sides are drawn.}

\argu{ {\tt mx} (PLINT, input)}{Length of array in x direction, for plotting
subarrays (Fortran only).}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plpage()}\label{plpage}
\addcontentsline{toc}{subsection}{plpage}

\descr{ Begins a new page.  For a file driver, the output file is opened if
necessary.  Advancing the page via {\tt plclr} and {\tt plpage} is useful
when a page break is desired at a particular point when plotting to
subpages.  Another use for {\tt plclr} and {\tt plpage} is when plotting
pages to different files, since you can manually set the file name (or file
handle) by calling {\tt plsfnam} or {\tt plsfile} after the call to {\tt
plclr} (in fact some drivers may only support a single page per file, making
this a necessity).  One way to handle this case automatically is to page
advance via {\tt pladv}, but enable familying (see {\tt plsfam}) with a
small byte per file limit so that a new family member file will be created
on each page break.  

Except for one of these circumstances, it is best to advance the page or
subpage simply by the call {\tt pladv(0)}.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plpat(nlin, inc, del)}\label{plpat}
\addcontentsline{toc}{subsection}{plpat}

\descr{ Sets the area fill pattern.  The pattern consists of 1 or 2 sets of
parallel lines with specified inclinations and spacings.  The arguments to
this routine are the number of sets to use (1 or 2) followed by two pointers
to integer arrays (of 1 or 2 elements) specifying the inclinations in tenths
of a degree and the spacing in micrometers.  (also see {\tt plpsty})}

\argu{{\tt nlin} (PLINT, input)}{Number of sets of lines making up the
pattern, either 1 or 2.}

\argu{{\tt inc} (PLINT *, input)}{Pointer to array with {\tt nlin} elements.
Specifies the line inclination in tenths of a degree.  (Should be between
-900 and 900).}

\argu{{\tt del} (PLINT *, input)}{Pointer to array with {\tt nlin} elements.
Specify the spacing in micrometers between the lines making up the pattern.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plpoin(n, x, y, code)}\label{plpoin}
\addcontentsline{toc}{subsection}{plpoin}

\descr{ Marks out a set of {\tt n} points at positions {\tt (x(i), y(i))}, 
using the symbol defined by {\tt code}.  If {\tt code} is between 32 and
127, the symbol is simply the printable ASCII character in the default
font.}

\argu{ {\tt n} (PLINT, input)}{Number of points to be marked.}

\argu{ {\tt x} (PLFLT *, input)}{Pointer to array with set of x~coordinate
values for the points.}

\argu{ {\tt y} (PLFLT *, input)}{Pointer to array with set of y~coordinate
values for the points.}

\argu{ {\tt code} (PLINT, input)}{Code number for the symbol to be plotted.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plprec(set, prec)}\label{plprec}
\addcontentsline{toc}{subsection}{plprec}

\descr{ Sets the number of places after the decimal point in numeric labels.}

\argu{ {\tt set} (PLINT, input)}{ If {\tt set} is equal to 0 then PLPLOT
automatically determines the number of places to use after the decimal point
in numeric labels (like those used to label axes).  If {\tt set} is 1 then
{\tt prec} sets the number of places.}

\argu{ {\tt prec} (PLINT, input)}{The number of characters to draw after the
decimal point in numeric labels.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plpsty(n)}\label{plpsty}
\addcontentsline{toc}{subsection}{plpsty}

\descr{ Select one of eight predefined area fill patterns to use (also see
{\tt plpat}).}

\argu{ {\tt n} (PLINT *, input)}{The desired pattern.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plptex(x, y, dx, dy, just, text)}\label{plptex}
\addcontentsline{toc}{subsection}{plptex}

\descr{ Writes text at a specified position and inclination within the
viewport.  Text is clipped at the viewport boundaries.  The reference point
of a string lies along a line passing through the string at half the height
of a capital letter.  The position of the reference point along this line is
determined by {\tt just}, the reference point is placed at world coordinates
{\tt (x, y)} within the viewport.  The inclination of the string is specified
in terms of differences of world coordinates making it easy to write text
parallel to a line in a graph.}

\argu{ {\tt x} (PLFLT, input)}{x coordinate of reference point of string.}

\argu{ {\tt y} (PLFLT, input)}{y coordinate of reference point of string.}

\argu{ {\tt dx} (PLFLT, input)}{Together with {\tt dy}, this specifies the
inclination of the string.  The baseline of the string is parallel to a line
joining {\tt (x, y)} to {\tt (x+dx, y+dy)}.}

\argu{ {\tt dy} (PLFLT, input)}{Together with {\tt dx}, this specifies the
inclination of the string.}

\argu{ {\tt just} (PLFLT, input)}{Specifies the position of the string
relative to its reference point.  If {\tt just=0}, the reference point is at
the left and if {\tt just=1}, it is at the right of the string.  Other
values of {\tt just} give intermediate justifications.}

\argu{ {\tt text} (char *, input)}{The string to be written out.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plsasp(aspect)}\label{plsasp}
\addcontentsline{toc}{subsection}{plsasp}

\descr{ This sets up the aspect ratio for all subsequent pages, if
supported by the driver.  This routine, if used, must be called before
initializing PLPLOT.  This routine at present does not always give good
results; the user is encouraged to instead plot to viewports of definite
aspect ratios via the {\tt plvasp} or {\tt plvpas} routines.  Note that
{\tt plrender} is capable of scaled aspect ratio plots to any device
whether that device supports scaling or not.}

\argu{ {\tt aspect} (PLFLT, input)}{Ratio of the page length in y to the
page length in x.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plschr(def, scale)}\label{plschr}
\addcontentsline{toc}{subsection}{plschr}

\descr{ This sets up the size of all subsequent characters drawn.  The
actual height of a character is the product of the default character size
and a scaling factor.}

\argu{ {\tt def} (PLFLT, input)}{The default height of a character in
millimetres, should be set to zero if the default height is to remain
unchanged.}

\argu{ {\tt scale} (PLFLT, input)}{Scale factor to be applied to default to
get actual character height.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plsfam(fam, num, bmax)}\label{plsfam}
\addcontentsline{toc}{subsection}{plsfam}

\descr{ Sets variables dealing with output file familying.  Does nothing if
familying not supported by the driver.  This routine, if used, must be
called before initializing PLPLOT.  See Section \ref{sec:family} for more
information.}

\argu{ {\tt fam} (PLINT, input)}{Family flag (boolean).  If nonzero, 
familying is enabled.}

\argu{ {\tt num} (PLINT, input)}{Current family file number.}

\argu{ {\tt bmax} (PLINT, input)}{Maximum file size (in bytes) 
for a family file.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plsfile(file)}\label{plsfile}
\addcontentsline{toc}{subsection}{plsfile}

\descr{ Sets the current output file handle, if applicable.  If the file has
has not been previously opened and is required by the driver, the user will
be prompted for the file name.  This routine, if used, must be called before
initializing PLPLOT.}

\argu{ {\tt file} (FILE *, output)}{File pointer.}

NOTE: cannot be called from Fortran.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plsfnam(fnam)}\label{plsfnam}
\addcontentsline{toc}{subsection}{plsfnam}

\descr{ Sets the current output file name, if applicable.  If the file name
has not been specified and is required by the driver, the user will be
prompted for it.  If using the X-windows output driver, this sets the
display name.  This routine, if used, must be called before initializing
PLPLOT.}

\argu{ {\tt fnam} (char *, output)}{Pointer to file name string.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plsmaj(def, scale)}\label{plsmaj}
\addcontentsline{toc}{subsection}{plsmaj}

\descr{ This sets up the length of the major ticks.  The actual length is
the product of the default length and a scaling factor as for character
height.}

\argu{ {\tt def} (PLFLT, input)}{The default length of a major tick in
millimetres, should be set to zero if the default length is to remain
unchanged.}

\argu{ {\tt scale} (PLFLT, input)}{Scale factor to be applied to default to
get actual tick length.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plsmin(def, scale)}\label{plsmin}
\addcontentsline{toc}{subsection}{plsmin}

\descr{ This sets up the length of the minor ticks and the length of the
terminals on error bars.  The actual length is the product of the default
length and a scaling factor as for character height.}

\argu{ {\tt def} (PLFLT, input)}{The default length of a minor tick in
millimetres, should be set to zero if the default length is to remain
unchanged.}

\argu{ {\tt scale} (PLFLT, input)}{Scale factor to be applied to default to
get actual tick length.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plsori(ori)}\label{plsori}
\addcontentsline{toc}{subsection}{plsori}

\descr{ Sets the current orientation.  If {\tt ori} is equal to zero
(default) then landscape is used (x axis is parallel to the longest edge of
the page), otherwise portrait is used.  This option is not supported by all
output drivers (in particular, most interactive screen drivers ignore the
orientation).  This routine, if used, must be called before initializing
PLPLOT.}

\argu{ {\tt ori} (PLINT, output)}{Orientation value.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plspage(xp, yp, xleng, yleng, xoff, yoff)}\label{plspage}
\addcontentsline{toc}{subsection}{plspage}

\descr{ Sets the page configuration (optional).  Not all parameters
recognized by all drivers.  The X-window driver uses the length and offset
parameters to determine the window size and location.  This routine, if
used, must be called before initializing PLPLOT.}

\argu{ {\tt xp} (PLINT *, output)}{ Number of pixels, x.}
\argu{ {\tt yp} (PLINT *; output)}{ Number of pixels, y.}
\argu{ {\tt xleng} (PLINT *, output)}{ Page length, x.}
\argu{ {\tt yleng} (PLINT *, output)}{ Page length, y.}
\argu{ {\tt xoff} (PLINT *, output)}{ Page offset, x.}
\argu{ {\tt yoff} (PLINT *, output)}{ Page offset, y.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plsstrm(strm)}\label{plsstrm}
\addcontentsline{toc}{subsection}{plsstrm}

\descr{ Sets the number of the current output stream.  The stream number
defaults to 0 unless changed by this routine.  The first use of this routine
must be followed by a call initializing PLPLOT (e.g.~{\tt plstar}).}

\argu{ {\tt strm} (PLINT *, output)}{Pointer to current stream number.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plssym(def, scale)}\label{plssym}
\addcontentsline{toc}{subsection}{plssym}

\descr{ This sets up the size of all subsequent symbols drawn by {\tt
plpoin} and {\tt plsym}.  The actual height of a symbol is the product of
the default symbol size and a scaling factor as for the character height.  }

\argu{ {\tt def} (PLFLT, input)}{The default height of a symbol in
millimetres, should be set to zero if the default height is to remain
unchanged.}

\argu{ {\tt scale} (PLFLT, input)}{Scale factor to be applied to default to
get actual symbol height.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plstar(nx, ny)}\label{plstar}
\addcontentsline{toc}{subsection}{plstar}

\descr{ Initializing the plotting package.  The program prompts for the
device keyword or number of the desired output device.  Hitting a RETURN in
response to the prompt is the same as selecting the first device.  If only
one device is enabled when PLPLOT is installed, {\tt plstar} will issue no
prompt.  The output device is divided into {\tt nx} by {\tt ny} sub-pages,
each of which may be used independently.  The subroutine {\tt pladv} is used
to advance from one subpage to the next.}

\argu{ {\tt nx} (PLINT, input)}{Number of subpages to divide output page in
the horizontal direction.}

\argu{ {\tt ny} (PLINT, input)}{Number of subpages to divide output page in
the vertical direction.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plstart(device, nx, ny)}\label{plstart}
\addcontentsline{toc}{subsection}{plstart}

\descr{ Alternative to {\tt plstar} for initializing the plotting package.
The device name keyword for the desired output device must be supplied as an
argument.  The device keywords are the same as those printed out by {\tt
plstar}.  If the requested device is not available, or if the input string
is empty or begins with ``?'', the prompted startup of {\tt plstar} is used.
This routine also divides the output device into {\tt nx} by {\tt ny}
sub-pages, each of which may be used independently.  The subroutine {\tt
pladv} is used to advance from one subpage to the next.}

\argu{ {\tt device} (char *, input)}{Device name (keyword) of the required
output device.  If NULL or if the first character is a ``?'', the normal
(prompted) startup is used.}

\argu{ {\tt nx} (PLINT, input)}{Number of subpages to divide output page in
the horizontal direction.}

\argu{ {\tt ny} (PLINT, input)}{Number of subpages to divide output page in
the vertical direction.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plstyl(nels, mark, space)}\label{plstyl}
\addcontentsline{toc}{subsection}{plstyl}

\descr{ This sets up the line style for all lines subsequently drawn.  A
line consists of segments in which the pen is alternately down and up.  The
lengths of these segments are passed in the arrays {\tt mark} and {\tt
space} respectively.  The number of mark-space pairs is specified by {\tt
nels}.  In order to return the line style to the default continuous line, 
{\tt plstyl} should be called with {\tt nels=0}.(also see {\tt pllsty})}

\argu{ {\tt nels} (PLINT, input)}{The number of {\tt mark} and {\tt space}
elements in a line.  Thus a simple broken line can be obtained by setting
{\tt nels=1}.  A continuous line is specified by setting {\tt nels=0}.}

\argu{ {\tt mark} (PLINT *, input)} {Pointer to array with the lengths of
the segments during which the pen is down, measured in micrometres.}

\argu{ {\tt space} (PLINT *, input)} {Pointer to array with the lengths of
the segments during which the pen is up, measured in micrometres.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plsvpa(xmin, xmax, ymin, ymax)}\label{plsvpa}
\addcontentsline{toc}{subsection}{plsvpa}

\descr{ Alternate routine to {\tt plvpor} for setting up the viewport.  This
routine should be used only if the viewport is required to have a definite
size in millimetres.  The routine {\tt plgspa} is useful for finding out the
size of the current subpage.  }

\argu{ {\tt xmin} (PLFLT, input)}{The distance of the left-hand edge of the
viewport from the left-hand edge of the subpage in millimetres.}

\argu{ {\tt xmax} (PLFLT, input)}{The distance of the right-hand edge of the
viewport from the left-hand edge of the subpage in millimetres.}

\argu{ {\tt ymin} (PLFLT, input)}{The distance of the bottom edge of the
viewport from the bottom edge of the subpage in millimetres.}

\argu{ {\tt ymax} (PLFLT, input)}{The distance of the top edge of the
viewport from the top edge of the subpage in millimetres.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plsxax(digmax, digits)}\label{plsxax}
\addcontentsline{toc}{subsection}{plsxax}

\descr{ Returns current values of the {\tt digmax} and {\tt digits} flags
for the x axis.  {\tt digits} is updated after the plot is drawn, so so this
routine should only be called {\em after\/} the call to {\tt plbox} 
(or {\tt plbox3}) is complete.  See section \ref{annotate} for more
information.}

\argu{ {\tt digmax} (PLINT, output)}{Variable to set the maximum
number of digits.  If nonzero, the printed label will be switched to a
floating point representation when the number of digits exceeds {\tt
digmax}.}

\argu{ {\tt digits} (PLINT, input)}{Field digits value.  Currently, changing
its value here has no effect since it is set only by {\tt plbox} or {\tt
plbox3}.  However, the user may obtain its value after a call to {\tt plbox}
by calling {\tt plgxax}.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plsyax(digmax, digits)}\label{plsyax}
\addcontentsline{toc}{subsection}{plsyax}

\descr{ Identical to {\tt plsxax}, except that arguments are flags for 
y axis.  See the description of {\tt plsxax} for more detail.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plsym(n, x, y, code)}\label{plsym}
\addcontentsline{toc}{subsection}{plsym}

\descr{ Marks out a set of {\tt n} points at positions {\tt (x[i], y[i])}, 
using the symbol defined by {\tt code}.  The code is interpreted as an index
in the Hershey font tables.}

\argu{ {\tt n} (PLINT, input)}{Number of points to be marked.}

\argu{ {\tt x} (PLFLT *, input)}{Pointer to array with set of x~coordinate
values for the points.}

\argu{ {\tt y} (PLFLT *, input)}{Pointer to array with set of y~coordinate
values for the points.}

\argu{ {\tt code} (PLINT, input)}{Code number for the symbol to be plotted.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plszax(digmax, digits)}\label{plszax}
\addcontentsline{toc}{subsection}{plszax}

\descr{ Identical to {\tt plsxax}, except that arguments are flags for 
z axis.  See the description of {\tt plsxax} for more detail.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{pltext()}\label{pltext}
\addcontentsline{toc}{subsection}{pltext}

\descr{ Sets an interactive device to text mode, used in conjunction with
{\tt plgra} to allow graphics and text to be interspersed.  On a device
which supports separate text and graphics windows, this command causes
control to be switched to the text window.  This can be useful for printing
diagnostic messages or getting user input, which would otherwise interfere
with the plots.  The user {\em must\/} switch back to the graphics window
before issuing plot commands, as the text (or console) device will probably
become quite confused otherwise.  If already in text mode, this command is
ignored.  It is also ignored on devices which only support a single window
or use a different method for shifting focus.  See also {\tt plgra}.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plvasp(aspect)}\label{plvasp}
\addcontentsline{toc}{subsection}{plvasp}

\descr{ Sets the viewport so that the ratio of the length of the y axis to
that of the x axis is equal to {\tt aspect}.}

\argu{ {\tt aspect} (PLFLT, input)}{Ratio of length of y axis to length of x
axis.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plvpas(xmin, xmax, ymin, ymax, aspect)}\label{plvpas}
\addcontentsline{toc}{subsection}{plvpas}

\descr{ Device-independent routine for setting up the viewport.  The
viewport is chosen to be the largest with the given aspect ratio that fits
within the specified region (in terms of normalized subpage coordinates).
This routine is functionally equivalent to {\tt plvpor} when a ``natural''
aspect ratio (0.0) is chosen.  Unlike {\tt plvasp}, this routine reserves
no extra space at the edges for labels.}

\argu{ {\tt xmin} (PLFLT, input)}{The normalized subpage coordinate of the
left-hand edge of the viewport.}

\argu{ {\tt xmax} (PLFLT, input)}{The normalized subpage coordinate of the
right-hand edge of the viewport.}

\argu{ {\tt ymin} (PLFLT, input)}{The normalized subpage coordinate of the
bottom edge of the viewport.}

\argu{ {\tt ymax} (PLFLT, input)}{The normalized subpage coordinate of the
top edge of the viewport.}

\argu{ {\tt aspect} (PLFLT, input)}{Ratio of length of y axis to length of x
axis.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plvpor(xmin, xmax, ymin, ymax)}\label{plvpor}
\addcontentsline{toc}{subsection}{plvpor}

\descr{ Device-independent routine for setting up the viewport.  This
defines the viewport in terms of normalized subpage coordinates which run
from 0.0 to 1.0 (left to right and bottom to top) along each edge of the
current subpage.  Use the alternate routine {\tt plsvpa} in order to create
a viewport of a definite size.}

\argu{ {\tt xmin} (PLFLT, input)}{The normalized subpage coordinate of the
left-hand edge of the viewport.}

\argu{ {\tt xmax} (PLFLT, input)}{The normalized subpage coordinate of the
right-hand edge of the viewport.}

\argu{ {\tt ymin} (PLFLT, input)}{The normalized subpage coordinate of the
bottom edge of the viewport.}

\argu{ {\tt ymax} (PLFLT, input)}{The normalized subpage coordinate of the
top edge of the viewport.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plvsta()}\label{plvsta}
\addcontentsline{toc}{subsection}{plvsta}

\descr{ Sets up a standard viewport, leaving a left-hand margin of seven
character heights, and four character heights around the other three sides.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plw3d(basex, basey, height, xmin, xmax, ymin, ymax, zmin, zmax, alt, az)}\label{plw3d}
\addcontentsline{toc}{subsection}{plw3d}

\descr{ Sets up a window for a three-dimensional surface plot within the
currently defined two-dimensional window.  The enclosing box for the surface
plot defined by {\tt xmin}, {\tt xmax}, {\tt ymin}, {\tt ymax}, {\tt zmin}
and {\tt zmax} in user-coordinate space is mapped into a box of world
coordinate size {\tt basex} by {\tt basey} by {\tt height} so that {\tt
xmin} maps to {\tt -basex/2}, {\tt xmax} maps to {\tt basex/2}, {\tt ymin}
maps to {\tt -basey/2}, {\tt ymax} maps to {\tt basey/2}, {\tt zmin} maps to
{\tt 0} and {\tt zmax} maps to {\tt height}.  The resulting world-coordinate
box is then viewed by an observer at altitude {\tt alt} and azimuth {\tt
az}.  This routine must be called before {\tt plbox3} or {\tt plot3d}.  See
Section \ref{threed} on page \pageref{threed} for a more complete
description of three-dimensional plotting.}

\argu{ {\tt basex} (PLFLT, input)}{The x~coordinate size of the
world-coordinate box.}

\argu{ {\tt basey} (PLFLT, input)}{The y~coordinate size of the
world-coordinate box.}

\argu{ {\tt height} (PLFLT, input)}{The z~coordinate size of the
world-coordinate box.}

\argu{ {\tt xmin} (PLFLT, input)}{The minimum user x~coordinate value.}

\argu{ {\tt xmax} (PLFLT, input)}{The maximum user x~coordinate value.}

\argu{ {\tt ymin} (PLFLT, input)}{The minimum user y~coordinate value.}

\argu{ {\tt ymax} (PLFLT, input)}{The maximum user y~coordinate value.}

\argu{ {\tt zmin} (PLFLT, input)}{The minimum user z~coordinate value.}

\argu{ {\tt zmax} (PLFLT, input)}{The maximum user z~coordinate value.}

\argu{ {\tt alt} (PLFLT, input)}{The viewing altitude in degrees above the
xy~plane.}

\argu{ {\tt az} (PLFLT, input)}{The viewing azimuth in degrees.  When {\tt
az=0}, the observer is looking face onto the zx~plane, and as {\tt az} is
increased, the observer moves clockwise around the box when viewed from
above the xy~plane.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plwid(width)}\label{plwid}
\addcontentsline{toc}{subsection}{plwid}

\descr{ Sets the pen width.}

\argu{ {\tt width} (PLINT, input)}{The desired pen width. The pen width
must be between 1 and a device dependent maximum value.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bname{plwind(xmin, xmax, ymin, ymax)}\label{plwind}
\addcontentsline{toc}{subsection}{plwind}

\descr{ Sets up the world coordinates of the edges of the viewport.}

\argu{ {\tt xmin} (PLFLT, input)}{The world x~coordinate of the
left-hand edge of the viewport.}

\argu{ {\tt xmax} (PLFLT, input)}{The world x~coordinate of the
right-hand edge of the viewport.}

\argu{ {\tt ymin} (PLFLT, input)}{The world y~coordinate of the
bottom edge of the viewport.}

\argu{ {\tt ymax} (PLFLT, input)}{The world y~coordinate of the
top edge of the viewport.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
