\c cplus.tex                     -*-LaTeX-*-
\c Geoffrey Furnish
\c 11 October 1994
\c
\c Describe the C++ wrapper for PLplot, and plans related to this.
\c
\c $Id$
\c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\node C++ Interface, Tcl Interface, API,  Top
\chapter{A C++ Interface for PLplot}

\c This first appeared as a posting to the PLplot mailing list, by:
\c                      Geoffrey Furnish
\c                        8 June 1995

PLplot has long had C and Fortran bindings, presenting a fairly
conventional API to the applications programmer.  Recently (1994
onwards) PLplot has been growing interfaces (language bindings) to a
variety of other languages.  In this chapter we discuss the PLplot C++
support provided in the PLplot distribution.  Of course many other
approaches are possible, perhaps even in use by PLplot users around
the world.  The purpose of this chapter then is to explain the
rationale and intended usage for the bundled C++ language support.

\begin{menu}
* C++ Motivation::	What we would want from a C++ language binding.
* C++ Design::		Design of the PLplot C++ language binding.
* C++ Specialization::	How to use derivation to improve the interface.
* C++ Status::		Where things stand now.
\end{menu}

\node C++ Motivation, C++ Design, C++ Interface, C++ Interface
\section{Motivation for the C++ interface}
\cindex{Why C++?}

PLplot has a fairly complex C API.  There are lots of functions, and
several facilities have multiple entry points with similar names but
different argument lists.  (Think contouring, shading).  Often these
differing argument lists are to accomodate a variety of data storage
paradigms, one of which you are expected to be using!

Especially in the case of the 2-d API's for contouring and shading,
sophisticated C++ users may feel a special sense of exasperation with
the data layout prescriptions, since they are extremely primitive,
pointer rich, and prone to a wide class of memory leaks and other
sorts of programming errors.  Many C++ users know good and well that
better ways exist (templated matrix classes, etc), but historically
have not been able to use these more sophisticated techniques if the
contained data ever needed to get plotted.

Besides the 2-d API functions, there is also the multiple output
stream capability of PLplot.  Anyone who knows C++ well, and who has
used multple output streams in PLplot, has probably noticed striking
similarities between the PLplot \code{PLStream} pointer and the C++ 
\code{this} pointer.  Although multiple output streams have not been 
widely used in PLplot applications in the past, the availability of
the plframe Tk widget, and the extended wish concept, is making it
much more attractive to use multiple output streams.

Unfortunately, if you do write a Tk extended wish application, and
endow your interface with multiple plframes, the event driven
character of X applications makes it difficult to ensure that PLplot
output shows up in the right plframe window.  If a plot is generated
to one plframe, the PLplot \code{PLStream} pointer is directed to that
stream.  If a user then pushes a Tk button which should generate a
plot to a different plframe, the plot goes to the old plframe instead!
Schemes for controlling this can be imagined, but the logic can be
complex, especially in the face of the ability to /also/ make plots to
the same plframe from either Tcl or C++.

Beyond this, the C API is downright "ugly" for a significant number of
the functions, particularly those which return values by accepting
pointers to variables in their argument lists, and then changing them
in that way.  Sophisticated C++ users generally take considerable
pride in bannishing the offensive bare pointer from their code, and
consider it disgusting to have to insert &'s just in order to make a
call to an API function.

In order to address these issues (and more), I have begun constructing
a C++ interface to PLplot.  The purpose of this missive is to describe
its architecture and usage.

\node C++ Design, C++ Specialization, C++ Motivation, C++ Interface
\section{Design of the PLplot C++ Interface}

\subsection{Stream/object identity}

A C++ class named \code{plstream} has been introduced.  It's central
purpose is provide a specific, object based encapsulation of the
concept of a PLplot output stream.  Any output produced using a
\code{plstream} object, will go to the PLplot output stream associated with
that object, regardless of what stream may have been active before.  

In order to write a multiple output stream PLplot application, a C++
program can declare \code{plstream} objects, and invoke drawing methods on
those objects, without regard to ordering considerations or other
coherency considerations.  Although this has obvious simplification
benefit even for simple programs, the full benefit is most easily
appreciated in the context of Tk extended wish applications in which a
\code{plstream} can be associated with each plframe.

\subsection{Namespace management}

The PLplot C API is composed of a set of drawing functions, all
prefixed with "pl", in an effort to prevent namespace collision.
However, the prefix "pl" is gratuitous, and in particular is
unnecessary in a C++ context.  The \code{plstream} class mirrors most
of the PLplot C API, but does so by dropping the "pl" prefix.  The
\code{plstream} class thus serves to collect the PLplot drawing
functions into a scope in which collisions with other similarly named
functions is not a concern.  So, where a C programmer might write:
\begin{example}
	plsstrm( 1 );
	plenv( ... );
	plline( ... );
\end{example}
The C++ programmer can write:
\begin{example}
	plstream p( ... );
	p.env( ... );
	p.line( ... );
\end{example}

Is that an important benefit?  The utility varies with the number of
output streams in use in the program.

plmkstrm() is replaced by object declaration.  plsstrm() is replaced by
method invocation on the desired output stream object.  plgstrm() is
rendered irrelevant.

The skeptic may say, "But you have to type the same number of
characters!  You've replaced 'pl' with 'p.', except it could be worse
for a longer object name."  True.  BUT, in this new scheme, most plots
will not be generated by invoking methods on a specific stream object,
but rather by deriving from \code{plstream}, and invoking methods of
"this" object.  See the section on derivation below.

\subsection{Abstraction of Data Layout}

The \code{plstream} class will provide an abstract interface to the
2-d drawing functions.  Instead of forcing the C++ user to organize
data in one of a small set of generally braindead data layouts with
poor memory management properties, potentially forcing the C++ user to
not use a superior method, or to copy data computed in one layout
format to another for plotting (with consequent bug production), the
\code{plstream} 2-d plotting functions will accept an abstract layout
specification.  The only thing which is important to the 2-d drawing
functions is that the data be "indexable".  They should not care about
data layout.

Consequently, an abstract class, "Contourable_Data" is provided.  This
class provides a pure virtual method which accepts indexes, and is to
be made to produce a function value for the user's 2-d data field.  It
is of no concern to PLplot how the user does this.  Any mapping
between index and data which the user wishes to use, may be used.

This methodology allows the C++ user to compute data using whatever
storage mechanism he wants.  Then, by deriving a class from PLplot's
Contourable_Data abstract class, he can provide a mapping to his own
data layout.

Note that this does /not/ mean that the C++ user's internal data
layout must be derived from PLplot's Contourable_Data class.  Suupsoe
for example that the user data is stored in a C++ "matrix" class.
To make this data contourable, the user may define a class which
specializes the indexing concept of the PLplot Contourable_Data class
to his matrix class.  For example:
\begin{example}
class Matrix { ... };
class Contourable_Matrix : public Contourable_Data {
    Matrix& m;
  public:
    Contourable_Matrix( Matrix& _m ) : m(_m) {}
    PLFLT  operator()( int i, int j ) const { return m(i,j); }
};

plstream p( ... );
Matrix m;
// Code to fill m with data
Contourable_Matrix cm(m);
p.shade( cm, ... );
\end{example}

In this way the C++ user is completely freed from the tyranny of
moronic data layout constraints imposed by PLplot's C or Fortran API.

\subsection{Collapsing the API}

Use of astraction as in C) above will allow a single method in
\code{plstream} to perform the services of multiple functions in the C API.
In those cases where multiple functions were provided with different
data layout specifications, but similar functionality, these can all
be collapsed into one, through the use of the abstract inteface
technique described above.

Moreover, function name overloading can be used to simplify the
namespace for those cases where multiple functions were used to get
variations on a basic capability.  For example, a single name such as
contour or shade can be used for multiple methods taking different
argument sets, so that for example, one can make simple plots of
rectangular data sets, or more complex generalized coordinate
mappings.

\node C++ Specialization, C++ Status, C++ Design, C++ Interface
\section{Specializing the PLplot C++ Interface}

The \code{plstream} class is an ideal candidate for derivation.  By
inheriting from \code{plstream}, the user can construct a new class
which is automatically endowed with the ability to plot to a specific
PLplot output stream in a coherent manner without having to worry
about interplay with other \code{plstream} (or derived type) objects.
Moreover, new, higher level, plotting functionality can be constructed
to provide even more simplicity and ease of use than the PLplot API.

The PLplot maintainers (Geoff and Maurice) expect to introduce a class
plxstream in the future which provides superior support for
constructing graphics with multiple plots per page, easier
specification of plot adornments, etc.  This should significantly ease
one aspect of PLplot usage which we regard as being clumsy at this
time.

Beyond that, users may find it useful to derive from \code{plstream}
(or later plxstream whenever it finally makes its appearance) for the
purpose of making "application specific" output streams.  For example,
a C++ program will normally have a variety of objects which constitute
the fundamental entities in the code.  These could all be made to be
"atomically plotted" by providing suitable methods.  For example:
\begin{example}
class Cat { ... };
class Dog { ... };
class Bear { ... };
class Fish { ... };

class zoostream : public plstream {
  public:
    void plot( const Cat& c ) { ... }
    void plot( const Dog& d ) { ... }
    void plot( const Bear& b ) { ... }
    void plot( const Fish& f ) { ... }
};
\end{example}

Presumably the PLplot user community can think of even more
immaginative uses...  :-).

\node C++ Status, , C++ Specialization, C++ Interface
\section{Status of the C++ Interface}

The class \code{plstream} (and the other abstraction classes in
\file{plstream.h}) provided in PLplot 4.99j (alpha) are to be
considered as works in progress.  By the standards outlined above, the
work has barely begun.  At this time, \code{plstream} is mostly a one
to one mirror of the C API, which is to say, it is still far from the
goals of simplification and abstraction outlined above.  As such, it
can be expected to change radically over the course of time.  (We
don't quote schedules--how long have you been waiting for 5.0?  :-).

In any event, we would welcome improvement submissions along the lines
of those above, but we would strongly discourage people from using
\code{plstream} if they are expecting it to be rock solid.  It \emph{will} 
be changing, to become more like the design goals elucidated above.

So, if you like the ideas described above, and are willing to accept
the burden of "upgrading" your code as the class \code{plstream}
evolves, then feel free to use it.  Just don't whine when I fix some
of the methods to take references instead of pointers, when I
eliminate some of the redundant methods to use the collapsed form,
etc.

