
<chapter id="advanced">
  <title>Advanced Use of PLplot</title>
  
  <para>
    In this chapter, we describe more precisely how to control the position
    and scaling of a graph, how to alter the low-level line and character
    attributes, and how to use the functions in PLplot for drawing
    three-dimensional surface plots and contour plots.
  </para>
  
  <para>
    Still updating this chapter.
  </para>
  
  <sect1 id="concepts">
    <title>Basic PLplot Concepts</title> 

    <para> 
      When drawing a graph, the programmer usually wishes to specify
      the coordinates of the points to be plotted in terms of the values of
      the variables involved. These coordinates are called <emphasis>world
	coordinates</emphasis>, and may have any floating-point value
      representable by the computer. The <emphasis>window</emphasis> refers
      to the rectangular region of world-coordinate space which is to be
      graphed.  This window is mapped onto a rectangular region of the
      <emphasis>view surface</emphasis>, which can be a terminal screen or a
      sheet of paper in the output device (or a portion thereof, if subpages
      are being used).  This physical region onto which the window is mapped
      is called the <emphasis>viewport</emphasis>.  Before a graph can be
      drawn, the program must define both the window and the viewport by
      calling appropriate routines in PLplot.
    </para>
    
  </sect1>

  <sect1 id="output-device">
    <title>Specifying the Output Device</title>

    <para>
      The main initialization routine for PLplot is &plinit;, which sets up
      all internal data structures necessary for plotting and initializes
      the output device driver.  The output device can be a terminal, disk
      file, window system, pipe, or socket.  If the output device has not
      already been specified when &plinit; is called, a list of valid
      output devices is given and the user is prompted for a choice.  For
      example:
    </para>
    
    <para>
      <screen>
<prompt>%</prompt> <userinput>x01c</userinput>
	
Plotting Options:
 < 1> xwin       X-Window (Xlib)
 < 2> dp         Tcl-DP/TK Window
 < 3> tk         Tcl/TK Window
 < 4> xterm      Xterm Window
 < 5> tekt       Tektronix Terminal (4010)
 < 6> tek4107t   Tektronix Terminal (4105/4107)
 < 7> mskermit   MS-Kermit emulator
 < 8> versaterm  Versaterm vt100/tek emulator
 < 9> vlt        VLT vt100/tek emulator
 <10> plmeta     PLPLOT Native Meta-File
 <11> tekf       Tektronix File (4010)
 <12> tek4107f   Tektronix File (4105/4107)
 <13> ps         PostScript File (monochrome)
 <14> psc        PostScript File (color)
 <15> xfig       Xfig file
 <16> ljiip      LaserJet IIp/deskjet compressed graphics
 <17> ljii       LaserJet II Bitmap File (150 dpi)
 <18> null       Null device

Enter device number or keyword: <!--
   --></screen>
    </para>
    
    <para>
      Either the device number or a device keyword is accepted.  Specifying
      the device by keyword is preferable in aliases or scripts since the
      device number is dependent on the install procedure (the installer
      can choose which device drivers to include).  The device can be
      specified prior to the call to &plinit; by:

      <itemizedlist>
	<listitem>
	  <para>
	    A call to <function>plsdev</function>.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    The <literal>-dev</literal> <replaceable>device</replaceable>
	    command line argument, if the program's command line arguments
	    are being passed to the PLplot function
	    <function>plParseInternalOpts</function>.
	  </para>
	</listitem>
      </itemizedlist>
      
    </para>

    <para>
      Additional startup routines &plstar; and &plstart; are available but
      these are simply front-ends to &plinit;, and should be avoided.  It
      is preferable to call &plinit; directly, along with the appropriate
      setup calls, for the greater amount of control this provides (see the
      example programs for more info).
    </para>

    <para>
      Before &plinit; is called, you may modify the number of subpages the
      output device is divided into via a call to
      <function>plssub</function>.  Subpages are useful for placing several
      graphs on a page, but all subpages are constrained to be of the same
      size.  For greater flexibility, viewports can be used (see <xref
      linkend="viewports"> for more info on viewports).  The routine
	&pladv; is used to advance to a particular subpage or to the next
	subpage.  The screen is cleared (or a new piece of paper loaded) if a
	new subpage is requested when there are no subpages left on the
	current page.  When a page is divided into subpages, the default
	character, symbol and tick sizes are scaled inversely as the square
	root of the number of subpages in the vertical direction.  This is
	designed to improve readability of plot labels as the plot size
	shrinks.
    </para>

    <para>
      PLplot has the ability to write to multiple output streams.  An
      output stream corresponds to a single logical device to which one
      plots independent of all other streams.  The function &plsstrm; is
      used to switch between streams -- you may only write to one output
      stream at a time.  At present, an output stream is not limited by the
      type of device, however, it may not be wise to attempt opening two
      terminal devices.  An example usage for the creation of multiple
      streams is as follows:
    </para>

    <para>
      <programlisting>
#include "plplot.h"

main()
{
    int nx = 2, ny = 2;

    plssub(nx, ny);
    plsdev("xwin");
    plinit();

    <lineannotation>plots for stream 0</lineannotation>

    plsstrm(1);
    plssub(nx, ny);
    plsdev("plmeta");
    plsfnam("tst.plm");
    plinit();

    <lineannotation>plots for stream 1</lineannotation>

    plsstrm(0);

    <lineannotation>plots for stream 0</lineannotation><!--
   --></programlisting>
    </para>

    <para>
      and so on, for sending output simultaneously to an X-window and a
      metafile.  The default stream corresponds to stream number zero.  At
      present, the majority of output drivers can only be used by a single
      stream (exceptions include the metafile driver and X-window driver).
      Also see example program 14 (note: only the C version is available,
      although it can be done equally well from Fortran).
    </para>

    <para>
      At the end of a plotting program, it is important to close the
      plotting device by calling &plend;.  This flushes any internal
      buffers and frees any memory that may have been allocated, for all
      open output streams.  You may call &plend1; to close the plotting
      device for the current output stream only.  Note that if PLplot is
      initialized more than once during a program to change the output
      device, an automatic call to &plend1; is made before the new device
      is opened for the given stream.
    </para>

  </sect1>

  <sect1 id="arguments">
    <title>Command line arguments</title>

    <para>
      PLplot supports a large number of command line arguments, but it is
      up to the user to pass these to PLplot for processing at the
      beginning of execution.  The function
      <function>plParseInternalOpts</function> is responsible for parsing
      the argument list, removing all that are recognized by PLplot, and
      taking the appropriate action before returning.  There are an
      extensive number of options available to affect this process.  The
      command line arguments recognized by PLplot are given by the -h
      option:
    </para>
    
    <para>
      <screen>
<prompt>%</prompt> <userinput>x01c -h</userinput>

Usage:
        x01c [plplot options]

plplot options:
    -h                   Print out this message
    -v                   Print out the plplot library version number
    -dev name            Output device name
    -o name              Output filename
    -display name        X server to contact
    -px number           Plots per page in x
    -py number           Plots per page in y
    -geometry geom       Window size, in pixels (e.g. -geometry 400x300)
    -wplt xl,yl,xr,yr    Relative coordinates [0-1] of window into plot
    -mar margin          Margin space in relative coordinates (0 to 0.5, def 0)
    -a aspect            Page aspect ratio (def: same as output device)
    -jx justx            Page justification in x (-0.5 to 0.5, def 0)
    -jy justy            Page justification in y (-0.5 to 0.5, def 0)
    -ori orient          Plot orientation (0,2=landscape, 1,3=portrait)
    -width width         Sets pen width (1 <= width <= 10)
    -bg color            Background color (0=black, FFFFFF=white)
    -fam                 Create a family of output files
    -fsiz size           Output family file size in MB (e.g. -fsiz 1.0)
    -fbeg number         First family member number on output
    -finc number         Increment between family members
    -fflen length        Family member number minimum field width
    -nopixmap            Don't use pixmaps in X-based drivers
    -db                  Double buffer X window output
    -np                  No pause between pages
    -server_name name    Main window name of plplot server (tk driver)
    -server_host name    Host to run plplot server on (dp driver)
    -server_port name    Port to talk to plplot server on (dp driver)
    -user name           User name on remote node (dp driver)

All parameters must be white-space delimited.  Some options are driver
dependent.  Please see the plplot reference document for more detail.<!--
   --></screen>
    </para>

  </sect1>
  
  <sect1 id="viewports">
    <title>Defining the Viewport</title>

    <para>
      After defining the view surface, it is necessary to define the
      portion of this surface which is to be used for plotting the graph
      (the viewport).  All lines and symbols (except for labels drawn by
      &plbox;, &plmtex; and &pllab;) are clipped at the viewport
      boundaries.
    </para>

    <para>
      Viewports are created within the current subpage.  If the division of
      the output device into equally sized subpages is inappropriate, it is
      best to specify only a single subpage which occupies the entire
      output device (by setting <literal>nx = 1</literal> and <literal>ny =
      1</literal> in &plstart; or &plstar;), and use one of the viewport
      specification subroutines below to place the plot in the desired
      position on the page.
    </para>

    <para>
      There are four methods for specifying the viewport size, using the
      subroutines &plvpor;, &plsvpa;, &plvasp;, and &plvpas;.  Each of
      these has the format:
    </para>

    <para>
      <programlisting>
    plvpor(xmin, xmax, ymin, ymax);
    plsvpa(xmin, xmax, ymin, ymax);
    plvasp(aspect);
    plvpas(xmin, xmax, ymin, ymax, aspect);<!--
   --></programlisting>
    </para>

    <para>
      where in the case of &plvpor; and &plvpas;, the arguments are given
      in <emphasis>normalized subpage coordinates</emphasis> which are
      defined to run from 0.0 to 1.0 along each edge of the subpage.  Thus
      for example,
    </para>
    
    <para>
      <programlisting>
    plvpor(0.0, 0.5, 0.5, 1.0);<!--
   --></programlisting>
    </para>

    <para>
      uses the top left quarter of the current subpage.
    </para>

    <para>
      In order to get a graph of known physical size, the routine &plsvpa;
      defines the viewport in terms of absolute coordinates (millimeters)
      measured from the bottom left-hand corner of the current subpage.
      This routine should only be used when the size of the view surface is
      known, and a definite scaling is required.
    </para>

    <para>
      The routine &plvasp; gives the largest viewport with the given aspect
      ratio that fits in the current subpage (i.e. the ratio of the length
      of the y axis to that of the x axis is equal to
      <literal>aspect</literal>).  It also allocates space on the left and
      top of the viewport for labels.
    </para>

    <para>
      The routine &plvpas; gives the largest viewport with the given aspect
      ratio that fits in the specified region (specified with normalized
      subpage coordinates, as with &plvpor;).  This routine is functionally
      equivalent to &plvpor; when a <quote>natural</quote> aspect ratio is
      chosen (done by setting <literal>aspect</literal> to 0.0).  Unlike
      &plvasp;, this routine reserves no extra space at the edges for
      labels.
    </para>

    <para>
      To help the user call &plsvpa; correctly, the routine &plgspa; is
      provided which returns the positions of the extremities of the
      current subpage measured in millimeters from the bottom left-hand
      corner of the device.  Thus, if to set up a viewport with a 10.0 mm
      margin around it within the current subpage, the following sequence
      of calls may be used:
    </para>
    
    <para>
      <programlisting>
    plgspa(xmin, xmax, ymin, ymax);
    plsvpa(10.0, xmax-xmin-10.0, 10.0, ymax-ymin-10.0);<!--
   --></programlisting>
    </para>

    <para>
      A further routine &plvsta; is available which sets up a standard
      viewport within the current subpage with suitable margins on each
      side of the viewport.  This may be used for simple graphs, as it
      leaves enough room for axis labels and a title.  This standard
      viewport is that used by &plenv; (See <xref
      linkend="standard-window">).
    </para>

    <para>
      Another way to get a specified aspect ratio is via the routine
      <function>plsasp</function> [not!.. fix this], which sets the global
      aspect ratio and must be called prior to &plstar;.  An aspect ratio
      of 0.0 corresponds to <quote>natural</quote> dimensions (i.e. fill
      the page); any positive value will give the specified aspect ratio.
      This scaling of plots is actually done in the driver, and so may not
      work for all output devices (note that <function>plrender</function>
      is capable of scaled aspect ratio plots to any device whether that
      device supports scaling or not).  In such scaled plots, absolute
      plotting is done in the scaled coordinate system.
    </para>

  </sect1>
  
  <sect1 id="windows">
    <title>Defining the Window</title>

    <para>
      The window must be defined after the viewport in order to map the
      world coordinate rectangle into the viewport rectangle.  The routine
      &plwind; is used to specify the rectangle in world-coordinate space.
      For example, if we wish to plot a graph showing the collector current
      I<subscript>C</subscript> as a function of the collector to emitter
      voltage V<subscript>CE</subscript> for a transistor where 0 &leq;
      I<subscript>C</subscript> &leq; 10.0&nbsp;mA and 0 &leq;
      V<subscript>CE</subscript> &leq; 12.0&nbsp;V, we would call the
      function &plwind; as follows:
    </para>
    
    <para>
      <programlisting>
    plwind(0.0, 12.0, 0.0, 10.0);<!--
   --></programlisting>
    </para>

    <para>
      Note that each of the arguments is a floating point number, and so
      the decimal points are required.  If the order of either the X limits
      or Y limits is reversed, the corresponding axis will point in the
      opposite sense, (i.e., right to left for X and top to bottom for Y).
      The window must be defined before any calls to the routines which
      actually draw the data points.  Note however that &plwind; may also
      be called to change the window at any time.  This will affect the
      appearance of objects drawn later in the program, and is useful for
      drawing two or more graphs with different axes on the same piece of
      paper.
    </para>

  </sect1>
  
  <sect1 id="annotation">
    <title>Annotating the Viewport</title>

    <para>
      The routine &plbox; is used to specify whether a frame is drawn
      around the viewport and to control the positions of the axis
      subdivisions and numeric labels.  For our simple graph of the
      transistor characteristics, we may wish to draw a frame consisting of
      lines on all four sides of the viewport, and to place numeric labels
      along the bottom and left hand side.  We can also tell PLplot to
      choose a suitable tick interval and the number of subticks between
      the major divisions based upon the data range specified to &plwind;.
      This is done using the following statement
    </para>
    
    <para>
      <programlisting>
    plbox("bcnst", 0.0, 0, "bcnstv", 0.0, 0);<!--
   --></programlisting>
    </para>

    <para>
      Another routine &pllab; provides for text labels for the bottom, left
      hand side and top of the viewport.  These labels are not clipped,
      even though they lie outside the viewport (but they are clipped at
      the subpage boundaries).  &pllab; actually calls the more general
      routine &plmtex; which can be used for plotting labels at any point
      relative to the viewport.  For our example, we may use
    </para>
    
    <para>
      <programlisting>
    pllab("V#dCE#u (Volts)", "I#dC#u (mA)", "TRANSISTOR CHARACTERISTICS");<!--
   --></programlisting>
    </para>

    <para>
      Note that <literal>#d</literal> and <literal>#u</literal> are escape
      sequences (see <xref linkend="escape-sequences">) which allow
      subscripts and superscripts to be used in text.  They are described
      more fully later in this chapter.
    </para>

    <para>
      The appearance of axis labels may be further altered by auxiliary
      calls to &plprec;, &plschr;, &plsxax;, &plsyax;, and &plszax;.  The
      routine &plprec; is used to set the number of decimal places
      precision for axis labels, while &plschr; modifies the heights of
      characters used for the axis and graph labels.  Routines &plsxax;,
      &plsyax;, and &plszax; are used to modify the
      <literal>digmax</literal> setting for each axis, which affects how
      floating point labels are formatted.
    </para>

    <para>
      The <literal>digmax</literal> variable represents the maximum field
      width for the numeric labels on an axis (ignored if less than one).
      If the numeric labels as generated by PLplot exceed this width, then
      PLplot automatically switches to floating point representation.  In
      this case the exponent will be placed at the top left for a vertical
      axis on the left, top right for a vertical axis on the right, and
      bottom right for a horizontal axis.
    </para>

    <para>
      For example, let's suppose that we have set <literal>digmax =
      5</literal> via &plsyax;, and for our plot a label is generated at
      <literal>y = 0.0000478</literal>.  In this case the actual field
      width is longer than <literal>digmax</literal>, so PLplot switches to
      floating point.  In this representation, the label is printed as
      simply 4.78 with the 10<superscript>-5</superscript> exponent placed
      separately.
    </para>

    <para>
      The determination of maximum length (i.e. <literal>digmax</literal>)
      for fixed point quantities is complicated by the fact that long fixed
      point representations look much worse than the same sized floating
      point representation.  Further, a fixed point number with magnitude
      much less than one will actually gain in precision when written as
      floating point.  There is some compensation for this effect built
      into PLplot, thus the internal representation for number of digits
      kept (<literal>digfix</literal>) may not always match the user's
      specfication (via <literal>digmax</literal>).  However, it will
      always be true that <literal>digfix &leq; digmax</literal>.  The
      PLplot defaults are set up such that good results are usually
      obtained without user intervention.
    </para>

    <para>
      Finally, after the call to &plbox;, the user may call routines
      &plgxax;, &plgyax;, or &plgzax; to obtain information about the
      window just drawn.  This can be helpful when deciding where to put
      captions.  For example, a typical usage would be to call &plgyax; to
      get the value of <literal>digits</literal>, then offset the y axis
      caption by that amount (plus a bit more) so that the caption
      <quote>floats</quote> just to the outside of the numeric labels.
      Note that the <literal>digits</literal> value for each axis for the
      current plot is not correct until <emphasis>after</emphasis> the call
      to &plbox; is complete.
    </para>

  </sect1>
  
  <sect1 id="standard-window">
    <title>Setting up a Standard Window</title>

    <para>
      Having to call &pladv;, &plvpor;, &plwind; and &plbox; is excessively
      cumbersome for drawing simple graphs.  Subroutine &plenv; combines
      all four of these in one subroutine, using the standard viewport, and
      a limited subset of the capabilities of &plbox;.  For example, the
      graph described above could be initiated by the call:
    </para>

    <para>
      <programlisting>
    plenv(0.0, 12.0, 0.0, 10.0, 0, 0);<!--
   --></programlisting>
    </para>

    <para>
      which is equivalent to the following series of calls:
    </para>

    <para>
      <programlisting>
    pladv(0);
    plvsta();
    plwind(0.0, 12.0, 0.0, 10.0);
    plbox("bcnst", 0.0, 0, "bcnstv", 0.0, 0);<!--
   --></programlisting>
    </para>

  </sect1>

  <sect1 id="line-attributes">
    <title>Setting Line Attributes</title>

    <para>
      The graph drawing routines may be freely mixed with those described
      in this section, allowing the user to control line color, width and
      styles.  The attributes set up by these routines apply modally, i.e,
      all subsequent objects (lines, characters and symbols) plotted until
      the next change in attributes are affected in the same way.  The only
      exception to this rule is that characters and symbols are not
      affected by a change in the line style, but are always drawn using a
      continuous line.
    </para>

    <para>
      Line color is set using the routine &plcol0;.  The argument is ignored
      for devices which can only plot in one color, although some terminals
      support line erasure by plotting in color zero.
    </para>

    <para>
      Line width is set using &plwid;.  This option is not supported by
      all devices.
    </para>

    <para>
      Line style is set using the routine &plstyl; or &pllsty;.  A broken
      line is specified in terms of a repeated pattern consisting of marks
      (pen down) and spaces (pen up).  The arguments to this routine are
      the number of elements in the line, followed by two pointers to
      integer arrays specifying the mark and space lengths in micrometers.
      Thus a line consisting of long and short dashes of lengths 4&nbsp;mm
      and 2&nbsp;mm, separated by spaces of length 1.5&nbsp;mm is specified
      by:
    </para>

    <para>
      <programlisting>
    mark[0] = 4000;
    mark[1] = 2000;
    space[0] = 1500;
    space[1] = 1500;
    plstyl(2, mark, space);<!--
   --></programlisting>
    </para>

    <para>
      To return to a continuous line, just call &plstyl; with first
      argument set to zero.  You can use &pllsty; to choose between 8
      different predefined styles.
    </para>

  </sect1>
  
  <sect1 id="fill-pattern">
    <title>Setting the Area Fill Pattern</title>

    <para>
      The routine &plpat; can be used to set the area fill pattern.  The
      pattern consists of 1 or 2 sets of parallel lines with specified
      inclinations and spacings.  The arguments to this routine are the
      number of sets to use (1 or 2) followed by two pointers to integer
      arrays (of 1 or 2 elements) specifying the inclinations in tenths of
      a degree and the spacing in micrometers (the inclination should be
      between -900 and 900).  Thus to specify an area fill pattern
      consisting of horizontal lines spaced 2&nbsp;mm apart use:
    </para>
    
    <para>
      <programlisting>
    *inc = 0;
    *del = 2000;
    plpat(1, inc, del);<!--
   --></programlisting>
    </para>

    <para>
      To set up a symmetrical crosshatch pattern with lines directed 30
      degrees above and below the horizontal and spaced 1.5&nbsp;mm apart
      use:
    </para>

    <para>
      <programlisting>
    *inc = 300;
    *(inc+1) = -300;
    *del = 1500;
    *(del+1) = 1500;
    plpat(2, inc, del);<!--
   --></programlisting>
    </para>

    <para>
      The routine &plpsty; can be used to select from 1 of 8 predefined
      patterns.
    </para>

    <para>
      The area fill routines also use the current line style, width and
      colors to give a virtually infinite number of different patterns.
    </para>

  </sect1>
  
  <sect1 id="characters">
    <title>Setting Character and Symbol Attributes</title>

    <para>
      There are two character sets included with PLplot.  These are known
      as the standard and extended character sets respectively.  The
      standard character set is a subset of the extended set.  It contains
      177 characters including the ascii characters in a normal style font,
      the greek alphabet and several plotter symbols.  The extended
      character set contains almost 1000 characters, including four font
      styles, and several math, musical and plotter symbols.
    </para>

    <para>
      The standard character set is loaded into memory automatically when
      &plstar; or &plstart; is called.  The extended character set is
      loaded by calling &plfontld;.  The extended character set requires
      about 50 kbytes of memory, versus about 5 kbytes for the standard
      set.  &plfontld; can be used to switch between the extended and
      standard sets (one set is unloaded before the next is loaded).
      &plfontld; can be called before &plstar;.
    </para>

    <para>
      When the extended character set is loaded there are four different
      font styles to choose from.  In this case, the routine &plfont; sets
      up the default font for all character strings.  It may be overridden
      for any portion of a string by using an escape sequence within the
      text, as described below.  This routine has no effect when the
      standard font set is loaded.  The default font (1) is simple and
      fastest to draw; the others are useful for presentation plots on a
      high-resolution device.
    </para>

    <para>
      The font codes are interpreted as follows:

      <itemizedlist>
	<listitem>
	  <para>
	    <literal>font = 1</literal>: normal simple font
	  </para>
	</listitem>
	<listitem>
	  <para>
	    <literal>font = 2</literal>: roman font
	  </para>
	</listitem>
	<listitem>
	  <para>
	    <literal>font = 3</literal>: italic font
	  </para>
	</listitem>
	<listitem>
	  <para>
	    <literal>font = 4</literal>: script font
	  </para>
	</listitem>
      </itemizedlist>
    </para>

    <para>
      The routine &plschr; is used to set up the size of subsequent
      characters drawn.  The actual height of a character is the product of
      the default character size and a scaling factor.  If no call is made
      to &plschr;, the default character size is set up depending on the
      number of subpages defined in the call to &plstar; or &plstart;, and
      the scale is set to 1.0.  Under normal circumstances, it is
      recommended that the user does not alter the default height, but
      simply use the scale parameter.  This can be done by calling &plschr;
      with <literal>def = 0.0</literal> and <literal>scale</literal> set to
      the desired multiple of the default height.  If the default height is
      to be changed, <literal>def</literal> is set to the new default
      height in millimeters, and the new character height is again set to
      <literal>def</literal> multiplied by <literal>scale</literal>.
    </para>

    <para>
      The routine &plssym; sets up the size of all subsequent symbols drawn
      by calls to &plpoin; and &plsym;.  It operates analogously to
      &plschr; as described above.
    </para>

    <para>
      The lengths of major and minor ticks on the axes are set up by the
      routines &plsmaj; and &plsmin;.
    </para>

  </sect1>
  
  <sect1 id="escape-sequences">
    <title>Escape Sequences in Text</title>

    <para>
      The routines which draw text all allow you to include escape
      sequences in the text to be plotted.  These are character sequences
      that are interpreted as instructions to change fonts, draw
      superscripts and subscripts, draw non-ASCII (e.g. Greek), and so on.
      All escape sequences start with a number symbol
      (<literal>#</literal>).
    </para>

    <para>
      The following escape sequences are defined:

      <itemizedlist>
	<listitem>
	  <para>
	    <literal>#u</literal>: move up to the superscript position
	    (ended with <literal>#d</literal>)
	  </para>
	</listitem>
	<listitem>
	  <para>
	    <literal>#d</literal>: move down to subscript position
	    (ended with <literal>#u</literal>)
	  </para>
	</listitem>
	<listitem>
	  <para>
	    <literal>#b</literal>: backspace (to allow overprinting)
	  </para>
	</listitem>
	<listitem>
	  <para>
	    <literal>##</literal>: number symbol
	  </para>
	</listitem>
	<listitem>
	  <para>
	    <literal>#+</literal>: toggle overline mode
	  </para>
	</listitem>
	<listitem>
	  <para>
	    <literal>#-</literal>: toggle underline mode
	  </para>
	</listitem>
	<listitem>
	  <para>
	    <literal>#gx</literal>: Greek letter corresponding to Roman
	    letter <literal>x</literal> (see below)
	  </para>
	</listitem>
	<listitem>
	  <para>
	    <literal>#fn</literal>: switch to normal font
	  </para>
	</listitem>
	<listitem>
	  <para>
	    <literal>#fr</literal>: switch to Roman font
	  </para>
	</listitem>
	<listitem>
	  <para>
	    <literal>#fi</literal>: switch to italic font
	  </para>
	</listitem>
	<listitem>
	  <para>
	    <literal>#fs</literal>: switch to script font
	  </para>
	</listitem>
	<listitem>
	  <para>
	    <literal>#(nnn)</literal>: Hershey character nnn (1 to 4
	    decimal digits) 
	  </para>
	</listitem>
      </itemizedlist>
    </para>

    <para>
      Sections of text can have an underline or overline appended.  For
      example, the string &over-under; is obtained by specifying
      <literal>"#+S#+(#-freq#-)"</literal>. 
    </para>

    <para>
      Greek letters are obtained by <literal>#g</literal> followed by a
      Roman letter.  <xref LINKEND="greek"> shows how these letters map
      into Greek characters.
    </para>

    <TABLE FRAME="all" ID="greek">
      <TITLE>Roman characters corresponding to Greek characters</TITLE>
      <TGROUP ALIGN="center" COLS="13">
	<COLSPEC ALIGN="center" COLNUM="1" COLWIDTH="2*">
	<TBODY valign="top">
	  <ROW>
	    <ENTRY>Roman</ENTRY>
	    <ENTRY>A</ENTRY>
	    <ENTRY>B</ENTRY>
	    <ENTRY>G</ENTRY>
	    <ENTRY>D</ENTRY>
	    <ENTRY>E</ENTRY>
	    <ENTRY>Z</ENTRY>
	    <ENTRY>Y</ENTRY>
	    <ENTRY>H</ENTRY>
	    <ENTRY>I</ENTRY>
	    <ENTRY>K</ENTRY>
	    <ENTRY>L</ENTRY>
	    <ENTRY>M</ENTRY>
	  </ROW>
	  <ROW>
	    <ENTRY>Greek</ENTRY>
	    <ENTRY>&Alpha;</ENTRY>
	    <ENTRY>&Beta;</ENTRY>
	    <ENTRY>&Gamma;</ENTRY>
	    <ENTRY>&Delta;</ENTRY>
	    <ENTRY>&Epsilon;</ENTRY>
	    <ENTRY>&Zeta;</ENTRY>
	    <ENTRY>&Eta;</ENTRY>
	    <ENTRY>&Theta;</ENTRY>
	    <ENTRY>&Iota;</ENTRY>
	    <ENTRY>&Kappa;</ENTRY>
	    <ENTRY>&Lambda;</ENTRY>
	    <ENTRY>&Mu;</ENTRY>
	  </ROW>
	</TBODY>
      </TGROUP>
      <TGROUP ALIGN="center" COLS="13">
	<COLSPEC ALIGN="center" COLNUM="1" COLWIDTH="2*">
	<TBODY>
	  <ROW>
	    <ENTRY>Roman</ENTRY>
	    <ENTRY>N</ENTRY>
	    <ENTRY>C</ENTRY>
	    <ENTRY>O</ENTRY>
	    <ENTRY>P</ENTRY>
	    <ENTRY>R</ENTRY>
	    <ENTRY>S</ENTRY>
	    <ENTRY>T</ENTRY>
	    <ENTRY>U</ENTRY>
	    <ENTRY>F</ENTRY>
	    <ENTRY>X</ENTRY>
	    <ENTRY>Q</ENTRY>
	    <ENTRY>W</ENTRY>
	  </ROW>
	  <ROW>
	    <ENTRY>Greek</ENTRY>
	    <ENTRY>&Nu;</ENTRY>
	    <ENTRY>&Xi;</ENTRY>
	    <ENTRY>&Omicron;</ENTRY>
	    <ENTRY>&Pi;</ENTRY>
	    <ENTRY>&Rho;</ENTRY>
	    <ENTRY>&Sigma;</ENTRY>
	    <ENTRY>&Tau;</ENTRY>
	    <ENTRY>&Upsilon;</ENTRY>
	    <ENTRY>&Phi;</ENTRY>
	    <ENTRY>&Chi;</ENTRY>
	    <ENTRY>&Psi;</ENTRY>
	    <ENTRY>&Omega;</ENTRY>
	  </ROW>
	</TBODY>
      </TGROUP>
      <TGROUP ALIGN="center" COLS="13">
	<COLSPEC ALIGN="center" COLNUM="1" COLWIDTH="2*">
	<TBODY>
	  <ROW>
	    <ENTRY>Roman</ENTRY>
	    <ENTRY>a</ENTRY>
	    <ENTRY>b</ENTRY>
	    <ENTRY>g</ENTRY>
	    <ENTRY>d</ENTRY>
	    <ENTRY>e</ENTRY>
	    <ENTRY>z</ENTRY>
	    <ENTRY>y</ENTRY>
	    <ENTRY>h</ENTRY>
	    <ENTRY>i</ENTRY>
	    <ENTRY>k</ENTRY>
	    <ENTRY>l</ENTRY>
	    <ENTRY>m</ENTRY>
	  </ROW>
	  <ROW>
	    <ENTRY>Greek</ENTRY>
	    <ENTRY>&alpha;</ENTRY>
	    <ENTRY>&beta;</ENTRY>
	    <ENTRY>&gamma;</ENTRY>
	    <ENTRY>&delta;</ENTRY>
	    <ENTRY>&epsilon;</ENTRY>
	    <ENTRY>&zeta;</ENTRY>
	    <ENTRY>&eta;</ENTRY>
	    <ENTRY>&theta;</ENTRY>
	    <ENTRY>&iota;</ENTRY>
	    <ENTRY>&kappa;</ENTRY>
	    <ENTRY>&lambda;</ENTRY>
	    <ENTRY>&mu;</ENTRY>
	  </ROW>
	</TBODY>
      </TGROUP>
      <TGROUP ALIGN="center" COLS="13">
	<COLSPEC ALIGN="center" COLNUM="1" COLWIDTH="2*">
	<TBODY>
	  <ROW>
	    <ENTRY>Roman</ENTRY>
	    <ENTRY>n</ENTRY>
	    <ENTRY>c</ENTRY>
	    <ENTRY>o</ENTRY>
	    <ENTRY>p</ENTRY>
	    <ENTRY>r</ENTRY>
	    <ENTRY>s</ENTRY>
	    <ENTRY>t</ENTRY>
	    <ENTRY>u</ENTRY>
	    <ENTRY>f</ENTRY>
	    <ENTRY>x</ENTRY>
	    <ENTRY>q</ENTRY>
	    <ENTRY>w</ENTRY>
	  </ROW>
	  <ROW>
	    <ENTRY>Greek</ENTRY>
	    <ENTRY>&nu;</ENTRY>
	    <ENTRY>&xi;</ENTRY>
	    <ENTRY>&omicron;</ENTRY>
	    <ENTRY>&pi;</ENTRY>
	    <ENTRY>&rho;</ENTRY>
	    <ENTRY>&sigma;</ENTRY>
	    <ENTRY>&tau;</ENTRY>
	    <ENTRY>&upsilon;</ENTRY>
	    <ENTRY>&phi;</ENTRY>
	    <ENTRY>&chi;</ENTRY>
	    <ENTRY>&psi;</ENTRY>
	    <ENTRY>&omega;</ENTRY>
	  </ROW>
	</TBODY>
      </TGROUP>
    </TABLE>
    
    
  </sect1>

  <sect1 id="tri-d-plots">
    <title>Three Dimensional Surface Plots</title>

    <para>
      PLplot includes routines that will represent a single-valued function
      of two variables as a surface.  In this section, we shall assume that
      the function to be plotted is <literal>Z[X][Y]</literal>, where
      <literal>Z</literal> represents the dependent variable and
      <literal>X</literal> and <literal>Y</literal> represent the
      independent variables.
    </para>

    <para>
      As usual, we would like to refer to a three dimensional point
      <literal>(X, Y, Z)</literal> in terms of some meaningful
      user-specified coordinate system.  These are called
      <emphasis>three-dimensional world coordinates</emphasis>.  We need to
      specify the ranges of these coordinates, so that the entire surface
      is contained within the cuboid defined by <literal>xmin &less; x &less;
      xmax</literal>, <literal>ymin &less; y &less; ymax</literal>, and
      <literal>zmin &less; z &less; zmax</literal>.  Typically, we shall want
      to view the surface from a variety of angles, and to facilitate this,
      a two-stage mapping of the enclosing cuboid is performed.  Firstly,
      it is mapped into another cuboid called the <emphasis>normalized
      box</emphasis> whose size must also be specified by the user, and
      secondly this normalized box is viewed from a particular azimuth and
      elevation so that it can be projected onto the two-dimensional
      window.
    </para>

    <para>
      This two-stage transformation process allows considerable flexibility
      in specifying how the surface is depicted.  The lengths of the sides
      of the normalized box are independent of the world coordinate ranges
      of each of the variables, making it possible to use
      <quote>reasonable</quote> viewing angles even if the ranges of the
      world coordinates on the axes are very different.  The size of the
      normalized box is determined essentially by the size of the
      two-dimensional window into which it is to be mapped.  The normalized
      box is centered about the origin in the <literal>x</literal> and
      <literal>y</literal> directions, but rests on the plane <literal>z =
      0</literal>.  It is viewed by an observer located at altitude
      <literal>alt</literal> and azimuth <literal>az</literal>, where both
      angles are measured in degrees.  The altitude should be restricted to
      the range zero to ninety degrees for proper operation, and represents
      the viewing angle above the xy plane.  The azimuth is defined so that
      when <literal>az = 0</literal>, the observer sees the xz plane face
      on, and as the angle is increased, the observer moves clockwise
      around the box as viewed from above the xy plane.  The azimuth can
      take on any.
    </para>

    <para>
      The first step in drawing a surface plot is to decide on the size of
      the two-dimensional window and the normalized box.  For example, we
      could choose the normalized box to have sides of length
    </para>

    <para>
      <programlisting>
    basex = 2.0;
    basey = 4.0;
    height = 3.0;<!--
   --></programlisting>
    </para>

    <para>
      A reasonable range for the x coordinate of the two-dimensional window
      is -2.5 to +2.5, since the length of the diagonal across the base of
      the normalized box is
      sqrt(2<superscript>2</superscript>+4<superscript>2</superscript>) =
      2&nbsp;sqrt(5), which fits into this coordinate range.  A reasonable
      range for the y coordinate of the two dimensional window in this case
      is -2.5 to +4, as the the projection of the normalized box lies in
      this range for the allowed range of viewing angles.
    </para>

    <para>
      The routine &plwind; or &plenv; is used in the usual way to establish
      the size of the two-dimensional window.  The routine &plw3d; must
      then be called to establish the range of the three dimensional world
      coordinates, the size of the normalized box and the viewing angles.
      After calling &plw3d;, the actual surface is drawn by a call to
      &plot3d;.
    </para>

    <para>
      For example, if the three-dimensional world-coordinate ranges are
      -10.0 &leq; <literal>x</literal> &leq; 10.0, -3.0 &leq;
      <literal>y</literal> &leq; +7.0, and 0.0 &leq; <literal>z</literal>
      &leq; 8.0, we could use the following statements:
    </para>
    
    <para>
      <programlisting>
    xmin2d = -2.5;
    xmax2d =  2.5;
    ymin2d = -2.5;
    ymax2d =  4.0;
    plenv(xmin2d, xmax2d, ymin2d, ymax2d, 0, -2);
    basex = 2.0;
    basey = 4.0;
    height = 3.0;
    xmin = -10.0;
    xmax = 10.0;
    ymin = -3.0;
    ymax = 7.0;
    zmin = 0.0;
    zmax = 8.0;
    alt = 45.0;
    az = 30.0;
    side = 1;
    plw3d(basex, basey, height, xmin, xmax, ymin, ymax, zmin, zmax, alt, az);
    plot3d(x, y, z, nx, ny, opt, side);<!--
   --><!--
   --></programlisting>
    </para>

    <para>
      The values of the function are stored in a two-dimensional array
      <literal>z[][]</literal> where the array element
      <literal>z[i][j]</literal> contains the value of the function at the
      point x<subscript>i</subscript>, y<subscript>j</subscript>.  (The
      two-dimensional array <literal>z</literal> is a vectored array
      instead of a fixed size array.  <literal>z</literal> points to an
      array of pointers which each point to a rwo of the matrix.)  Note
      that the values of the independent variables
      x<subscript>i</subscript> and y<subscript>j</subscript> do not need
      to be equally spaced, but they must lie on a rectangular grid.  Thus
      two further arrays <literal>x[nx]</literal> and
      <literal>y[ny]</literal> are required as arguments to &plot3d; to
      specify the values of the independent variables.  The values in the
      arrays x and y must be strictly increasing with the index.  The
      argument <literal>opt</literal> specifies how the surface is
      outlined.  If <literal>opt = 1</literal>, a line is drawn
      representing z as a function of x for each value of y, if
      <literal>opt = 2</literal>, a line is drawn representing z as a
      function of y for each value of x, and if <literal>opt = 3</literal>,
      a net of lines is drawn.  The first two options may be preferable if
      one of the independent variables is to be regarded as a parameter,
      whilst the third is better for getting an overall picture of the
      surface.  If side is equal to one then sides are drawn on the figure
      so that the graph doesn't appear to float.
    </para>

    <para>
      The routine &plmesh; is similar to &plot3d;, except that it is used
      for drawing mesh plots.  Mesh plots allow you to see both the top and
      bottom sides of a surface mesh, while 3D plots allow you to see the
      top side only (like looking at a solid object).  The side option is
      not available with &plmesh;.
    </para>

    <para>
      Labelling a three-dimensional or mesh plot is somewhat more
      complicated than a two dimensional plot due to the need for skewing
      the characters in the label so that they are parallel to the
      coordinate axes.  The routine &plbox3; thus combines the functions of
      box drawing and labelling.
    </para>
    
  </sect1>
  
  <sect1 id="contour-plots">
    <title>Contour and Shade Plots</title>
    
    <para>
      Several routines are available in PLplot which perform a contour or
      shade plot of data stored in a two-dimensional array.  The contourer
      uses a contour following algorithm is used, so that it is possible to
      use non-continuous line styles.  Further, one may specify arbitrary
      coordinate mappings from array indices to world coordinates, such as
      for contours in a polar coordinate system.  In this case it is best
      to draw the distinction between a C and Fortran language caller, so
      these are handled in turn.
    </para>
    
    <sect2 id="contour-plots-c">
      <title>Contour Plots from C</title>

      <para>
	&plcont; is the routine callable from C for plotting contours.
	This routine has the form:
      </para>

      <para>
	<funcsynopsis> 
	  <funcdef>
	    <function>plcont</function>
	  </funcdef>
	  <paramdef><parameter>z</parameter></paramdef>
	  <paramdef><parameter>nx</parameter></paramdef>
	  <paramdef><parameter>ny</parameter></paramdef>
	  <paramdef><parameter>kx</parameter></paramdef>
	  <paramdef><parameter>lx</parameter></paramdef>
	  <paramdef><parameter>ky</parameter></paramdef>
	  <paramdef><parameter>ly</parameter></paramdef>
	  <paramdef><parameter>clevel</parameter></paramdef>
	  <paramdef><parameter>nlevel</parameter></paramdef>
	  <paramdef><parameter>pltr</parameter></paramdef>
	  <paramdef><parameter>pltr_data</parameter></paramdef>
	</funcsynopsis>
      </para>
      
      <para>
	where <literal>z</literal> is the two-dimensional array of size
	<literal>nx</literal> by <literal>ny</literal> containing samples
	of the function to be contoured.  (<literal>z</literal> is a
	vectored two-dimensional array as described in the previous
	section.  It is <emphasis>not</emphasis> a fixed-size
	two-dimensional array.) The parameters <literal>kx</literal>,
	<literal>lx</literal>, <literal>ky</literal> and
	<literal>ly</literal> specify the portion of <literal>z</literal>
	that is to be considered.  The array <literal>clevel</literal> of
	length <literal>nlevel</literal> is a list of the desired contour
	levels.
      </para>

      <para>
	The path of each contour is initially computed in terms of the
	values of the array indices which range from <literal>0</literal>
	to <literal>nx-1</literal> in the first index and from
	<literal>0</literal> to <literal>ny-1</literal> in the second
	index.  Before these can be drawn in the current window (see <xref
	linkend="windows">), it is necessary to convert from these array
	indices into world coordinates.  This is done by passing a pointer
	to a user-defined function to &plcont; This function pointer is
	the last argument &pltr;.  
	(N.B. This documentation needs updating because there is now an
	extra argument to &plcont; and &pltr; which is not currently
	documented.)  This function must be declared as type
	<literal>void</literal> in the module which calls &plcont;.  This
	transformation function must have the parameter list:
      </para>
      
      <para>
	<funcsynopsis> 
	  <funcdef>
	    <function>pltr</function>
	  </funcdef>
	  <paramdef><parameter>x</parameter></paramdef>
	  <paramdef><parameter>y</parameter></paramdef>
	  <paramdef><parameter>tx</parameter></paramdef>
	  <paramdef><parameter>ty</parameter></paramdef>
	  <paramdef><parameter>pltr_data</parameter></paramdef>
	</funcsynopsis>
      </para>
      
      <para>
	where <literal>(x, y)</literal> is the point through which the
	contour runs expressed in terms of array indices, and
	<literal>(tx, ty)</literal> are pointers to float variables which
	are the world coordinates of the point which corresponds to these
	indices.
      </para>

      <para>
	Often, the transformation between array indices and world
	coordinates can be expressed as a linear transformation.  A routine
	is provided within the library which can be passed to &plcont; as
	&pltr;.  This transformation routine is:
      </para>

      <para>
	<programlisting>
#include "plplot.h"

#ifdef PLSTDC
void 
xform(PLFLT x, PLFLT y, PLFLT * tx, PLFLT * ty)
#else
void 
xform(x, y, tx, ty)
PLFLT x, y, *tx, *ty;
#endif
{
    *tx = tr[0] * x + tr[1] * y + tr[2];
    *ty = tr[3] * x + tr[4] * y + tr[5];
}<!--
   --></programlisting>
      </para>

      <para>
	and should be compiled as part of the user's code (it is
	<emphasis>not</emphasis> normally linked in with the PLplot library
	since the <literal>tr</literal> data array is unspecified).
      </para>

      <para>
	Thus by setting up the values in the array <literal>tr[]</literal>,
	we can apply an arbitrary translation, rotation and/or shear to the
	array before drawing out the contours.  By defining other
	transformation subroutines, it is possible to draw contours wrapped
	around polar grids etc.  If no transformation is required, you can
	simply set <literal>tr[0] = tr[4] = 1.</literal>, with other
	entries set to 0..  Alternately you can pass the built-in function
	<literal>pltr0</literal> to &plcont;; this function merely sets
	<literal>*tx</literal> to <literal>x</literal> and
	<literal>*ty</literal> to <literal>y</literal>, resulting in no net
	transformation.
      </para>

      <para>
	As an example in setting up <literal>tr[]</literal>, suppose that
	the array <literal>z</literal> is of size 21 by 41 and contains the
	values of the function <literal>z[x][y]</literal>, where
	<literal>x</literal> ranges from 0.0 to 4.0 and
	<literal>y</literal> ranges from -8.0 to 8.0.  Furthermore, let us
	also suppose that the window (as defined using &plenv; or &plwind;)
	covers this range of world coordinates.  Since we wish the index
	(0, 0) in array <literal>z</literal> to map to (0.0, -8.0) and the
	index (20, 40) to map to (4.0, 8.0), and for there to be no skew in
	the axes, we should choose elements of <literal>tr[]</literal> so
	that 

	<informaltable frame="none" pgwide="0">
	  <TGROUP ALIGN="center" COLS="3">
	  <colspec colnum="1" align="right" colwidth="1*">
	  <colspec colnum="2" align="center" colwidth="1*">
	  <colspec colnum="3" align="left" colwidth="1*">
	    <TBODY>
	      <ROW>
		<ENTRY>tx</ENTRY><ENTRY>=</ENTRY><ENTRY>0.2x</ENTRY>
	      </ROW>
	      <ROW>
	        <ENTRY>ty</ENTRY><ENTRY>=</ENTRY><ENTRY>0.4y - 8</ENTRY>
              </ROW>
	    </TBODY>
	  </TGROUP>
        </informaltable>
 
	and so <literal>tr[0] = 0.2</literal>,
	<literal>tr[1] = 0.0</literal>, <literal>tr[2] = 0.0</literal>,
	<literal>tr[3] = 0.0</literal>, <literal>tr[4] = 0.4</literal>,
	<literal>tr[5] = -8.</literal>
      </para>

      <para>
	There are three built-in transformation functions to assist
	the user; these are:
      </para>
      
      <para>
	<funcsynopsis> 
	  <funcdef>
	    <function>pltr0</function>
	  </funcdef>
	  <paramdef><parameter>x</parameter></paramdef>
	  <paramdef><parameter>y</parameter></paramdef>
	  <paramdef><parameter>tx</parameter></paramdef>
	  <paramdef><parameter>ty</parameter></paramdef>
	  <paramdef><parameter>pltr_data</parameter></paramdef>
	</funcsynopsis>

	<funcsynopsis> 
	  <funcdef>
	    <function>pltr1</function>
	  </funcdef>
	  <paramdef><parameter>x</parameter></paramdef>
	  <paramdef><parameter>y</parameter></paramdef>
	  <paramdef><parameter>tx</parameter></paramdef>
	  <paramdef><parameter>ty</parameter></paramdef>
	  <paramdef><parameter>pltr_data</parameter></paramdef>
	</funcsynopsis>
	
	<funcsynopsis> 
	  <funcdef>
	    <function>pltr2</function>
	  </funcdef>
	  <paramdef><parameter>x</parameter></paramdef>
	  <paramdef><parameter>y</parameter></paramdef>
	  <paramdef><parameter>tx</parameter></paramdef>
	  <paramdef><parameter>ty</parameter></paramdef>
	  <paramdef><parameter>pltr_data</parameter></paramdef>
	</funcsynopsis>
      </para>
      
      <para>
        pltr0 does the identity transformation, 
pltr1 does linear interpolation in singly dimensioned coordinate arrays, and 
pltr2 does linear interpolation in doubly dimensioned coordinate arrays
(see code for details). This
	is further discussed in the following section
      </para>

    </sect2>
    
    <sect2 id="contour-plots-fortran">
      <title>Contour Plots from Fortran</title>

      <para>
	The routines mentioned above are not recommended for use directly
	from Fortran due to the need to pass a function pointer.  That is,
	the transformation function is written in C and can not generally
	be changed by the user.  The call for routine &plcontfortran; from
	Fortran is then:
      </para>

      <para>
	<funcsynopsis> 
	  <funcdef>
	    call <function>plcont</function>
	  </funcdef>
	  <paramdef><parameter>z</parameter></paramdef>
	  <paramdef><parameter>nx</parameter></paramdef>
	  <paramdef><parameter>ny</parameter></paramdef>
	  <paramdef><parameter>kx</parameter></paramdef>
	  <paramdef><parameter>lx</parameter></paramdef>
	  <paramdef><parameter>ky</parameter></paramdef>
	  <paramdef><parameter>ly</parameter></paramdef>
	  <paramdef><parameter>clevel</parameter></paramdef>
	  <paramdef><parameter>nlevel</parameter></paramdef>
	</funcsynopsis>
      </para>
      
      <para>
When called from Fortran, this routine has the same effect as when invoked
from C.  The interpretation of all parameters (see &plcont;) is also the
same except there is no transformation function supplied as the last
parameter.  Instead, a 6-element array specifying coefficients to use in the
transformation is supplied via the named common block
<literal>plplot</literal> (see code). Since this approach is somewhat
inflexible, the user is recommended to call either of &plcon0;, &plcon1;, or
&plcon2; instead.
      </para>

      <para>
	The three routines recommended for use from Fortran are &plcon0;,
	&plcon1;, and &plcon2;.  These routines are similar to existing
	commercial plot package contour plotters in that they offer
	successively higher complexity, with &plcon0; utilizing no
	transformation arrays, while those used by &plcon1; and &plcon2;
	are one and two dimensional, respectively.  The call syntax for
	each is
      </para>
      
      <para>
	<funcsynopsis> 
	  <funcdef>
	    call <function>plcon0</function>
	  </funcdef>
	  <paramdef><parameter>z</parameter></paramdef>
	  <paramdef><parameter>nx</parameter></paramdef>
	  <paramdef><parameter>ny</parameter></paramdef>
	  <paramdef><parameter>kx</parameter></paramdef>
	  <paramdef><parameter>lx</parameter></paramdef>
	  <paramdef><parameter>ky</parameter></paramdef>
	  <paramdef><parameter>ly</parameter></paramdef>
	  <paramdef><parameter>clevel</parameter></paramdef>
	  <paramdef><parameter>nlevel</parameter></paramdef>
	</funcsynopsis>
	
	<funcsynopsis> 
	  <funcdef>
	    call <function>plcon1</function>
	  </funcdef>
	  <paramdef><parameter>z</parameter></paramdef>
	  <paramdef><parameter>nx</parameter></paramdef>
	  <paramdef><parameter>ny</parameter></paramdef>
	  <paramdef><parameter>kx</parameter></paramdef>
	  <paramdef><parameter>lx</parameter></paramdef>
	  <paramdef><parameter>ky</parameter></paramdef>
	  <paramdef><parameter>ly</parameter></paramdef>
	  <paramdef><parameter>clevel</parameter></paramdef>
	  <paramdef><parameter>nlevel</parameter></paramdef>
	  <paramdef><parameter>xg1</parameter></paramdef>
	  <paramdef><parameter>yg1</parameter></paramdef>
	</funcsynopsis>
	
	<funcsynopsis> 
	  <funcdef>
	    call <function>plcon2</function>
	  </funcdef>
	  <paramdef><parameter>z</parameter></paramdef>
	  <paramdef><parameter>nx</parameter></paramdef>
	  <paramdef><parameter>ny</parameter></paramdef>
	  <paramdef><parameter>kx</parameter></paramdef>
	  <paramdef><parameter>lx</parameter></paramdef>
	  <paramdef><parameter>ky</parameter></paramdef>
	  <paramdef><parameter>ly</parameter></paramdef>
	  <paramdef><parameter>clevel</parameter></paramdef>
	  <paramdef><parameter>nlevel</parameter></paramdef>
	  <paramdef><parameter>xg2</parameter></paramdef>
	  <paramdef><parameter>yg2</parameter></paramdef>
	</funcsynopsis>
      </para>
      
      <para>
	The &plcon0; routine is implemented via a call to &plcont; with a
	very simple (identity) transformation function, while &plcon1; and
	&plcon2; use interpolating transformation functions as well as
	a call to
	&plcont;.
      </para>

      <para>
	The transformation arrays are used by these routines to specify a
	mapping between the computational coordinate system and the
	physical one.  For example, the transformation to polar coordinates
	might look like:
      </para>
      
      <para>
	<programlisting>
    do i = 1, NX
        do j = 1, NY
            xg(i, j) = r(i) * cos( theta(j) )
            yg(i, j) = r(i) * sin( theta(j) )
        enddo
    enddo<!--
   --></programlisting>
      </para>

      <para>
	assuming the user had already set up arrays <literal>r</literal>
	and <literal>theta</literal> to specify the (r, &theta;) values at
	the gridpoints in his system.  For this example, it is recommended
	that the user add an additional cell in theta such that
	<literal>xg(i, NY+1) = xg(i, 1)</literal> and <literal>yg(i, NY+1)
	= yg(i, 1)</literal> so that the contours show the proper periodic
	behavior in &theta; (see also example program 9).
      </para>

      <para>
	The transformation function not only specifies the transformation
	at grid points, but also at intermediate locations, via linear
	interpolation.  For example, in the <literal>pltr1</literal>
	transformation function used by &plcon1;, the 1-d interpolation to
	get <literal>tx</literal> as a function of <literal>x</literal>
	looks like (in C):
      </para>
      
      <para>
	<programlisting>
    ul = (PLINT)x;
    ur = ul + 1;
    du = x - ul;

    xl = *(xg+ul);
    xr = *(xg+ur);

    *tx = xl * (1-du)  +  xr * du;<!--
   --></programlisting>
      </para>

      <para>
	while in Fortran this might look like:
      </para>

      <para>
	<programlisting>
    lxl = x
    lxr = lxl + 1
    dx = x - lxl

    xl = xg(lxl)
    xr = xg(lxr)

    tx = xl * (1-dx)  +  xr * dx<!--
   --></programlisting>
      </para>

    </sect2>

  </sect1>

</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:2
sgml-indent-data:t
sgml-default-dtd-file:nil
sgml-exposed-tags:nil
sgml-local-ecat-files:nil
sgml-doctype:"plplotdoc.sgml"
End:
-->
