<!-- -*-  mode: nxml -*- -->
<!--
    fortran95.xml: "Fortran Language" chapter

Copyright (C) 1994  Geoffrey Furnish and Maurice LeBrun
Copyright (C) 1999, 2000, 2001, 2002, 2003  Rafael Laboissiere
Copyright (C) 1999-2016 Alan W. Irwin
Copyright (C) 2003  Joao Cardoso

Redistribution and use in source (XML DocBook) and "compiled" forms
(HTML, PDF, PostScript, DVI, TeXinfo and so forth) with or without
modification, are permitted provided that the following conditions are
met:

1. Redistributions of source code (XML DocBook) must retain the
above copyright notice, this list of conditions and the following
disclaimer as the first lines of this file unmodified.

2. Redistributions in compiled form (transformed to other DTDs,
converted to HTML, PDF, PostScript, and other formats) must
reproduce the above copyright notice, this list of conditions and
the following disclaimer in the documentation and/or other
materials provided with the distribution.

Important: THIS DOCUMENTATION IS PROVIDED BY THE PLPLOT PROJECT "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE PLPLOT PROJECT BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS DOCUMENTATION,
EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->

<chapter id="fortran95">
  <title>Fortran Language</title>
  <para>
    The Fortran binding to PLplot takes full advantage of the <literal>ISO_C_BINDING</literal> feature of
    the Fortran 2003 standard, which is supported by all current compilers.  The advantage
    of this is that the entire binding is now written in Fortran, so that there is only
    one library that you need to link against.  Furthermore, the binding defines
    routines for both single and double precision.  A program can therefore use
    single and double precision variables and only one version of the PLplot library is
    required.  There are a few limitations, however, which are discussed below.
  </para>
  <para>
    Note: in this chapter <quote>Fortran</quote> stands for <quote>Fortran as defined by the Fortran 2003 standard</quote>. Older
    versions of PLplot supported FORTRAN 77, but the binding for this 40 years old version has been
    abandoned for quite a few years now.  As we now use features from the Fortran 2003 standard,
    it is no longer appropriate to refer to the language as Fortran 95.
  </para>
  <para>
    Because the PLplot kernel is written in C, standard C syntax is used in the
    description of each PLplot function.  Thus to understand this manual it is
    helpful to know a little about C, but fortunately the translation is very
    easy and can be summarized here.  As an example, the routine
    &plline; call from C would look like:
    <programlisting>
      plline(n,x,y);
    </programlisting>
    The argument <literal>n</literal> is the number of points that make
    up the line and the arguments <literal>x</literal> and <literal>y</literal>
    are arrays of floating-point numbers containing the x- and y-coordinates of the
    points.
  </para>
  <para>
    In C you need to specify the array dimensions explicitly, whereas in
    Fortran (from Fortran 90 onwards) the array dimension can be implicit, which leads to less
    mistakes. The interface to <literal>plline</literal> therefore looks
    like this:
    <programlisting>
      integer, parameter :: wp = &lt;the kind for single precision reals or double precision reals&gt;

      interface
        subroutine plline(x,y)
          real(wp), dimension(:) :: x, y
        end subroutine plline
      end interface
    </programlisting>

  </para>
  <para>
    The limitation is that the same precision must be used for both the <literal>x</literal> and
    <literal>y</literal> arrays, just they should have the same size.  The compiler takes care of
    invoking the right version of the <literal>plline</literal> routines.  This is true in general:
    all <literal>real</literal> arguments to a PLplot subroutine should be either single precision
    or double precision.
  </para>
  <para>
    Note that this <quote>duality</quote> applies only to the <literal>real</literal> arguments, not
    to <literal>integer</literal>, <literal>logical</literal> or <literal>character string</literal>
    arguments.
  </para>
  <para>
    To help with the interpretation of the C API, here is a short overview of how C data types correspond
    to Fortran
    data types:
    <informaltable frame="none" pgwide="0">
      <tgroup align="center" cols="2">
	<colspec colnum="1" align="center" colwidth="1*"/>
	<colspec colnum="2" align="center" colwidth="1*"/>
	<tbody>
	  <row>
	    <entry>PLFLT</entry><entry>real(kind=plflt)</entry>
	  </row>
	  <row>
	    <entry>PLINT</entry><entry>integer</entry>
	  </row>
	  <row>
	    <entry>PLBOOL</entry><entry>logical</entry>
	  </row>
	  <row>
	    <entry>char *</entry><entry>character</entry>
	  </row>
	  <row>
	    <entry>PLFLT *</entry><entry>real(kind=plflt) or real(kind=plflt), dimension(:)</entry>
	  </row>
	  <row>
	    <entry>PLFLT **</entry><entry>real(kind=plflt), dimension(:,:)</entry>
	  </row>
	  <row>
	    <entry><literal>"string"</literal></entry><entry><literal>'string'</literal></entry>
	  </row>
	  <row>
	    <entry>array[0]</entry><entry>array(1)</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>
    In C there are two ways to pass a variable --- by value (the default) or by
    reference (pointer), whereas in Fortran this difference is not visible in the
    call, only in the interface definition via the <literal>value</literal> attribute.
    Therefore when you see references in the text to <emphasis>either</emphasis> an ordinary
    argument or a pointer argument (e.g.  <literal>*data</literal>), you simply use an
    ordinary Fortran variable or array name.  The interfacing
    routines take care of any transformations that may be necessary.
  </para>
  <para>
    The PLplot library comes with a set of Fortran interface routines that
    allow the same call semantics (usually) regardless of whether calling
    from C or Fortran.  In some cases, the Fortran interface uses
    implicit array dimensions, so that it has fewer arguments than the C
    counterpart.
  </para>
  <para>
    These <quote>stub</quote> routines handle transforming the data
    from the normal Fortran representation to that typically used in C.  Just to give
    an impression, here is an explanation of one such routine:
  </para>
  <para>
    In the Fortran program there might be a call to <literal>plpoin</literal>:
    <programlisting>
      real(kind=pllft), dimension(6) :: x, y
      x = ...
      y = ...
      call plpoin(x,y,9)
    </programlisting>
    where <literal>x</literal> and <literal>y</literal> are arrays with 6 elements and the points are to be
    plotted using symbol 9. The routine <literal>plpoin_impl</literal>, which is the actual routine called,
    is implemented as follows:
    <programlisting>
    subroutine plpoin_impl( x, y, code )
      integer, intent(in) :: code
      real(kind=wp), dimension(:), intent(in) :: x, y

      interface
        subroutine interface_plpoin( n, x, y, code ) bind(c,name='c_plpoin')
          import :: private_plint, private_plflt
          implicit none
          integer(kind=private_plint), value, intent(in) :: n, code
          real(kind=private_plflt), dimension(*), intent(in) :: x, y
        end subroutine interface_plpoin
      end interface

       call interface_plpoin( size(x,kind=private_plint), real(x,kind=private_plflt), &amp;
                              real(y,kind=private_plflt), int(code,kind=private_plint) )
    end subroutine plpoin_impl
    </programlisting>
    The size of the arrays, that is the number of points to be plotted, is passed on via the
    <literal>size()</literal> intrinsic function.  The intrinsic function <literal>real()</literal>
    is used to convert the data in the arrays <literal>x</literal> and <literal>y</literal> to
    the precision actually used by the C library (represented as <literal>private_plflt</literal>).
    And finally, the intrinsic function <literal>int()</literal> is used to do the same for
    the integer argument.
  </para>
  <para>
    Since the <literal>code</literal> argument to the routine <literal>interface_plpoin</literal>
    has the <literal>value</literal> attribute, the C routine gets the value, not the memory address
    of the argument.
  </para>
  <para>
    In the above code the kind <literal>wp</literal> is either the single precision kind or the double
    precision kind:
    <programlisting>
    module plplot_single
      ...
      integer, parameter :: wp = private_single
      private :: wp

      interface plpoin
        module procedure plpoin_impl
    contains
      ...
    subroutine plpoin_impl( x, y, code )
      ...
    end subroutine plpoin_impl
    end module plplot_single
    </programlisting>
    And similarly for the double precision version.
  </para>
  <para>
    In this way the PLplot API has been made accessible from Fortran.  The C binding features of the
    compiler hide the complexities of the name mangling that occurs.
  </para>
  <para>
    There are a few limitations and exceptions that one must be aware of with regards to the dual
    precision interface:
    <itemizedlist>
      <listitem><para>
        The <literal>plrandd()</literal> function takes no arguments, so the Fortran rules cannot distinguish
        between a version returning a single-precision value and one returning a double-precision value.
        For this reason only a double-precision version is available, though you can use
        <literal>plrandd_single()</literal> explicitly for single-precision random numbers.
      </para></listitem>
      <listitem><para>
        For the various callback routines, <literal>pltransform()</literal>
        and <literal>pllabelfunc()</literal>, only the double-precision version is made available. The
        reason for this is a technical one. The current Fortran standard does not distinguish procedure
        arguments based on their argument list. Therefore it is not possible to define the routine
        <literal>plstransform</literal> in two versions.
      </para></listitem>
      <listitem><para>
        PLplot defines a small number of auxiliary real parameters, PL_PI, PL_TWOPI and PL_NOTSET.
        To use these in the correct precision, define a local parameter (see for instance example x31f):
        <programlisting>
        use plplot
        real(kind=myprec), parameter :: NOTSET = PL_NOTSET
        </programlisting>
        These parameters are defined as double precision.
      </para></listitem>
    </itemizedlist>
  </para>
  <para>
    For more information on calling PLplot from Fortran 95, please see the
    example Fortran 95 programs (<filename>/examples/f95/x??f.f</filename>)
    distributed
    with PLplot.
  </para>
</chapter>
