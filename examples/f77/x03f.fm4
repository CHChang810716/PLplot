divert(-1)dnl
!***********************************************************************
! $Id$
! $Log$
! Revision 1.2  2000/12/24 19:02:28  airwin
! For these m4 source files remove DBLE (a poorly chosen name) and replace
! with REAL_FUN.  REAL_FUN is applied to constants and expressions that are
! surrounded by parentheses.  It gets replaced by real if single precision and
! by dble if double precision.
!
! Revision 1.1  2000/12/23 23:19:24  airwin
! Double precision handled by m4. These are the m4 source files for the *.f
! files that are compiled for examples.  m4 source is fairly close to
! old version of the *.f file, but with a header prepended, and REAL,
! implicit_none, and DBLE translated appropriately.  In particular the
! implicit_none demanded a lot of changes in these examples, and
! single-precision arguments to plplot routines were converted using
! DBLE (which translates to dble or real depending on DOUBLE).
!
! Revision 1.2  1994/05/26 19:34:16  mjl
! Inserted missing CVS Id and Log fields for all Fortran demos.  Comment
! character changed to "!" everywhere, to work well with font-lock in Lucid
! emacs (requires a small change to fortran-mode.el).
!
!
      program example03
!     =================
!
!***********************************************************************
! Uses implicit_none, REAL, and REAL_FUN from fmacs.m4.
divert(1)dnl
include(fmacs.m4)dnl
! Illustration of 1-1 scaling for polar plot
      implicit_none

      character*3 text
      REAL x0(0:360), y0(0:360)
      REAL x(0:360), y(0:360), dtr, theta, dx, dy, r
      integer i, j, nsp

      dtr = 3.141592654/180.0
      do 1 i=0,360
        x0(i) = cos(dtr * REAL_FUN (i))
        y0(i) = sin(dtr * REAL_FUN (i))
    1 continue

! Ask user to specify the output device.

      call plinit()

! Set up viewport and window, but do not draw box

      call plenv(REAL_FUN (-1.3), REAL_FUN (1.3), REAL_FUN (-1.3),
     &  REAL_FUN (1.3), 1, -2)
      do 2 i = 1,10
        do 3 j = 0,360
          x(j) = 0.1*i*x0(j)
          y(j) = 0.1*i*y0(j)
    3   continue

! Draw circles for polar grid

        call plline(361,x,y)
    2 continue

      call plcol(2)
      do 4 i = 0,11
        theta = 30.0*i
        dx = cos(dtr*theta)
        dy = sin(dtr*theta)

! Draw radial spokes for polar grid

        call pljoin(REAL_FUN (0.0), REAL_FUN (0.0), dx, dy)
        write (text,'(i3)') nint(theta)

! Write labels for angle

        text = text(nsp(text):)
        if (dx.ge.0) then
          call plptex(dx, dy, dx, dy, REAL_FUN (-0.15), text)
        else
          call plptex(dx, dy, -dx, -dy, REAL_FUN (1.15), text)
        end if
    4 continue

! Draw the graph

      do 5 i=0,360
        r = sin(dtr*REAL_FUN (5*i))
        x(i) = x0(i) * r
        y(i) = y0(i) * r
    5 continue
      call plcol(3)
      call plline(361,x,y)

      call plcol(4)
      call plmtex
     &  ('t', REAL_FUN (2.0), REAL_FUN (0.5), REAL_FUN (0.5), 
     &  '#frPLPLOT Example 3 - r(#gh)=sin 5#gh')

! Close the plot at end

      call plend
      end

      integer function nsp(text)
!     ==================

! Find first non-space character
      implicit_none

      character*(*) text
      integer l, len

      l = len (text)
      nsp = 1
    1 if (text(nsp:nsp).eq.' ' .and. nsp.lt.l) then
        nsp = nsp+1
        goto 1
      end if
      end
