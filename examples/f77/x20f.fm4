c $Id$
c
c      Copyright (C) 2004  Alan W. Irwin
c      Copyright (C) 2008  Andrew Ross
c
c      This file is part of PLplot.
c
c      PLplot is free software; you can redistribute it and/or modify
c      it under the terms of the GNU Library General Public License as
c      published by the Free Software Foundation; either version 2 of the
c      License, or (at your option) any later version.
c
c      PLplot is distributed in the hope that it will be useful,
c      but WITHOUT ANY WARRANTY; without even the implied warranty of
c      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
c      GNU Library General Public License for more details.
c
c      You should have received a copy of the GNU Library General Public
c      License along with PLplot; if not, write to the Free Software
c      Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
c
c
c      plimage demo
c
c

cstatic PLOptionTable options[] = {
c{
c    "dbg",			/* extra debugging plot */
c    NULL,
c    NULL,
c    &dbg,
c    PL_OPT_BOOL,
c    "-dbg",
c    "Extra debugging plot" },
c{
c    "nosombrero",			/* Turns on test of xor function */
c    NULL,
c    NULL,
c    &nosombrero,
c    PL_OPT_BOOL,
c    "-nosombrero",
c    "No sombrero plot" },
c{
c    "nointeractive",			/* Turns on test of xor function */
c    NULL,
c    NULL,
c    &nointeractive,
c    PL_OPT_BOOL,
c    "-nointeractive",
c    "No interactive selection" },
c{
c    "save",			/* For saving in postscript */
c    NULL,
c    NULL,
c    &f_name,
c    PL_OPT_STRING,
c    "-save filename",
c      "Save sombrero plot in color postscript `filename'" },
c{
c    NULL,			/* option */
c    NULL,			/* handler */
c    NULL,			/* client data */
c    NULL,			/* address of variable to set */
c    0,				/* mode flag */
c    NULL,			/* short syntax */
c    NULL }			/* long syntax */
c};

      program x20f
      implicit none

      integer XDIM, YDIM
      real*8  XDIMR, YDIMR
      parameter(XDIM = 260, YDIM = 220)
      parameter(XDIMR = XDIM, YDIMR = YDIM)
      include 'plplot_parameters.h'

      real*8  x(XDIM), y(YDIM), z(XDIM,YDIM), r(XDIM,YDIM)
      real*8  xi, yi, xe, ye
      integer i, j
      real*8  width_r, height_r

c
c     Dimensions taken from "lena.pgm"
c
      integer width, height, num_col, WDIM, HDIM
      parameter (WDIM = 500)
      parameter (HDIM = 500)
      data width, height / 500, 500/
      real*8  img_f(WDIM,HDIM)
      real*8  xg(WDIM+1,HDIM+1), yg(WDIM+1,HDIM+1)
      real*8 img_max, img_min

      real*8 x0, y0, dy, stretch

      logical  read_img
      external read_img

      logical  get_clip
      external get_clip

c
c     Parameters from command-line
c
      logical dbg
      logical nosombrero
      logical nointeractive
      character*80 f_name

c
c     Bugs in plimage():
c      -at high magnifications, the left and right edge are ragged, try
c         ./x20c -dev xwin -wplt 0.3,0.3,0.6,0.6 -ori 0.5
c
c     Bugs in x20c.c:
c      -if the window is resized after a selection is made on 'lena', when
c       making a new selection the old one will re-appear.
c
c
c     Parse and process command line arguments
c
c      call plMergeOpts(options, 'x20c options', NULL)

      dbg            = .false.
      nosombrero     = .false.
      nointeractive  = .false.
      f_name         = ' '
      call plparseopts(PL_PARSE_FULL)

c     Initialize plplot

      call plinit

c     View image border pixels
      if (dbg) then
          call plenv(1.d0, XDIMR, 1.d0, YDIMR, 1, 1)

c         Build a one pixel square border, for diagnostics
          do 110 i = 1,XDIM
c             Right
              z(i,YDIM) = 1.d0
c             Left
              z(i,1)    = 1.d0
  110     continue

          do 120 i = 1,YDIM
c             Top
              z(1,i)    = 1.d0
c             Bottom
              z(XDIM,i) = 1.d0
  120     continue

          call pllab('...around a blue square.',' ',
     &        'A red border should appear...')

          call plimage(z, XDIM, YDIM,
     &     1.d0, XDIMR, 1.d0, YDIMR, 0.d0, 0.d0,
     &     1.d0, XDIMR, 1.d0, YDIMR, XDIM)
      endif

c     Sombrero-like demo
      if (.not. nosombrero) then
c         draw a yellow plot box, useful for diagnostics! :(
          call plcol0(2)
          call plenv(0.d0, 2.d0*PI, 0.0d0, 3.d0*PI, 1, -1)

          do 210 i=1,XDIM
              x(i) = dble(i-1)*2.d0*PI/dble(XDIM-1)
  210     continue
          do 220 i=1,YDIM
            y(i) = dble(i-1)*3.d0*PI/dble(YDIM-1)
  220     continue

          do 240 i=1,XDIM
              do 230 j=1,YDIM
                  r(i,j) = sqrt(x(i)*x(i)+y(j)*y(j))+1.d-3
                  z(i,j) = sin(r(i,j)) / (r(i,j))
  230         continue
  240     continue

          call pllab('No, an amplitude clipped "sombrero"', '',
     &        'Saturn?')
          call plptex(2.d0, 2.d0, 3.d0, 4.d0, 0.d0, 'Transparent image')
          call plimage(z, XDIM, YDIM, 0.d0, 2.d0*PI, 0.0d0, 3.d0*PI,
     &        0.05d0, 1.d0, 0.d0, 2.d0*PI, 0.d0, 3.d0*PI, XDIM)

c         Save the plot
          if (f_name .ne. ' ') then
              call save_plot(f_name)
          endif
      endif

c
c     Read Lena image
c     Note we try two different locations to cover the case where this
c     examples is being run from the test_c.sh script
c
      if (.not. read_img('lena.pgm', img_f, width, height,
     &           num_col)) then
          if (.not. read_img('../lena.pgm', img_f, width, height,
     &           num_col)) then
cC            call plabort('No such file')
              write(*,*) 'Image could not be read'
              call plend()
              stop
          endif
      endif

c     Set gray colormap
      call gray_cmap(num_col)

c     Display Lena
      width_r  = dble(width)
      height_r = dble(height)
      call plenv(1.d0, width_r, 1.d0, height_r, 1, -1)

      if (.not. nointeractive) then
          call pllab('Set and drag Button 1 to (re)set selection, '//
     &        'Button 2 to finish.',' ','Lena...')
      else
          call pllab('',' ','Lena...')
      endif

      call plimage(img_f, width, height, 1.d0, width_r, 1.d0,
     &    height_r, 0.d0, 0.d0, 1.d0, width_r, 1.d0, height_r, WDIM)


c     Selection/expansion demo
      if (.not. nointeractive) then
          xi = 200.0d0
          xe = 330.0d0
          yi = 280.0d0
          ye = 220.0d0

          if (get_clip(xi, xe, yi, ye)) then
              call plend()
              call exit(0)
          endif

c
c         I'm unable to continue, clearing the plot and advancing to the next
c         one, without hiting the enter key, or pressing the button... help!
c         Forcing the xwin driver to leave locate mode and destroying the
c         xhairs (in GetCursorCmd()) solves some problems, but I still have
c         to press the enter key or press Button-2 to go to next plot, even
c         if a pladv() is not present!  Using plbop() solves the problem, but
c         it shouldn't be needed!
c
c         plspause(0), pladv(0), plspause(1), also works,
c         but the above question remains.
c         With this approach, the previous pause state is lost,
c         as there is no API call to get its current state.
c

          call plspause(0)
          call pladv(0)

c         Display selection only
          call plimage(img_f, width, height, 1.d0, width_r, 1.d0,
     &        height_r, 0.d0, 0.d0, xi, xe, ye, yi, WDIM)

          call plspause(1)

c         Zoom in selection
          call plenv(xi, xe, ye, yi, 1, -1)
          call plimage(img_f, width, height, 1.d0, width_r, 1.d0,
     &        height_r, 0.d0, 0.d0, xi, xe, ye, yi, WDIM)
      endif

c     Base the dynamic range on the image contents.

      call a2mnmx(img_f,width,height,img_min,img_max,WDIM)

      call plcol0(2)
      call plenv(0.d0, width_r, 0.d0, height_r, 1, -1)
      call pllab("", "", "Reduced dynamic range image example")
      call plimagefr0(img_f, width, height, 0.d0, width_r, 0.d0,
     &     height_r, 0.d0, 0.d0, img_min + img_max * 0.25d0,
     &     img_max - img_max * 0.25d0, WDIM)

c     Draw a distorted version of the original image, showing its
c     full dynamic range.
      call plenv(0.d0, width_r, 0.d0, height_r, 1, -1)
      call pllab("", "", "Distorted image example")

c     Populate the 2-d grids used for the distortion
c     NB grids must be 1 larger in each dimension than the image
c     since the coordinates are for the corner of each pixel.
      x0 = 0.5d0*width_r
      y0 = 0.5d0*height_r
      dy = 0.5d0*height_r
      stretch = 0.5d0
      do i=1,width+1
         do j=1,height+1
            xg(i,j) = x0 + (x0-dble(i-1))*(1.0d0 - stretch*
     &           cos((dble(j-1)-y0)/dy*PI*0.5d0))
            yg(i,j) = dble(j-1)
         enddo
      enddo
      call plimagefr2(img_f, width, height, 0.d0, width_r, 0.d0,
     &     height_r, 0.d0, 0.d0, img_min, img_max, xg, yg, WDIM)

      call plend()

      end

c     Determine the unit of length for direct-access files
      subroutine bytes_in_rec( bytes )
      implicit none
      integer     bytes

      character*8 string
      integer     i

      open( 10, file = '_x20f_.bin', access = 'direct', recl = 1 )
      do 110 i = 1,8
          write( 10, rec = 1, err = 120 ) string(1:i)
          bytes = i
  110 continue

  120 continue
      close( 10, status = 'delete' )

      end

c     Read image from file in binary ppm format
      logical function read_img(fname, img_f, width, height, num_col)
      implicit none
      character(*) fname
      integer      width, height
      real*8       img_f(width,height)
      integer      num_col

      character    img(8)
      character*80 ver
      integer      i, j, k, w, h, b

      integer      ierr
      integer      count
      integer      record

      integer      bytes
      integer      lastlf
      integer      first
      integer      last
      integer      pixel

c     Naive grayscale binary ppm reading. If you know how to, improve it

      open( 10, file = fname, status = 'old', iostat = ierr )

      if (ierr .ne. 0 ) then
          read_img = .false.
          return
      endif

c
c     Read the first lines (count them for later re-reading)
c
      count = 1
      read( 10, '(a)', iostat = ierr ) ver

c     I only understand "P5"!
      if (ver .ne. 'P5' .or. ierr .ne. 0) then
          read_img = .false.
          return
      endif

  100 continue
      count = count + 1
      read( 10, '(a)', iostat = ierr ) ver

      if (ierr .ne. 0) then
          read_img = .false.
          write(*,*) 'Error!'
          return
      endif

      if (ver(1:1) .eq. '#' ) goto 100

c     Found the line with the sizes, copy this one and the next

      open( 11, file = '_x20f_.bin' )
      write( 11, '(a)' ) ver

      count = count + 1
      read( 10, '(a)', iostat = ierr ) ver
      write( 11, '(a)' ) ver

      close( 11 )
      open( 11, file = '_x20f_.bin' )
      read( 11, * ) w, h, num_col

      if ( w*h .gt. width*height ) then
          write(*,*) 'Picture size too large: width = ',w,
     &        'height =', h
          read_img = .false.
          return
      endif

      close( 10 )
      close( 11, status = 'delete' )

c
c     Read the second part - we need to do it the hard way :(
c
c     Note:
c     The algorithm works if the unit of record length is a byte or
c     if it is a multiple therefore (up to 8 bytes are allowed).
c     Background: Some compilers use a word (4 bytes) as the unit of
c     length instead, but often provide a compile switch to use bytes,
c     we can not rely on this though.
c
      call bytes_in_rec( bytes )

      open( 10, file = fname, access = 'direct', recl = 1 )

      record = 0
  200 continue
c
c     Look for the end of the line with sizes
c
      record = record + 1
      read( 10, rec = record ) (img(i), i = 1,bytes )

      do 210 i = 1,bytes
          if ( img(i) .eq. char(10) ) then
              count = count - 1
              lastlf = i
          endif
  210 continue
      if ( count .gt. 0 ) goto 200

c
c     We have found the picture bytes!
c     The picture needs to be flipped vertically.
c     So do that rightaway
c
c
      first = lastlf + 1
      last  = bytes
      pixel = 0

  220 continue
      do 230 b = first, last
          pixel = pixel + 1
          if ( pixel .le. h*w ) then
              i     = 1 + mod(pixel-1,w)
              j     = 1 + (pixel-1)/w
              img_f(i,h-j+1) = dble(ichar(img(b)))
          endif
  230 continue
      if ( pixel .lt. h*w ) then
          record = record + 1
          read( 10, rec = record ) (img(b), b = 1,bytes )
          first  = 1
          goto 220
      endif

      width  = w
      height = h
      read_img = .true.

      end

c     Save plot
      subroutine save_plot(fname)
      implicit none
      character*(*) fname

      integer cur_strm, new_strm

c     Get current stream
      call plgstrm(cur_strm)

c     Create a new one
      call plmkstrm(new_strm)

c     New device type. Use a known existing driver
      call plsdev('psc')
      call plsfnam(fname)

c     Copy old stream parameters to new stream
      call plcpstrm(cur_strm, 0)
      call plreplot()
      call plend1()

c     Return to previous one
      call plsstrm(cur_strm)

      end

c     Get selection square interactively
      logical function get_clip(xi, xe, yi, ye)
      implicit none
      real*8 xi, xe, yi, ye

c      PLGraphicsIn gin
      integer gin
      real*8 xxi, yyi, xxe, yye, t
      logical st, start
      real*8 sx(5), sy(5)

      xxi = xi
      yyi = yi
      xxe = xe
      yye = ye
      start = .false.

c     Enter xor mode to draw a selection rectangle
      call plxormod(1, st)

c     Driver has xormod capability, continue
      if (st) then
  100     continue

          call plxormod(0, st)
cC        call plGetCursor(gin)
          call plxormod(1, st)

cC         if (gin.button == 1) {
cC             xxi = gin.wX
cC             yyi = gin.wY
              if (start) then
cC                clear previous rectangle
                  call plline(5, sx, sy)
              endif

              start = .false.

              sx(1) = xxi
              sy(1) = yyi
              sx(5) = xxi
              sy(5) = yyi
cC         endif

cC         if (gin.state & 0x100) then
cC             xxe = gin.wX
cC             yye = gin.wY
              if (start) then
c                 Clear previous rectangle
                  call plline(5, sx, sy)
              endif
              start = .true.

              sx(3) = xxe
              sy(3) = yye
              sx(2) = xxe
              sy(2) = yyi
              sx(4) = xxi
              sy(4) = yye
c             Draw new rectangle
              call plline(5, sx, sy)
cC         endif

cC         if (gin.button == 3 || gin.keysym == PLK_Return || gin.keysym == 'Q') then
              if (start) then
c                 Clear previous rectangle
                  call plline(5, sx, sy)
                  goto 110
              endif
cC         endif

  110     continue
c         Leave xor mode
          call plxormod(0, st)

          if (xxe .lt. xxi) then
              t   = xxi
              xxi = xxe
              xxe = t
          endif

          if (yyi .lt. yye) then
              t   = yyi
              yyi = yye
              yye = t
          endif

          xe = xxe
          xi = xxi
          ye = yye
          yi = yyi

cC         get_clip = gin.keysym == 'Q'
          get_clip = .false.
      else
c         driver has no xormod capability, just do nothing
          get_clip = .false.
          return
      endif

      end

c     Set gray colormap
      subroutine gray_cmap(num_col)
      implicit none
      integer num_col
      real*8 r(2), g(2), b(2), pos(2)
      integer rev(2)

      r(1) = 0.0
      g(1) = 0.0
      b(1) = 0.0
      r(2) = 1.0
      g(2) = 1.0
      b(2) = 1.0

      pos(1) = 0.0
      pos(2) = 1.0

      rev(1) = 0
      rev(2) = 0

      call plscmap1n(num_col)
      call plscmap1l(1, 2, pos, r, g, b, rev)

      end

c----------------------------------------------------------------------------
c      Subroutine a2mmx
c      Minimum and the maximum elements of a 2-d array.

      subroutine a2mnmx(f, nx, ny, fmin, fmax, xdim)
      implicit none

      integer   i, j, nx, ny, xdim
      real*8    f(xdim, ny), fmin, fmax

      fmax = f(1, 1)
      fmin = fmax
      do j = 1, ny
        do  i = 1, nx
          fmax = max(fmax, f(i, j))
          fmin = min(fmin, f(i, j))
        enddo
      enddo
      end
