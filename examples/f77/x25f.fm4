C $Id$
C
C   Filling and clipping polygons.
C
C
C --------------------------------------------------------------------------
C main
C
C Test program for filling polygons and proper clipping
C --------------------------------------------------------------------------

      program x25f

      implicit none

      integer PL_PARSE_FULL
      parameter(PL_PARSE_FULL = 1)

      integer i
      integer j
      integer npts
      real*8 xextreme(2,10)
      real*8 yextreme(2,10)
      real*8 x0(10)
      real*8 y0(10)

      data ( xextreme(1,i), xextreme(2,i), yextreme(1,i), yextreme(2,i),
     &         i=1,9) /
     &              -120.0,         120.0,        -120.0,         120.0,
     &              -120.0,         120.0,          20.0,         120.0,
     &              -120.0,         120.0,         -20.0,         120.0,
     &               -80.0,          80.0,         -20.0,         120.0,
     &              -220.0,        -120.0,        -120.0,         120.0,
     &               -20.0,          20.0,        -120.0,         120.0,
     &               -20.0,          20.0,         -20.0,          20.0,
     &               -80.0,          80.0,         -80.0,          80.0,
     &                20.0,         120.0,        -120.0,         120.0/

      npts = 0

C  Parse and process command line arguments

      call plparseopts(PL_PARSE_FULL)

C  Initialize plplot

      call plssub(3,3)
      call plinit()


      do 120 j = 1,4

          if ( j .eq. 1 ) then
C  Polygon 1: a diamond
              x0(1) =    0 ; y0(1) = -100
              x0(2) = -100 ; y0(2) =    0
              x0(3) =    0 ; y0(3) =  100
              x0(4) =  100 ; y0(4) =    0
              npts = 4
          endif
          if ( j .eq. 2 ) then
C  Polygon 1: a diamond - reverse direction
              x0(4) =    0 ; y0(4) = -100
              x0(3) = -100 ; y0(3) =    0
              x0(2) =    0 ; y0(2) =  100
              x0(1) =  100 ; y0(1) =    0
              npts = 4
          endif
          if ( j .eq. 3 ) then
C  Polygon 2: a square with punctures
              x0(1)  = -100 ; y0(1)  = -100
              x0(2)  = -100 ; y0(2)  =  -80
              x0(3)  =   80 ; y0(3)  =    0
              x0(4)  = -100 ; y0(4)  =   80
              x0(5)  = -100 ; y0(5)  =  100
              x0(6)  =  -80 ; y0(6)  =  100
              x0(7)  =    0 ; y0(7)  =   80
              x0(8)  =   80 ; y0(8)  =  100
              x0(9)  =  100 ; y0(9)  =  100
              x0(10) =  100 ; y0(10) = -100
              npts = 10
          endif
          if ( j .eq. 4 ) then
C  Polygon 2: a square with punctures - reversed direction 
              x0(10) = -100 ; y0(10) = -100
              x0(9)  = -100 ; y0(9)  =  -80
              x0(8)  =   80 ; y0(8)  =    0
              x0(7)  = -100 ; y0(7)  =   80
              x0(6)  = -100 ; y0(6)  =  100
              x0(5)  =  -80 ; y0(5)  =  100
              x0(4)  =    0 ; y0(4)  =   80
              x0(3)  =   80 ; y0(3)  =  100
              x0(2)  =  100 ; y0(2)  =  100
              x0(1)  =  100 ; y0(1)  = -100
              npts = 10
          endif

          do 110 i = 1,9
              call pladv(0)
              call plvsta()
              call plwind(xextreme(1,i), xextreme(2,i),
     &                    yextreme(1,i), yextreme(2,i))

              call plcol0(2)
              call plbox('bc', 1.0d0, 0, 'bcnv', 10.0d0, 0)
              call plcol0(1)
              call plpsty(0)
              call plfill(npts,x0,y0)
              call plcol0(2)
              call pllsty(1)
              call plline(npts,x0,y0)
  110     continue
  120 continue

C  Don't forget to call plend() to finish off!

      call plend()
      end
