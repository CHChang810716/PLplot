#!xtk04 -f
# Maurice LeBrun                     -*-tcl-*-
# 30 Jun 1994
#
# @> A script illustrating use of 2-d tcl api (plframe).
#
# $Id$
#
# $Log$
# Revision 1.1  1994/10/10 17:23:50  furnish
# Tk script to show off new 2-d plframe API.
#
###############################################################################

wm title . "tk04"
plstdwin .

###############################################################################
# Set up the menubar and message widgets.

frame .menu -relief raised -borderwidth 3

button .menu.comp -text "Compute Function" -command "compute"
button .menu.contour -text "Line Contour" -command "contour"
button .menu.shade -text "Color Fill Contour" -command "shade"
pack .menu.comp .menu.contour .menu.shade -side left

button .menu.exit -text "Exit" -command "destroy ." 
pack .menu.exit -side right

message .msg \
	-font -Adobe-helvetica-medium-r-normal--*-240* -aspect 200 \
	 -width 500 -borderwidth 1 \
	-text "TK04: 2-d Tcl API"

pack .menu .msg -fill x

tk_menuBar .menu .menu.comp .menu.contour .menu.shade .menu.exit

PLXWin .plw
pack .plw -side bottom -expand 1 -fill both

matrix x f 64 64

# This is the front end to the data computation.  Initially we just
# create the matrix to hold the data, and then vector down to the C
# side to set the data.  However, one could easily embellish this to
# accept specifications from the user (via Tk entries), and act on
# them.  For instance, choosing the size of the matrix, passing
# paramaters to the compiled side, etc.

proc compute {} {

    global x

    get_data x
}

# Draw a contour of the data.

proc contour {} {

    global x

    .plw plcol 1
#    .plw plenv 0 1 0 1 0 0
    .plw plenv 1 64 1 64 0 0
    .plw plcol 6
    .plw pllab "(x)" "(y)" "#frPLplot Example Tk04"

    # plot the data points

    .plw plcol 9

    matrix clev f 10

    set max [x max]
    set min [x min]

    #puts "max = $max, min = $min"

    for {set i 0} {$i < 10} {incr i} {
	clev $i = [expr $min + ($max-$min)*($i+.5)/10 ]
    }

    .plw plcont x clev
#    .plw.plwin cmd plcont x clev
}

# This is supposed to work just like the plot1() in x01c.c

proc plot1 {w} {
    global xscale yscale xoff yoff

    set npts 60
    matrix x f $npts
    matrix y f $npts

    for {set i 0} {$i < $npts} {incr i} {
	$x $i = [expr $xoff + $xscale * ($i + 1) / $npts]
	$y $i = [expr $yoff + $yscale * pow([$x $i],2)]
    }

    set xmax [$x [expr $npts-1]]
    set ymax [$y [expr $npts-1]]

    matrix x1 f 6
    matrix y1 f 6

    for {set i 0} {$i < 6} {incr i} {
	set j [expr $i*10+3]
	$x1 $i = [$x $j]
	$y1 $i = [$y $j]
    }

    $w cmd plcol 1
    $w cmd plenv $xoff $xmax $yoff $ymax 0 0
    $w cmd plcol 6
    $w cmd pllab "(x)" "(y)" "#frPLplot Example 1 - y=x#u2"

    # plot the data points

    $w cmd plcol 9
    $w cmd plpoin 6 $x1 $y1 9

    # draw the line through the data

    $w cmd plcol 4
    $w cmd plline $npts $x $y
}

# This is supposed to work just like the plot2() in x01c.c

proc plot2 {w} {
    $w cmd plcol 1
    $w cmd plenv -2 10 -.4 1.2 0 1
    $w cmd plcol 2
    $w cmd pllab "(x)" "sin(x)/x" "#frPLplot Example 1 - Sinc Function"

    # Fill up the array

    matrix x1 f 101
    matrix y1 f 101

    for {set i 0} {$i < 101} {incr i} {
	set x [expr ($i - 19.)/6.]
	$x1 $i = $x
	$y1 $i = 1
	if {$x != 0} { $y1 $i = [expr sin($x)/$x] }
    }

    $w cmd plcol 3
    $w cmd plline 101 $x1 $y1
}

# This is supposed to work just like the plot3() in x01c.c

proc plot3 {w} {

    $w cmd pladv
    $w cmd plvsta
    $w cmd plwind 0.0 360.0 -1.2 1.2

# Draw a box with ticks spaced 60 degrees apart in X, and 0.2 in Y.

    $w cmd plcol 1
    $w cmd plbox "bcnst" 60.0 2 "bcnstv" 0.2 2

# Superimpose a dashed line grid, with 1.5 mm marks and spaces. 
# plstyl expects two integer matrices for mark and space!

    matrix mark i 1
    matrix space i 1

    $mark 0 = 1500
    $space 0 = 1500
    $w cmd plstyl 1 $mark $space

    $w cmd plcol 2
    $w cmd plbox "g" 30.0 0 "g" 0.2 0

    $mark 0 = 0
    $space 0 = 0
    $w cmd plstyl 0 $mark $space

    $w cmd plcol 3
    $w cmd pllab "Angle (degrees)" "sine" "#frPLplot Example 1 - Sine function"

    matrix x f 101
    matrix y f 101

    for {set i 0} {$i < 101} {incr i} {
	$x $i = [expr 3.6 * $i]
	$y $i = [expr sin([$x $i] * 3.141592654 / 180.0)]
    }

    $w cmd plcol 4
    $w cmd plline 101 $x $y
}

###############################################################################
