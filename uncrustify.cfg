#
# Uncrustify configuration for PLplot style
#

indent_with_tabs		= 0		# 1=indent with tabs, 2=indent to level only
indent_columns			= 4
indent_brace			= 0
indent_class			= true		# Indent class body

nl_enum_brace			= add		# "enum {" vs "enum \n {"
nl_union_brace			= add		# "union {" vs "union \n {"
nl_struct_brace			= add		# "struct {" vs "struct \n {"
nl_do_brace			= add		# "do {" vs "do \n {"
nl_if_brace			= add		# "if () {" vs "if () \n {"
nl_for_brace			= add		# "for () {" vs "for () \n {"
nl_else_brace			= add		# "else {" vs "else \n {"
nl_while_brace			= add		# "while () {" vs "while () \n {"
nl_switch_brace			= add		# "switch () {" vs "switch () \n {"
nl_fcall_brace			= add		# "foo() {" vs "foo()\n{"
nl_fdef_brace			= add		# "int foo() {" vs "int foo()\n{"
nl_brace_else			= add
nl_assign_leave_one_liners	= true		# Don't split one-line braced assignments
nl_class_leave_one_liners	= true		# Don't split one-line braced statements inside s class
nl_enum_leave_one_liners	= true		# Don't split one-line enums

sp_before_semi			= remove
sp_paren_paren			= remove	# space between (( and ))
sp_return_paren			= force 	# "return (1);" vs "return(1);"
sp_sizeof_paren			= force 	# "sizeof (int)" vs "sizeof(int)"
sp_before_sparen		= force		# "if (" vs "if("
sp_after_sparen			= force		# "if () {" vs "if (){"
sp_after_cast			= force 	# "(int) a" vs "(int)a"
sp_inside_braces		= force		# "{ 1 }" vs "{1}"
sp_inside_braces_struct		= force		# "{ 1 }" vs "{1}"
sp_inside_braces_enum		= force		# "{ 1 }" vs "{1}"
sp_inside_paren			= force
sp_inside_fparen		= force
sp_inside_sparen		= force
sp_assign			= force
sp_arith			= force
sp_bool				= force
sp_compare			= force
sp_enum_assign			= force
sp_after_comma			= force
sp_func_def_paren		= remove	# "int foo (){" vs "int foo(){"
sp_func_call_paren		= remove	# "foo (" vs "foo("
sp_func_proto_paren		= remove	# "int foo ();" vs "int foo();"
sp_defined_paren		= force


#
# Code alignment (not left column spaces/tabs)
#

# Whether to keep non-indenting tabs
align_keep_tabs                          = false    # false/true

# Whether to use tabs for alinging
align_with_tabs                          = false    # false/true

# Whether to bump out to the next tab when aligning
align_on_tabstop                         = false    # false/true

# Whether to left-align numbers
align_number_left                        = true	    # false/true

# Align variable definitions in prototypes and functions
align_func_params                        = false    # false/true

# Align parameters in single-line functions that have the same name.
# The function names must already be aligned with each other.
align_same_func_call_params              = false    # false/true

# The span for aligning variable definitions (0=don't align)
align_var_def_span                       = 2        # number

# How to align the star in variable definitions.
#  0=Part of the type     'void *   foo;'
#  1=Part of the variable 'void     *foo;'
#  2=Dangling             'void    *foo;'
align_var_def_star_style                 = 1        # number

# How to align the '&' in variable definitions.
#  0=Part of the type
#  1=Part of the variable
#  2=Dangling
align_var_def_amp_style                  = 0        # number

# The threshold for aligning variable definitions (0=no limit)
align_var_def_thresh                     = 0        # number

# The gap for aligning variable definitions
align_var_def_gap                        = 0        # number

# Whether to align the colon in struct bit fields
align_var_def_colon                      = true    # false/true

# Whether to align any attribute after the variable name
align_var_def_attribute                  = false    # false/true

# Whether to align inline struct/enum/union variable definitions
align_var_def_inline                     = true    # false/true

# The span for aligning on '=' in assignments (0=don't align)
align_assign_span                        = 1        # number

# The threshold for aligning on '=' in assignments (0=no limit)
align_assign_thresh                      = 0        # number

# The span for aligning on '=' in enums (0=don't align)
align_enum_equ_span                      = 4        # number

# The threshold for aligning on '=' in enums (0=no limit)
align_enum_equ_thresh                    = 0        # number

# The span for aligning struct/union (0=don't align)
align_var_struct_span                    = 3        # number

# The threshold for aligning struct/union member definitions (0=no limit)
align_var_struct_thresh                  = 0        # number

# The gap for aligning struct/union member definitions
align_var_struct_gap                     = 0        # number

# The span for aligning struct initializer values (0=don't align)
align_struct_init_span                   = 3        # number

# The minimum space between the type and the synonym of a typedef
align_typedef_gap                        = 3        # number

# The span for aligning single-line typedefs (0=don't align)
align_typedef_span                       = 5        # number

# How to align typedef'd functions with other typedefs
# 0: Don't mix them at all
# 1: align the open paren with the types
# 2: align the function type name with the other type names
align_typedef_func                       = 0        # number

# Controls the positioning of the '*' in typedefs. Just try it.
# 0: Align on typdef type, ignore '*'
# 1: The '*' is part of type name: typedef int  *pint;
# 2: The '*' is part of the type, but dangling: typedef int *pint;
align_typedef_star_style                 = 0        # number

# Controls the positioning of the '&' in typedefs. Just try it.
# 0: Align on typdef type, ignore '&'
# 1: The '&' is part of type name: typedef int  &pint;
# 2: The '&' is part of the type, but dangling: typedef int &pint;
align_typedef_amp_style                  = 0        # number

# The span for aligning comments that end lines (0=don't align)
align_right_cmt_span                     = 3        # number

# If aligning comments, mix with comments after '}' and #endif with less than 3 spaces before the comment
align_right_cmt_mix                      = false    # false/true

# If a trailing comment is more than this number of columns away from the text it follows,
# it will qualify for being aligned.
align_right_cmt_gap                      = 0        # number

# Align trailing comment at or beyond column N; 'pulls in' comments as a bonus side effect (0=ignore)
align_right_cmt_at_col                   = 0        # number

# The span for aligning function prototypes (0=don't align)
align_func_proto_span                    = 0        # number

# Minimum gap between the return type and the function name.
align_func_proto_gap                     = 0        # number

# Align function protos on the 'operator' keyword instead of what follows
align_on_operator                        = false    # false/true

# Whether to mix aligning prototype and variable declarations.
# If true, align_var_def_XXX options are used instead of align_func_proto_XXX options.
align_mix_var_proto                      = false    # false/true

# Align single-line functions with function prototypes, uses align_func_proto_span
align_single_line_func                   = false    # false/true

# Aligning the open brace of single-line functions.
# Requires align_single_line_func=true, uses align_func_proto_span
align_single_line_brace                  = false    # false/true

# Gap for align_single_line_brace.
align_single_line_brace_gap              = 0        # number

# The span for aligning ObjC msg spec (0=don't align)
align_oc_msg_spec_span                   = 0        # number

# Whether to align macros wrapped with a backslash and a newline.
# This will not work right if the macro contains a multi-line comment.
align_nl_cont                            = true    # false/true

# The minimum space between label and value of a preprocessor define
align_pp_define_gap                      = 4        # number

# The span for aligning on '#define' bodies (0=don't align)
align_pp_define_span                     = 3        # number

# Align lines that start with '<<' with previous '<<'. Default=true
align_left_shift                         = true     # false/true

cmt_star_cont			= TRUE 
cmt_multi_check_last		= FALSE

eat_blanks_before_close_brace	= TRUE
eat_blanks_after_open_brace	= TRUE


#
# Line Splitting options
#

# Try to limit code width to N number of columns
code_width                               = 80        # number

# Whether to fully split long 'for' statements at semi-colons
ls_for_split_full                        = true    # false/true

# Whether to fully split long function protos/calls at commas
ls_func_split_full                       = true    # false/true

# True:  indent continued function call parameters one indent level
# False: align parameters under the open paren
indent_func_call_param                   = true    # false/true

# Same as indent_func_call_param, but for function defs
indent_func_def_param                    = true    # false/true

# Same as indent_func_call_param, but for function protos
indent_func_proto_param                  = true    # false/true

