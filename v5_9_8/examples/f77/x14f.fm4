c      $Id$
c      Demo of multiple stream/window capability
c
c      Copyright (C) 2004  Arjen Markus
c      Copyright (C) 2004  Alan W. Irwin
c
c      This file is part of PLplot.
c
c      PLplot is free software; you can redistribute it and/or modify
c      it under the terms of the GNU Library General Public License as
c      published by the Free Software Foundation; either version 2 of the
c      License, or (at your option) any later version.
c
c      PLplot is distributed in the hope that it will be useful,
c      but WITHOUT ANY WARRANTY; without even the implied warranty of
c      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
c      GNU Library General Public License for more details.
c
c      You should have received a copy of the GNU Library General Public
c      License along with PLplot; if not, write to the Free Software
c      Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA

c Plots several simple functions from other example programs.
c
c This version sends the output of the first 4 plots (one page) to two
c independent streams.

      implicit none

      integer digmax

      character*80 driver
      character*15 geometry_master
      character*15 geometry_slave

      integer fam, num, bmax

      real*8  x(101), y(101)
      real*8  xs(6), ys(6)
      real*8  xscale, yscale, xoff, yoff
      common /plotdat/ x, y, xs, ys, xscale, yscale, xoff, yoff
c      some fortran compilers demand typing of intrinsic lnblnk, and
c      although this is not demanded on g77 it also works there.
      integer lnblnk
      include 'plplot_parameters.h'
      real*8 xp0, yp0
      integer xleng0, yleng0, xoff0, yoff0
      logical valid_geometry

      geometry_master = '500x410+100+200'
      geometry_slave = '500x410+650+200'

c      Process command-line arguments
      call plparseopts(PL_PARSE_FULL)

c      If valid geometry specified on command line, use it for both streams.
      call plgpage(xp0, yp0, xleng0, yleng0, xoff0, yoff0)
      valid_geometry = (xleng0 .gt. 0 .and. yleng0 .gt. 0)

c      Set up first stream

      if(valid_geometry) then
         call plspage(xp0, yp0, xleng0, yleng0, xoff0, yoff0)
      else
         call plsetopt( 'geometry', geometry_master)
      endif

      call plssub(2, 2)
      call plinit()

      call plgdev(driver)
      call plgfam(fam,num,bmax)

      write(6,'(3A)') 'Demo of multiple output streams via the ',
     &  driver(:lnblnk(driver)), ' driver.'
      write(6,'(A)') 'Running with the second stream as slave '//
     &  'to the first.'
      write(6,*)
c      flush unit 6 so this part of stdout is guaranteed to be written prior
c      to stdout generated by second plinit below.
      call flush(6)

c      Start next stream

      call plsstrm(1)

      if(valid_geometry) then
         call plspage(xp0, yp0, xleng0, yleng0, xoff0, yoff0)
      else
         call plsetopt( 'geometry', geometry_slave)
      endif

c      Turn off pause to make this a slave (must follow master)

      call plspause(0)
      call plsdev(driver)
      call plsfam(fam,num,bmax)
      call plsetopt('fflen','2')
      call plinit()

c      Set up the data & plot
c      Original case

      call plsstrm(0)

      xscale = 6.d0
      yscale = 1.d0
      xoff = 0.d0
      yoff = 0.d0
      call plot1()

c      Set up the data & plot

      xscale = 1.d0
      yscale = 1.d+6
      call plot1()

c      Set up the data & plot

      xscale = 1.d0
      yscale = 1.d-6
      digmax = 2
      call plsyax(digmax, 0)
      call plot1()

c      Set up the data & plot

      xscale = 1.d0
      yscale = 0.0014d0
      yoff = 0.0185d0
      digmax = 5
      call plsyax(digmax, 0)
      call plot1()

c      To slave
c      The pleop() ensures the eop indicator gets lit.

      call plsstrm(1)
      call plot4()
      call pleop()

c      Back to master

      call plsstrm(0)
      call plot2()
      call plot3()

c      To slave

      call plsstrm(1)
      call plot5()
      call pleop()

c      Back to master to wait for user to advance

      call plsstrm(0)
      call pleop()

c      Call plend to finish off.

      call plend()
      end

c======================================================================

      subroutine plot1()
      implicit none

      real*8 x(101), y(101)
      real*8 xs(6), ys(6)
      real*8  xscale, yscale, xoff, yoff,
     &  xmin, xmax, ymin, ymax
      integer i
      common /plotdat/ x, y, xs, ys, xscale, yscale, xoff, yoff

      do i = 1, 60
        x(i) = xoff + xscale * dble(i)/60.0d0
        y(i) = yoff + yscale * x(i)**2
      enddo

      xmin = x(1)
      xmax = x(60)
      ymin = y(1)
      ymax = y(60)

      do i = 1, 6
        xs(i) = x((i-1)*10+4)
        ys(i) = y((i-1)*10+4)
      enddo

c      Set up the viewport and window using PLENV. The range in X is
c      0.0 to 6.0, and the range in Y is 0.0 to 30.0. The axes are
c      scaled separately (just = 0), and we just draw a labelled
c      box (axis = 0).

      call plcol0(1)
      call plenv( xmin, xmax, ymin, ymax, 0, 0 )
      call plcol0(6)
      call pllab( '(x)', '(y)', '#frPLplot Example 1 - y=x#u2' )

c      Plot the data points

      call plcol0(9)
      call plpoin( 6, xs, ys, 9 )

c      Draw the line through the data

      call plcol0(4)
      call plline( 60, x, y )
      call plflush
      end

c======================================================================

      subroutine plot2()
      implicit none
      real*8  x(101), y(101)
      real*8  xs(6), ys(6)
      real*8  xscale, yscale, xoff, yoff
      integer i
      common /plotdat/ x, y, xs, ys, xscale, yscale, xoff, yoff

c======================================================================
c
c      Set up the viewport and window using PLENV. The range in X is
c      -2.0 to 10.0, and the range in Y is -0.4 to 2.0. The axes are
c      scaled separately (just = 0), and we draw a box with axes
c      (axis = 1).

      call plcol0(1)
      call plenv(-2.0d0, 10.0d0, -0.4d0, 1.2d0, 0, 1 )
      call plcol0(2)
      call pllab( '(x)', 'sin(x)/x',
     &            '#frPLplot Example 1 - Sinc Function' )

c      Fill up the arrays

      do i = 1, 100
        x(i) = (i-20.0d0)/6.0d0
        y(i) = 1.0d0
        if (x(i) .ne. 0.0d0) y(i) = sin(x(i)) / x(i)
      enddo
c      Draw the line

      call plcol0(3)
      call plline( 100, x, y )
      call plflush
      end

c======================================================================

      subroutine plot3()
c
c      For the final graph we wish to override the default tick intervals,
c      and so do not use_ PLENV
      implicit none

      include 'plplot_parameters.h'
      real*8  x(101), y(101)
      real*8  xs(6), ys(6)
      real*8  xscale, yscale, xoff, yoff
      integer i
      common /plotdat/ x, y, xs, ys, xscale, yscale, xoff, yoff
      call pladv(0)

c      Use_ standard viewport, and define X range from 0 to 360 degrees,
c      Y range from -1.2 to 1.2.

      call plvsta()
      call plwind( 0.0d0, 360.0d0, -1.2d0, 1.2d0 )

c      Draw a box with ticks spaced 60 degrees apart in X, and 0.2 in Y.

      call plcol0(1)
      call plbox( 'bcnst', 60.0d0, 2, 'bcnstv', 0.2d0, 2 )

c      Superimpose a dashed line grid, with 1.5 mm marks and spaces. With
c      only a single mark and space element, we do not need arrays

      call plstyl( 1, 1500, 1500 )
      call plcol0(2)
      call plbox( 'g', 30.0d0, 0, 'g', 0.2d0, 0 )
      call plstyl( 0, 0, 0 )

      call plcol0(3)
      call pllab( 'Angle (degrees)', 'sine',
     &            '#frPLplot Example 1 - Sine function' )

      do i = 1, 101
        x(i) = 3.6d0 * (i-1)
        y(i) = sin( x(i) * PI/180.0d0 )
      enddo

      call plcol0(4)
      call plline( 101, x, y )
      call plflush
      end

c======================================================================

      subroutine plot4()
      implicit none

      character*3 text
      real*8 x0(0:360), y0(0:360)
      real*8 x(0:360), y(0:360), dtr, theta, dx, dy, r
      integer i, j, nsp
      include 'plplot_parameters.h'

      dtr = PI/180.0d0
      do i=0,360
        x0(i) = cos(dtr * dble (i))
        y0(i) = sin(dtr * dble (i))
      enddo

c      Set up viewport and window, but do not draw box

      call plenv(-1.3d0, 1.3d0, -1.3d0, 1.3d0, 1, -2)
      do i = 1,10
        do j = 0,360
          x(j) = 0.1d0*i*x0(j)
          y(j) = 0.1d0*i*y0(j)
        enddo

c        Draw circles for polar grid

        call plline(361,x,y)
      enddo
      call plcol0(2)
      do i = 0,11
        theta = 30.0d0*i
        dx = cos(dtr*theta)
        dy = sin(dtr*theta)

c        Draw radial spokes for polar grid

        call pljoin(0.0d0, 0.0d0, dx, dy)
        write (text,'(i3)') nint(theta)

c        Write labels for angle

        text = text(nsp(text):)
c        Slightly off zero to avoid floating point logic flips at
c        90 and 270 deg.
        if (dx.ge.-0.00001d0) then
          call plptex(dx, dy, dx, dy, -0.15d0, text)
        else
          call plptex(dx, dy, -dx, -dy, 1.15d0, text)
        end if
      enddo
c      Draw the graph

      do i=0,360
        r = sin(dtr*dble (5*i))
        x(i) = x0(i) * r
        y(i) = y0(i) * r
      enddo
      call plcol0(3)
      call plline(361,x,y)

      call plcol0(4)
      call plmtex('t', 2.0d0, 0.5d0, 0.5d0,
     &  '#frPLplot Example 3 - r(#gh)=sin 5#gh')

c      Flush the plot at end

      call plflush
      end

c======================================================================

      integer function nsp(text)
c      ==================

c      Find first non-space character
      implicit none

      character*(*) text
      integer l, len

      l = len(text)
      nsp = 1
      do while(text(nsp:nsp).eq.' ' .and. nsp.lt.l)
        nsp = nsp+1
      enddo
      end

c======================================================================

      subroutine plot5()

      implicit none
      include 'plplot_parameters.h'
      integer i, j, nptsx, nptsy, xdim, ydim
c      xdim and ydim are the absolute static dimensions.
c      nptsx, and nptsy are the (potentially dynamic) defined area of the 2D
c      arrays that is actually used.
      parameter (xdim=99, ydim=100, nptsx=35,nptsy=46)

      real*8 z(xdim, ydim), w(xdim, ydim), clevel(11),
     &  xg1(xdim), yg1(ydim),
     &  xg2(xdim, ydim), yg2(xdim, ydim)
      real*8 tr, xx, yy, argx, argy, distort

cDEC$ ATTRIBUTES DLLIMPORT :: PLPLOT
      common /plplot/ tr(6)

      data clevel /-1.d0, -0.8d0, -0.6d0, -0.4d0, -0.2d0,
     &  0.d0, 0.2d0, 0.4d0, 0.6d0 ,0.8d0, 1.d0/

      tr(1) = 2.d0/dble(nptsx-1)
      tr(2) = 0.0d0
      tr(3) = -1.0d0
      tr(4) = 0.0d0
      tr(5) = 2.d0/dble(nptsy-1)
      tr(6) = -1.0d0

c      Calculate the data matrices.
4     do i=1,nptsx
        xx = dble(i-1-(nptsx/2))/dble (nptsx/2)
        do j=1,nptsy
          yy = dble(j-1-(nptsy/2))/dble (nptsy/2) - 1.0d0
          z(i,j) = xx*xx - yy*yy
          w(i,j) = 2.d0*xx*yy
        enddo
      enddo

c      Build the 1-d coord arrays.
      distort = 0.4d0
      do i=1,nptsx
        xx = -1.d0 + dble(i-1)*2.d0/dble(nptsx-1)
        xg1(i) = xx + distort*cos(0.5d0*PI*xx)
      enddo

      do j=1,nptsy
        yy = -1.d0 + dble(j-1)*2.d0/dble(nptsy-1)
        yg1(j) = yy - distort*cos(0.5d0*PI*yy)
      enddo

c      Build the 2-d coord arrays.
      do i=1,nptsx
        xx = -1.d0 + dble(i-1)*2.d0/dble(nptsx-1)
        argx = 0.5d0*PI*xx
        do j=1,nptsy
          yy = -1.d0 + dble(j-1)*2.d0/dble(nptsy-1)
          argy = 0.5d0*PI*yy
          xg2(i,j) = xx + distort*cos(argx)*cos(argy)
          yg2(i,j) = yy - distort*cos(argx)*cos(argy)
        enddo
      enddo

c      Plot using identity transform
      call plenv(-1.0d0, 1.0d0, -1.0d0, 1.0d0, 0, 0)
      call plcol0(2)
      call plcont(z,xdim,ydim,1,nptsx,1,nptsy,clevel,11)
      call plstyl(1,1500,1500)
      call plcol0(3)
      call plcont(w,xdim,ydim,1,nptsx,1,nptsy,clevel,11)
      call plstyl(0,1500,1500)
      call plcol0(1)
      call pllab('X Coordinate', 'Y Coordinate',
     &  'Streamlines of flow')

      call plflush
      end
