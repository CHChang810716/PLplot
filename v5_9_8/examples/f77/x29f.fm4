c  $Id$
c
c   Sample plots using date / time formatting for axes
c
c   Copyright (C) 2008  Andrew Ross
c
c   This file is part of PLplot.
c
c   PLplot is free software; you can redistribute it and/or modify
c   it under the terms of the GNU Library General Public License as
c   published by the Free Software Foundation; either version 2 of the
c   License, or (at your option) any later version.
c
c   PLplot is distributed in the hope that it will be useful,
c   but WITHOUT ANY WARRANTY; without even the implied warranty of
c   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
c   GNU Library General Public License for more details.
c
c   You should have received a copy of the GNU Library General Public
c   License along with PLplot; if not, write to the Free Software
c   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
c

      program x29f

      implicit none
      include 'plplot_parameters.h'

      real*8 x(365), y(365), xerr1(365), xerr2(365), yerr1(365), 
     &     yerr2(365)
      common /plotdat/ x, y, xerr1, xerr2, yerr1, yerr2

      call plparseopts(PL_PARSE_FULL)

      call plinit()

c     This is the ASCII value for character @
      call plsesc(64)

      call plot1()
      call plot2()
      call plot3()
      call plot4()

      call plend()
      end

c====================================================================
c
c     Plot a model diurnal cycle of temperature
c     
      subroutine plot1()
      implicit none
      include 'plplot_parameters.h'

      real*8 x(365), y(365), xerr1(365), xerr2(365), yerr1(365), 
     &     yerr2(365)
      common /plotdat/ x, y, xerr1, xerr2, yerr1, yerr2

      integer i, npts
      real*8 xmin, xmax, ymin, ymax

      parameter(npts = 73)
      parameter(xmin = 0.0d0)
      parameter(xmax = 60.0d0*60.0d0*24.0d0)
      parameter(ymin = 10.0d0)
      parameter(ymax = 20.0d0)

      do i = 1,npts
      	 x(i) = xmax*(dble(i-1)/dble(npts))
         y(i) = 15.0d0 - 5.0d0*cos(2.0d0*PI*dble(i-1)/dble(npts))
c     Set x error bars to +/- 5 minute 
         xerr1(i) = x(i)-60.0d0*5.0d0
         xerr2(i) = x(i)+60.0d0*5.0d0
c     Set y error bars to +/- 0.1 deg C
         yerr1(i) = y(i)-0.1d0
         yerr2(i) = y(i)+0.1d0
      enddo

      call pladv(0)
      
c     Rescale major ticks marks by 0.5
      call plsmaj(0.0d0,0.5d0)
c     Rescale minor ticks and error bar marks by 0.5
      call plsmin(0.0d0,0.5d0)
   
      call plvsta()
      call plwind(xmin, xmax, ymin, ymax)

c     Draw a box with ticks spaced every 3 hour in X and 1 degree C in Y.
      call plcol0(1)
c     Set time format to be hours:minutes
      call pltimefmt("%H:%M")
      call plbox("bcnstd", 3.0d0*60.0d0*60.0d0, 3, "bcnstv", 1.0d0, 5)

      call plcol0(3)
      call pllab("Time (hours:mins)", "Temperature (degC)", 
     &     "@frPLplot Example 29 - Daily temperature")
  
      call plcol0(4)

      call plline(npts, x, y)
      call plcol0(2)
      call plerrx(npts, xerr1, xerr2, y)
      call plcol0(3)
      call plerry(npts, x, yerr1, yerr2)

c     Rescale major / minor tick marks back to default
      call plsmin(0.0d0,1.0d0)
      call plsmaj(0.0d0,1.0d0)

      end

c
c     Plot the number of hours of daylight as a function of day for a year
c
      subroutine plot2() 
      implicit none
      include 'plplot_parameters.h'
      
      integer j, npts
      real*8 xmin, xmax, ymin, ymax
      real*8 lat, p, d
      real*8 x(365), y(365), xerr1(365), xerr2(365), yerr1(365), 
     &     yerr2(365)
      common /plotdat/ x, y, xerr1, xerr2, yerr1, yerr2


c Latitude for London
      parameter (lat = 51.5d0)

      parameter (npts = 365)

      parameter(xmin = 0.0d0)
      parameter(xmax = npts*60.0d0*60.0d0*24.0d0)
      parameter(ymin = 0)
      parameter(ymax = 24)

c     Formula for hours of daylight from 
c     "A Model Comparison for Daylength as a Function of Latitude and 
c     Day of the Year", 1995, Ecological Modelling, 80, pp 87-95.
      do j=1,npts
         x(j) = (j-1)*60.0d0*60.0d0*24.0d0
         p = asin(0.39795d0*cos(0.2163108d0 + 2.0d0*atan(0.9671396d0*
     &        tan(0.00860d0*(j-187)))))
         d = 24.0d0 - (24.0d0/PI)*
     &        acos( (sin(0.8333d0*PI/180.0d0) + sin(lat*PI/180.0d0)*
     &        sin(p)) / (cos(lat*PI/180.0d0)*cos(p)) )
         y(j) = d
      enddo

      call plcol0(1)
c     Set time format to be abbreviated month name followed by day of month
      call pltimefmt("%b %d")
      call plprec(1,1)
      call plenv(xmin, xmax, ymin, ymax, 0, 40)
      
      call plcol0(3)
      call pllab("Date", "Hours of daylight", 
     &     "@frPLplot Example 29 - Hours of daylight at 51.5N")
  
      call plcol0(4)

      call plline(npts, x, y)

      call plprec(0,0)
  
      end

c
c
c
      subroutine plot3()
      implicit none
      include 'plplot_parameters.h'
      
      integer i, npts
      real*8 xmin, xmax, ymin, ymax
      integer tstart, t1, t2
      real*8 toff
      real*8 x(365), y(365), xerr1(365), xerr2(365), yerr1(365), 
     &     yerr2(365)
      common /plotdat/ x, y, xerr1, xerr2, yerr1, yerr2

c     integer tm(9)

      parameter (npts = 62)

c     number of seconds elapsed since the Unix epoch (1970-01-01, UTC) for
c     2005-12-01, UTC.  This is the same result as the Python
c     calendar.timegm((2005,12,1,0,0,0)) result or the Linux C timegm
c     result corresponding to 2005-12-01.
      tstart = 1133395200

      xmin = dble(tstart)
      xmax = xmin + npts*60.0d0*60.0d0*24.0d0
      ymin = 0.0d0
      ymax = 5.0d0
  
      do i=1,npts
         x(i) = xmin + dble(i-1)*60.0d0*60.0d0*24.0d0
         y(i) = 1.0d0 + sin( 2.0d0*PI*dble(i-1)/7.0d0) + 
     &     exp( dble(min(i-1,npts+1-i)) / 31.0d0)
      enddo
      call pladv(0)

      call plvsta()
      call plwind(xmin, xmax, ymin, ymax)

      call plcol0(1)
c     Set time format to be ISO 8601 standard YYYY-MM-DD. Note that this is
c     equivalent to %f for C99 compliant implementations of strftime.
      call pltimefmt("%Y-%m-%d")
c     Draw a box with ticks spaced every 14 days in X and 1 hour in Y.
      call plbox("bcnstd", 14.0d0*24.0d0*60.0d0*60.0d0,14, "bcnstv", 
     &     1.0d0, 4)

      call plcol0(3)
      call pllab("Date", "Hours of television watched", 
     &     "@frPLplot Example 29 - Hours of television watched in " //
     &     "Dec 2005 / Jan 2006")
  
      call plcol0(4)

      call plssym(0.0d0,0.5d0)
      call plpoin(npts, x, y, 2)
      call plline(npts, x, y)
 
      end

c
c
c
      subroutine plot4() 
      implicit none

c     TAI-UTC (seconds) as a function of time.
c     Use Besselian epochs as the continuous time interval just to prove
c     this does not introduce any issues.
  
      real*8 scale, offset1, offset2
      real*8 xmin, xmax, ymin, ymax, xlabel_step
      integer kind, npts, i
      logical if_TAI_time_format
      character*10 time_format
      character*100 title_suffix
      character*100 xtitle
      character*100 title
      real*8 x(1001), y(1001)
      integer tai_year, tai_month, tai_day, tai_hour, tai_min
      real*8 tai_sec, tai
      integer utc_year, utc_month, utc_day, utc_hour, utc_min
      real*8 utc_sec, utc
      integer lnblnk
      
c     Use the definition given in http://en.wikipedia.org/wiki/Besselian_epoch
c     B = 1900. + (JD -2415020.31352)/365.242198781 
c     ==> (as calculated with aid of "bc -l" command)
c     B = (MJD + 678940.364163900)/365.242198781
c     ==>
c     MJD = B*365.24219878 - 678940.364163900
      scale = 365.242198781d0
      offset1 = -678940.0d0
      offset2 = -0.3641639d0
      call plconfigtime(scale, offset1, offset2, z'0', 0, 0, 0, 0, 0, 
     1     0, 0.d0)

      do kind = 0,6
         if (kind .eq. 0) then
            call plctime(1950,0,2,0,0,0.d0,xmin)
            call plctime(2020,0,2,0,0,0.d0,xmax)
            npts = 70*12 + 1
            ymin = 0.0d0
            ymax = 36.0d0
            time_format="%Y%"
            if_TAI_time_format = .true.
            title_suffix = "from 1950 to 2020"
            xtitle =  "Year"
            xlabel_step = 10.0d0
         elseif ((kind .eq. 1) .or. (kind .eq. 2)) then
            call plctime(1961,7,1,0,0,1.64757d0-.20d0, xmin)
            call plctime(1961,7,1,0,0,1.64757d0+.20d0, xmax)
            npts = 1001
            ymin = 1.625d0
            ymax = 1.725d0
            time_format = "%S%2%"
            title_suffix = "near 1961-08-01 (TAI)"
            xlabel_step = 0.05d0/(scale*86400.0d0)
            if (kind .eq. 1) then
               if_TAI_time_format = .true.
               xtitle = "Seconds (TAI)"
            else
               if_TAI_time_format = .false.
               xtitle = "Seconds (TAI) labelled with corresponding UTC"
            endif
         elseif ((kind .eq. 3) .or. (kind .eq. 4)) then
            call plctime(1963,10,1,0,0,2.6972788d0-.20d0, xmin)
            call plctime(1963,10,1,0,0,2.6972788d0+.20d0, xmax)
            npts = 1001
            ymin = 2.55d0
            ymax = 2.75d0
            time_format = "%S%2%"
            title_suffix = "near 1963-11-01 (TAI)"
            xlabel_step = 0.05d0/(scale*86400.0d0)
            if (kind .eq. 3) then
               if_TAI_time_format = .true.
               xtitle = "Seconds (TAI)"
            else
               if_TAI_time_format = .false.
               xtitle = "Seconds (TAI) labelled with corresponding UTC"
            endif
         elseif ((kind .eq. 5) .or. (kind .eq. 6)) then
            call plctime(2009,0,1,0,0,34.d0-5.d0,xmin)
            call plctime(2009,0,1,0,0,34.d0+5.d0,xmax)
            npts = 1001
            ymin = 32.5d0
            ymax = 34.5d0
            time_format = "%S%2%"
            title_suffix = "near 2009-01-01 (TAI)"
            xlabel_step = 1.d0/(scale*86400.d0)
            if (kind .eq. 5) then
               if_TAI_time_format = .true.
               xtitle = "Seconds (TAI)"
            else 
               if_TAI_time_format = .false.
               xtitle = "Seconds (TAI) labelled with corresponding UTC"
            endif
         endif

         do i=0,npts-1
            x(i+1) = xmin + i*(xmax-xmin)/(dble(npts-1))
            call plconfigtime(scale, offset1, offset2, z'0', 0, 0, 0, 0, 
     1           0, 0, 0.d0)
            tai = x(i+1)
            call plbtime(tai_year, tai_month, tai_day, tai_hour, 
     1           tai_min, tai_sec, tai)
            call plconfigtime(scale, offset1, offset2, z'2', 0, 0, 0, 
     1           0, 0, 0, 0.d0)
            call plbtime(utc_year, utc_month, utc_day, utc_hour, 
     1           utc_min, utc_sec, tai)
            call plconfigtime(scale, offset1, offset2, z'0', 0, 0, 0, 
     1           0, 0, 0, 0.d0)
            call plctime(utc_year, utc_month, utc_day, utc_hour, 
     1           utc_min, utc_sec, utc)
            y(i+1)=(tai-utc)*scale*86400.d0
         enddo

         call pladv(0)
         call plvsta()
         call plwind(xmin, xmax, ymin, ymax)
         call plcol0(1)
         if (if_TAI_time_format) then
            call plconfigtime(scale, offset1, offset2, z'0', 0, 0, 0, 
     1           0, 0, 0, 0.d0)
         else
            call plconfigtime(scale, offset1, offset2, z'2', 0, 0, 0, 
     1           0, 0, 0, 0.d0)
         endif
         call pltimefmt(time_format)
         call plbox("bcnstd", xlabel_step, 0, "bcnstv", 0.d0, 0)
         call plcol0(3)
         title = "@frPLplot Example 29 - TAI-UTC "//
     1        title_suffix(:lnblnk(title_suffix))
         call pllab(xtitle, "TAI-UTC (sec)", title)
    
         call plcol0(4)
         
         call plline(npts, x, y)
      enddo
      end
